"""
Comprehensive tests for Pending Order Manager functionality.

Tests limit/stop order placement, modification, cancellation, expiry handling,
and order monitoring capabilities.
"""

import pytest
import asyncio
from decimal import Decimal
from datetime import datetime, timezone, timedelta
from unittest.mock import Mock, AsyncMock, patch

from src.oanda.pending_order_manager import (
    OandaPendingOrderManager,
    OrderInfo,
    OrderResult,
    OrderType,
    OrderSide,
    TimeInForce,
    OrderStatus
)
from src.oanda.client import OandaClientInterface, MockOandaClient
from src.oanda.stream_manager import StreamManagerInterface, MockStreamManager


@pytest.fixture
def mock_oanda_client():
    """Mock OANDA client"""
    return MockOandaClient("test_account")


@pytest.fixture
def mock_price_stream():
    """Mock price stream manager"""
    return MockStreamManager()


@pytest.fixture
def order_manager(mock_oanda_client, mock_price_stream):
    """Pending order manager instance for testing"""
    return OandaPendingOrderManager(
        mock_oanda_client,
        mock_price_stream,
        refresh_interval=1.0
    )


@pytest.fixture
def sample_order_response():
    """Sample order creation response"""
    return {
        "orderCreateTransaction": {
            "id": "12345",
            "type": "ORDER_CREATE",
            "instrument": "EUR_USD",
            "units": "10000",
            "price": "1.0550"
        }
    }


@pytest.fixture
def sample_order_info():
    """Sample order info for testing"""
    return OrderInfo(
        order_id="12345",
        instrument="EUR_USD",
        order_type=OrderType.LIMIT,
        side=OrderSide.BUY,
        units=Decimal('10000'),
        price=Decimal('1.0550'),
        time_in_force=TimeInForce.GTC,
        status=OrderStatus.PENDING,
        created_at=datetime.now(timezone.utc)
    )


class TestLimitOrderPlacement:
    """Test suite for limit order placement"""
    
    @pytest.mark.asyncio
    async def test_place_buy_limit_order_success(
        self,
        order_manager,
        mock_oanda_client,
        sample_order_response
    ):
        """Test successful buy limit order placement"""
        # The MockOandaClient already returns appropriate mock data
        # No need to set return values as it's a real mock implementation
        
        # Place limit order
        result = await order_manager.place_limit_order(
            instrument="EUR_USD",
            units=10000,  # Positive for buy
            price="1.0550",  # Below market (valid for buy limit)
            time_in_force=TimeInForce.GTC
        )
        
        # Verify success
        assert result.success is True
        assert result.order_id is not None  # Will be auto-generated by MockOandaClient
        assert result.order_info is not None
        assert result.order_info.order_type == OrderType.LIMIT
        assert result.order_info.side == OrderSide.BUY
        assert result.order_info.price == Decimal('1.0550')
        
        # Verify order stored in manager
        assert result.order_id in order_manager.pending_orders
        
    @pytest.mark.asyncio
    async def test_place_sell_limit_order_success(
        self,
        order_manager,
        mock_oanda_client,
        sample_order_response
    ):
        """Test successful sell limit order placement"""
        # MockOandaClient provides appropriate mock data automatically
        
        # Place limit order
        result = await order_manager.place_limit_order(
            instrument="EUR_USD",
            units=-10000,  # Negative for sell
            price="1.0600",  # Above market of ~1.0576 (valid for sell limit)
            time_in_force=TimeInForce.GTC
        )
        
        # Verify success
        assert result.success is True
        assert result.order_info.side == OrderSide.SELL
        
    @pytest.mark.asyncio
    async def test_place_limit_order_invalid_price(
        self,
        order_manager,
        mock_oanda_client
    ):
        """Test limit order placement with invalid price"""
        # MockOandaClient provides appropriate mock pricing automatically
        
        # Try to place buy limit above market (invalid)
        result = await order_manager.place_limit_order(
            instrument="EUR_USD",
            units=10000,
            price="1.0600",  # Above market (invalid for buy limit)
            time_in_force=TimeInForce.GTC
        )
        
        # Verify failure
        assert result.success is False
        assert "Invalid limit order price" in result.message
        
        # Verify invalid price was rejected
        
    @pytest.mark.asyncio
    async def test_place_limit_order_with_gtd(
        self,
        order_manager,
        mock_oanda_client,
        sample_order_response
    ):
        """Test limit order placement with GTD time-in-force"""
        # MockOandaClient provides appropriate mock data automatically
        
        # Set expiry time
        expiry_time = datetime.now(timezone.utc) + timedelta(hours=24)
        
        # Place GTD limit order
        result = await order_manager.place_limit_order(
            instrument="EUR_USD",
            units=10000,
            price="1.0550",
            time_in_force=TimeInForce.GTD,
            expiry_time=expiry_time
        )
        
        # Verify success
        assert result.success is True
        assert result.order_info.time_in_force == TimeInForce.GTD
        assert result.order_info.expiry_time == expiry_time
        
        # Verify GTD order properties
        assert result.order_info.time_in_force == TimeInForce.GTD
        assert result.order_info.expiry_time == expiry_time
        
    @pytest.mark.asyncio
    async def test_place_limit_order_with_stop_loss_take_profit(
        self,
        order_manager,
        mock_oanda_client,
        sample_order_response
    ):
        """Test limit order placement with stop loss and take profit"""
        # MockOandaClient provides appropriate mock data automatically
        
        # Place limit order with SL/TP
        result = await order_manager.place_limit_order(
            instrument="EUR_USD",
            units=10000,
            price="1.0550",
            stop_loss="1.0530",
            take_profit="1.0580"
        )
        
        # Verify success
        assert result.success is True
        assert result.order_info.stop_loss == Decimal('1.0530')
        assert result.order_info.take_profit == Decimal('1.0580')
        
        # Verify SL/TP were set correctly
        assert result.order_info.stop_loss == Decimal('1.0530')
        assert result.order_info.take_profit == Decimal('1.0580')


class TestStopOrderPlacement:
    """Test suite for stop order placement"""
    
    @pytest.mark.asyncio
    async def test_place_buy_stop_order_success(
        self,
        order_manager,
        mock_oanda_client,
        sample_order_response
    ):
        """Test successful buy stop order placement"""
        # Mock current price (below stop price)
        mock_oanda_client.get.return_value = {
            "prices": [{
                "closeoutBid": "1.0525",
                "closeoutAsk": "1.0527"
            }]
        }
        
        # Mock order creation response
        sample_order_response["orderCreateTransaction"]["type"] = "STOP"
        mock_oanda_client.post.return_value = sample_order_response
        
        # Place stop order
        result = await order_manager.place_stop_order(
            instrument="EUR_USD",
            units=10000,  # Positive for buy
            price="1.0560",  # Above market (valid for buy stop)
            time_in_force=TimeInForce.GTC
        )
        
        # Verify success
        assert result.success is True
        assert result.order_info.order_type == OrderType.STOP
        assert result.order_info.side == OrderSide.BUY
        assert result.order_info.price == Decimal('1.0560')
        
    @pytest.mark.asyncio
    async def test_place_sell_stop_order_success(
        self,
        order_manager,
        mock_oanda_client,
        sample_order_response
    ):
        """Test successful sell stop order placement"""
        # Mock current price (above stop price)
        mock_oanda_client.get.return_value = {
            "prices": [{
                "closeoutBid": "1.0575",
                "closeoutAsk": "1.0577"
            }]
        }
        
        # Mock order creation response
        sample_order_response["orderCreateTransaction"]["type"] = "STOP"
        sample_order_response["orderCreateTransaction"]["units"] = "-10000"
        mock_oanda_client.post.return_value = sample_order_response
        
        # Place stop order
        result = await order_manager.place_stop_order(
            instrument="EUR_USD",
            units=-10000,  # Negative for sell
            price="1.0550",  # Below market (valid for sell stop)
            time_in_force=TimeInForce.GTC
        )
        
        # Verify success
        assert result.success is True
        assert result.order_info.side == OrderSide.SELL
        
    @pytest.mark.asyncio
    async def test_place_stop_order_invalid_price(
        self,
        order_manager,
        mock_oanda_client
    ):
        """Test stop order placement with invalid price"""
        # Mock current price
        mock_oanda_client.get.return_value = {
            "prices": [{
                "closeoutBid": "1.0575",
                "closeoutAsk": "1.0577"
            }]
        }
        
        # Try to place buy stop below market (invalid)
        result = await order_manager.place_stop_order(
            instrument="EUR_USD",
            units=10000,
            price="1.0550",  # Below market (invalid for buy stop)
            time_in_force=TimeInForce.GTC
        )
        
        # Verify failure
        assert result.success is False
        assert "Invalid stop order price" in result.message


class TestMarketIfTouchedOrders:
    """Test suite for market-if-touched order placement"""
    
    @pytest.mark.asyncio
    async def test_place_market_if_touched_order_success(
        self,
        order_manager,
        mock_oanda_client,
        sample_order_response
    ):
        """Test successful market-if-touched order placement"""
        # Mock current price
        mock_oanda_client.get.return_value = {
            "prices": [{
                "closeoutBid": "1.0575",
                "closeoutAsk": "1.0577"
            }]
        }
        
        # Mock order creation response
        sample_order_response["orderCreateTransaction"]["type"] = "MARKET_IF_TOUCHED"
        mock_oanda_client.post.return_value = sample_order_response
        
        # Place market-if-touched order
        result = await order_manager.place_market_if_touched_order(
            instrument="EUR_USD",
            units=10000,
            price="1.0590",
            time_in_force=TimeInForce.GTC
        )
        
        # Verify success
        assert result.success is True
        assert result.order_info.order_type == OrderType.MARKET_IF_TOUCHED
        assert result.order_info.price == Decimal('1.0590')


class TestOrderModification:
    """Test suite for order modification"""
    
    @pytest.mark.asyncio
    async def test_modify_order_price_success(
        self,
        order_manager,
        mock_oanda_client,
        sample_order_info
    ):
        """Test successful order price modification"""
        # Setup existing order
        order_manager.pending_orders["12345"] = sample_order_info
        
        # Mock current price for validation
        mock_oanda_client.get.return_value = {
            "prices": [{
                "closeoutBid": "1.0575",
                "closeoutAsk": "1.0577"
            }]
        }
        
        # Mock modification response
        mock_oanda_client.put.return_value = {
            "orderCreateTransaction": {
                "id": "12346",
                "type": "ORDER_CREATE"
            }
        }
        
        # Modify order price
        result = await order_manager.modify_pending_order(
            order_id="12345",
            new_price="1.0540"
        )
        
        # Verify success
        assert result.success is True
        assert result.order_info.price == Decimal('1.0540')
        
        # Verify API call
        mock_oanda_client.put.assert_called_once()
        
    @pytest.mark.asyncio
    async def test_modify_order_stop_loss_take_profit(
        self,
        order_manager,
        mock_oanda_client,
        sample_order_info
    ):
        """Test modifying order stop loss and take profit"""
        # Setup existing order
        order_manager.pending_orders["12345"] = sample_order_info
        
        # Mock current price for validation
        mock_oanda_client.get.return_value = {
            "prices": [{
                "closeoutBid": "1.0575",
                "closeoutAsk": "1.0577"
            }]
        }
        
        # Mock modification response
        mock_oanda_client.put.return_value = {
            "orderCreateTransaction": {
                "id": "12345",
                "type": "ORDER_CREATE"
            }
        }
        
        # Modify SL/TP
        result = await order_manager.modify_pending_order(
            order_id="12345",
            new_stop_loss="1.0520",
            new_take_profit="1.0590"
        )
        
        # Verify success
        assert result.success is True
        assert result.order_info.stop_loss == Decimal('1.0520')
        assert result.order_info.take_profit == Decimal('1.0590')
        
    @pytest.mark.asyncio
    async def test_modify_nonexistent_order(
        self,
        order_manager,
        mock_oanda_client
    ):
        """Test modifying non-existent order"""
        result = await order_manager.modify_pending_order(
            order_id="nonexistent",
            new_price="1.0540"
        )
        
        # Verify failure
        assert result.success is False
        assert "not found" in result.message
        
        # Verify no API call
        mock_oanda_client.put.assert_not_called()


class TestOrderCancellation:
    """Test suite for order cancellation"""
    
    @pytest.mark.asyncio
    async def test_cancel_single_order_success(
        self,
        order_manager,
        mock_oanda_client,
        sample_order_info
    ):
        """Test successful single order cancellation"""
        # Setup existing order
        order_manager.pending_orders["12345"] = sample_order_info
        
        # Mock cancellation response
        mock_oanda_client.put.return_value = {
            "orderCancelTransaction": {
                "id": "cancel_12345",
                "type": "ORDER_CANCEL"
            }
        }
        
        # Cancel order
        result = await order_manager.cancel_pending_order("12345")
        
        # Verify success
        assert result.success is True
        assert "12345" not in order_manager.pending_orders
        
        # Verify API call
        mock_oanda_client.put.assert_called_once_with(
            "/v3/accounts/test_account/orders/12345/cancel"
        )
        
    @pytest.mark.asyncio
    async def test_cancel_all_orders_success(
        self,
        order_manager,
        mock_oanda_client
    ):
        """Test successful cancellation of all orders"""
        # Setup multiple orders
        order1 = OrderInfo(
            order_id="order1", instrument="EUR_USD", order_type=OrderType.LIMIT,
            side=OrderSide.BUY, units=Decimal('10000'), price=Decimal('1.0550'),
            time_in_force=TimeInForce.GTC, status=OrderStatus.PENDING
        )
        order2 = OrderInfo(
            order_id="order2", instrument="GBP_USD", order_type=OrderType.STOP,
            side=OrderSide.SELL, units=Decimal('5000'), price=Decimal('1.2480'),
            time_in_force=TimeInForce.GTC, status=OrderStatus.PENDING
        )
        
        order_manager.pending_orders["order1"] = order1
        order_manager.pending_orders["order2"] = order2
        
        # Mock cancellation responses
        mock_oanda_client.put.return_value = {
            "orderCancelTransaction": {
                "id": "cancel_tx",
                "type": "ORDER_CANCEL"
            }
        }
        
        # Cancel all orders
        results = await order_manager.cancel_all_orders()
        
        # Verify all orders cancelled
        assert len(results) == 2
        assert all(result.success for result in results.values())
        assert len(order_manager.pending_orders) == 0
        
        # Verify API calls
        assert mock_oanda_client.put.call_count == 2
        
    @pytest.mark.asyncio
    async def test_cancel_orders_filtered_by_instrument(
        self,
        order_manager,
        mock_oanda_client
    ):
        """Test cancelling orders filtered by instrument"""
        # Setup orders for different instruments
        order1 = OrderInfo(
            order_id="order1", instrument="EUR_USD", order_type=OrderType.LIMIT,
            side=OrderSide.BUY, units=Decimal('10000'), price=Decimal('1.0550'),
            time_in_force=TimeInForce.GTC, status=OrderStatus.PENDING
        )
        order2 = OrderInfo(
            order_id="order2", instrument="GBP_USD", order_type=OrderType.LIMIT,
            side=OrderSide.BUY, units=Decimal('5000'), price=Decimal('1.2520'),
            time_in_force=TimeInForce.GTC, status=OrderStatus.PENDING
        )
        
        order_manager.pending_orders["order1"] = order1
        order_manager.pending_orders["order2"] = order2
        
        # Mock cancellation response
        mock_oanda_client.put.return_value = {
            "orderCancelTransaction": {
                "id": "cancel_tx",
                "type": "ORDER_CANCEL"
            }
        }
        
        # Cancel only EUR_USD orders
        results = await order_manager.cancel_all_orders(instrument="EUR_USD")
        
        # Verify only EUR_USD order cancelled
        assert len(results) == 1
        assert "order1" in results
        assert results["order1"].success
        assert "order1" not in order_manager.pending_orders
        assert "order2" in order_manager.pending_orders  # GBP_USD order remains


class TestOrderViewing:
    """Test suite for order viewing and status"""
    
    @pytest.mark.asyncio
    async def test_get_pending_orders_all(
        self,
        order_manager,
        mock_oanda_client
    ):
        """Test getting all pending orders"""
        # Setup orders
        order1 = OrderInfo(
            order_id="order1", instrument="EUR_USD", order_type=OrderType.LIMIT,
            side=OrderSide.BUY, units=Decimal('10000'), price=Decimal('1.0550'),
            time_in_force=TimeInForce.GTC, status=OrderStatus.PENDING
        )
        order2 = OrderInfo(
            order_id="order2", instrument="GBP_USD", order_type=OrderType.STOP,
            side=OrderSide.SELL, units=Decimal('5000'), price=Decimal('1.2480'),
            time_in_force=TimeInForce.GTC, status=OrderStatus.PENDING
        )
        
        order_manager.pending_orders["order1"] = order1
        order_manager.pending_orders["order2"] = order2
        
        # Mock refresh response
        mock_oanda_client.get.return_value = {
            "orders": [
                {"id": "order1", "state": "PENDING"},
                {"id": "order2", "state": "PENDING"}
            ]
        }
        
        # Get all pending orders
        orders = await order_manager.get_pending_orders()
        
        # Verify results
        assert len(orders) == 2
        order_ids = [order.order_id for order in orders]
        assert "order1" in order_ids
        assert "order2" in order_ids
        
    @pytest.mark.asyncio
    async def test_get_pending_orders_filtered(
        self,
        order_manager,
        mock_oanda_client
    ):
        """Test getting pending orders with filters"""
        # Setup orders
        order1 = OrderInfo(
            order_id="order1", instrument="EUR_USD", order_type=OrderType.LIMIT,
            side=OrderSide.BUY, units=Decimal('10000'), price=Decimal('1.0550'),
            time_in_force=TimeInForce.GTC, status=OrderStatus.PENDING
        )
        order2 = OrderInfo(
            order_id="order2", instrument="EUR_USD", order_type=OrderType.STOP,
            side=OrderSide.SELL, units=Decimal('5000'), price=Decimal('1.0480'),
            time_in_force=TimeInForce.GTC, status=OrderStatus.PENDING
        )
        
        order_manager.pending_orders["order1"] = order1
        order_manager.pending_orders["order2"] = order2
        
        # Mock refresh response
        mock_oanda_client.get.return_value = {"orders": []}
        
        # Get orders filtered by type
        orders = await order_manager.get_pending_orders(order_type=OrderType.LIMIT)
        
        # Verify filtering
        assert len(orders) == 1
        assert orders[0].order_type == OrderType.LIMIT
        
    @pytest.mark.asyncio
    async def test_get_order_status_existing(
        self,
        order_manager,
        mock_oanda_client,
        sample_order_info
    ):
        """Test getting status of existing order"""
        # Setup order
        order_manager.pending_orders["12345"] = sample_order_info
        
        # Mock current price
        mock_oanda_client.get.return_value = {
            "prices": [{
                "closeoutBid": "1.0575",
                "closeoutAsk": "1.0577"
            }]
        }
        
        # Get order status
        order = await order_manager.get_order_status("12345")
        
        # Verify order returned
        assert order is not None
        assert order.order_id == "12345"
        assert order.current_distance is not None
        
    @pytest.mark.asyncio
    async def test_get_order_status_not_found(
        self,
        order_manager,
        mock_oanda_client
    ):
        """Test getting status of non-existent order"""
        # Mock order not found response
        mock_oanda_client.get.return_value = {}
        
        # Get order status
        order = await order_manager.get_order_status("nonexistent")
        
        # Verify None returned
        assert order is None


class TestPriceValidation:
    """Test suite for price validation logic"""
    
    def test_validate_limit_order_price_buy(self, order_manager):
        """Test limit order price validation for buy orders"""
        current_price = Decimal('1.0576')
        
        # Valid buy limit (below market)
        assert order_manager._validate_limit_order_price(
            Decimal('10000'), Decimal('1.0550'), current_price
        ) is True
        
        # Invalid buy limit (above market)
        assert order_manager._validate_limit_order_price(
            Decimal('10000'), Decimal('1.0600'), current_price
        ) is False
        
    def test_validate_limit_order_price_sell(self, order_manager):
        """Test limit order price validation for sell orders"""
        current_price = Decimal('1.0576')
        
        # Valid sell limit (above market)
        assert order_manager._validate_limit_order_price(
            Decimal('-10000'), Decimal('1.0600'), current_price
        ) is True
        
        # Invalid sell limit (below market)
        assert order_manager._validate_limit_order_price(
            Decimal('-10000'), Decimal('1.0550'), current_price
        ) is False
        
    def test_validate_stop_order_price_buy(self, order_manager):
        """Test stop order price validation for buy orders"""
        current_price = Decimal('1.0576')
        
        # Valid buy stop (above market)
        assert order_manager._validate_stop_order_price(
            Decimal('10000'), Decimal('1.0600'), current_price
        ) is True
        
        # Invalid buy stop (below market)
        assert order_manager._validate_stop_order_price(
            Decimal('10000'), Decimal('1.0550'), current_price
        ) is False
        
    def test_validate_stop_order_price_sell(self, order_manager):
        """Test stop order price validation for sell orders"""
        current_price = Decimal('1.0576')
        
        # Valid sell stop (below market)
        assert order_manager._validate_stop_order_price(
            Decimal('-10000'), Decimal('1.0550'), current_price
        ) is True
        
        # Invalid sell stop (above market)
        assert order_manager._validate_stop_order_price(
            Decimal('-10000'), Decimal('1.0600'), current_price
        ) is False


class TestPipCalculations:
    """Test suite for pip value and distance calculations"""
    
    def test_get_pip_value_standard_pairs(self, order_manager):
        """Test pip values for standard currency pairs"""
        assert order_manager._get_pip_value("EUR_USD") == Decimal('0.0001')
        assert order_manager._get_pip_value("GBP_USD") == Decimal('0.0001')
        assert order_manager._get_pip_value("AUD_USD") == Decimal('0.0001')
        
    def test_get_pip_value_jpy_pairs(self, order_manager):
        """Test pip values for JPY currency pairs"""
        assert order_manager._get_pip_value("USD_JPY") == Decimal('0.01')
        assert order_manager._get_pip_value("EUR_JPY") == Decimal('0.01')
        assert order_manager._get_pip_value("GBP_JPY") == Decimal('0.01')
        
    def test_calculate_price_distance(self, order_manager):
        """Test price distance calculation in pips"""
        # Standard pair distance
        distance = order_manager._calculate_price_distance(
            Decimal('1.0550'), Decimal('1.0530'), "EUR_USD"
        )
        assert distance == Decimal('200')  # 20 pips * 10 (0.0020 / 0.0001)
        
        # JPY pair distance
        distance = order_manager._calculate_price_distance(
            Decimal('150.50'), Decimal('150.00'), "USD_JPY"
        )
        assert distance == Decimal('50')  # 50 pips (0.50 / 0.01)


class TestOrderMonitoring:
    """Test suite for order monitoring and expiry"""
    
    @pytest.mark.asyncio
    async def test_order_expiry_check(
        self,
        order_manager,
        mock_oanda_client
    ):
        """Test order expiry checking and cleanup"""
        # Setup expired order
        expired_order = OrderInfo(
            order_id="expired_order",
            instrument="EUR_USD",
            order_type=OrderType.LIMIT,
            side=OrderSide.BUY,
            units=Decimal('10000'),
            price=Decimal('1.0550'),
            time_in_force=TimeInForce.GTD,
            status=OrderStatus.PENDING,
            expiry_time=datetime.now(timezone.utc) - timedelta(minutes=5)  # Expired
        )
        
        order_manager.pending_orders["expired_order"] = expired_order
        
        # Mock cancellation response
        mock_oanda_client.put.return_value = {
            "orderCancelTransaction": {
                "id": "cancel_tx",
                "type": "ORDER_CANCEL"
            }
        }
        
        # Trigger expiry check
        await order_manager._check_order_expiry()
        
        # Verify expired order was cancelled
        assert "expired_order" not in order_manager.pending_orders
        mock_oanda_client.put.assert_called_once()


class TestPerformanceMetrics:
    """Test suite for order performance metrics"""
    
    @pytest.mark.asyncio
    async def test_get_order_performance_metrics(
        self,
        order_manager,
        mock_oanda_client,
        sample_order_info
    ):
        """Test getting performance metrics for an order"""
        # Setup order with times
        sample_order_info.created_at = datetime.now(timezone.utc) - timedelta(hours=2)
        sample_order_info.expiry_time = datetime.now(timezone.utc) + timedelta(hours=22)
        sample_order_info.stop_loss = Decimal('1.0530')
        sample_order_info.take_profit = Decimal('1.0580')
        
        order_manager.pending_orders["12345"] = sample_order_info
        
        # Mock current price
        mock_oanda_client.get.return_value = {
            "prices": [{
                "closeoutBid": "1.0575",
                "closeoutAsk": "1.0577"
            }]
        }
        
        # Get performance metrics
        metrics = await order_manager.get_order_performance_metrics("12345")
        
        # Verify metrics
        assert metrics["order_id"] == "12345"
        assert metrics["instrument"] == "EUR_USD"
        assert metrics["order_type"] == "LIMIT"
        assert metrics["side"] == "BUY"
        assert "distance_pips" in metrics
        assert "distance_percentage" in metrics
        assert "age_hours" in metrics
        assert "time_to_expiry_hours" in metrics
        assert "stop_loss_distance_pips" in metrics
        assert "take_profit_distance_pips" in metrics


class TestErrorHandling:
    """Test suite for error handling scenarios"""
    
    @pytest.mark.asyncio
    async def test_api_error_handling(
        self,
        order_manager,
        mock_oanda_client
    ):
        """Test handling of API errors"""
        # Mock API error
        mock_oanda_client.get.side_effect = Exception("API error")
        
        # Try to place order
        result = await order_manager.place_limit_order(
            instrument="EUR_USD",
            units=10000,
            price="1.0550"
        )
        
        # Verify error handling
        assert result.success is False
        assert "Error placing limit order" in result.message
        
    @pytest.mark.asyncio
    async def test_invalid_order_response(
        self,
        order_manager,
        mock_oanda_client
    ):
        """Test handling of invalid order response"""
        # Mock current price
        mock_oanda_client.get.return_value = {
            "prices": [{
                "closeoutBid": "1.0575",
                "closeoutAsk": "1.0577"
            }]
        }
        
        # Mock invalid order response (missing orderCreateTransaction)
        mock_oanda_client.post.return_value = {"error": "Invalid request"}
        
        # Try to place order
        result = await order_manager.place_limit_order(
            instrument="EUR_USD",
            units=10000,
            price="1.0550"
        )
        
        # Verify error handling
        assert result.success is False
        assert "Failed to place limit order" in result.message


if __name__ == "__main__":
    # Run tests
    pytest.main([__file__, "-v"])
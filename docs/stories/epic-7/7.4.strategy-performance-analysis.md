# Story 7.4: Strategy Performance Analysis

## Status
Ready

## Story
**As an** analyst system,  
**I want** to evaluate strategy effectiveness,  
**so that** I can disable underperforming approaches.

## Acceptance Criteria
1. Individual strategy performance tracking with statistical significance
2. Market regime performance analysis (which strategies work when)
3. Correlation analysis between strategies for diversification
4. Underperformance detection with automatic strategy suspension
5. Strategy effectiveness reports generated weekly
6. Manual strategy enable/disable controls in dashboard

## Tasks / Subtasks

- [ ] Task 1: Build individual strategy tracking system (AC: 1)
  - [ ] Create strategy identification and classification
  - [ ] Implement statistical significance testing for performance
  - [ ] Build strategy performance metric calculation
  - [ ] Add strategy comparison and ranking
  - [ ] Create strategy lifecycle management
  
- [ ] Task 2: Develop market regime analysis (AC: 2)
  - [ ] Create market regime classification system
  - [ ] Build regime-specific performance tracking
  - [ ] Implement strategy-regime effectiveness mapping
  - [ ] Add regime transition impact analysis
  - [ ] Create regime-based strategy recommendations
  
- [ ] Task 3: Implement strategy correlation analysis (AC: 3)
  - [ ] Build strategy correlation calculation engine
  - [ ] Create diversification benefit analysis
  - [ ] Implement correlation-based portfolio optimization
  - [ ] Add correlation monitoring and alerts
  - [ ] Create correlation visualization and reporting
  
- [ ] Task 4: Build underperformance detection system (AC: 4)
  - [ ] Create performance degradation detection
  - [ ] Implement automatic suspension triggers
  - [ ] Build performance recovery monitoring
  - [ ] Add suspension notification and logging
  - [ ] Create strategy rehabilitation process
  
- [ ] Task 5: Develop weekly reporting system (AC: 5)
  - [ ] Create comprehensive strategy effectiveness reports
  - [ ] Build performance trend analysis
  - [ ] Implement strategy ranking and recommendations
  - [ ] Add executive summary generation
  - [ ] Create automated report distribution
  
- [ ] Task 6: Build manual strategy controls (AC: 6)
  - [ ] Create strategy enable/disable interface
  - [ ] Implement manual override controls
  - [ ] Build strategy configuration management
  - [ ] Add manual control audit logging
  - [ ] Create strategy control dashboard

## Dev Notes

### Architecture Context
This story implements a comprehensive strategy performance analysis system that continuously evaluates the effectiveness of different trading strategies, identifies underperforming approaches, and provides recommendations for strategy optimization. This enables the system to maintain a portfolio of only the most effective strategies while adapting to changing market conditions.

### Strategy Analysis Framework
[Source: docs/architecture/strategy-analysis.md]
The analysis operates on multiple dimensions:
- **Individual Performance**: Each strategy evaluated independently
- **Market Regime Sensitivity**: How strategies perform in different market conditions
- **Cross-Strategy Correlation**: Diversification benefits and risks
- **Time-Based Analysis**: Performance evolution over time
- **Risk-Adjusted Metrics**: Performance relative to risk taken

### Data Models
[Source: docs/architecture/data-models.md]
```typescript
interface TradingStrategy {
  strategyId: string;
  strategyName: string;
  version: string;
  
  // Strategy Classification
  classification: {
    type: 'trend_following' | 'mean_reversion' | 'breakout' | 'pattern_recognition' | 'arbitrage';
    subtype: string;
    timeframe: string[];           // ['H1', 'H4', 'D1']
    symbols: string[];             // Applicable currency pairs
    marketRegimes: string[];       // Preferred market conditions
  };
  
  // Strategy Logic
  logic: {
    entryConditions: string[];
    exitConditions: string[];
    riskManagement: string[];
    signalGeneration: string;
    complexity: 'simple' | 'moderate' | 'complex';
  };
  
  // Performance Tracking
  performance: StrategyPerformance;
  
  // Lifecycle
  lifecycle: {
    createdAt: Date;
    activatedAt: Date;
    lastModified: Date;
    status: 'active' | 'suspended' | 'deprecated' | 'testing';
    suspensionReason?: string;
    suspendedAt?: Date;
  };
  
  // Configuration
  configuration: {
    enabled: boolean;
    weight: number;                // Portfolio allocation weight
    maxAllocation: number;         // Maximum portfolio percentage
    minTradesForEvaluation: number; // Minimum trades for statistical significance
    evaluationPeriod: number;      // Days
  };
}

interface StrategyPerformance {
  strategyId: string;
  
  // Overall Performance
  overall: {
    totalTrades: number;
    winCount: number;
    lossCount: number;
    winRate: number;
    profitFactor: number;
    expectancy: number;
    sharpeRatio: number;
    calmarRatio: number;
    maxDrawdown: number;
    averageWin: number;
    averageLoss: number;
    averageHoldTime: number;
    totalReturn: number;
    annualizedReturn: number;
  };
  
  // Statistical Significance
  significance: {
    sampleSize: number;
    confidenceLevel: number;
    pValue: number;
    confidenceInterval: [number, number];
    statisticallySignificant: boolean;
    requiredSampleSize: number;
    currentSignificanceLevel: number;
  };
  
  // Time-Based Performance
  timeBased: {
    daily: Record<string, DailyPerformance>;   // YYYY-MM-DD
    weekly: Record<string, WeeklyPerformance>; // YYYY-WW
    monthly: Record<string, MonthlyPerformance>; // YYYY-MM
    rolling30Day: PerformanceMetrics;
    rolling90Day: PerformanceMetrics;
    rolling365Day: PerformanceMetrics;
  };
  
  // Market Regime Performance
  regimePerformance: Record<string, RegimePerformance>;
  
  // Recent Performance Trend
  trend: {
    direction: 'improving' | 'stable' | 'declining';
    trendStrength: number;         // 0-1
    trendDuration: number;         // Days
    changeRate: number;            // Performance change per day
    projectedPerformance: number;  // 30-day projection
  };
  
  lastUpdated: Date;
}

interface RegimePerformance {
  regime: string;
  
  // Performance in this regime
  performance: PerformanceMetrics;
  
  // Regime characteristics
  characteristics: {
    volatility: 'low' | 'medium' | 'high';
    trend: 'strong_up' | 'weak_up' | 'sideways' | 'weak_down' | 'strong_down';
    volumeProfile: 'low' | 'normal' | 'high';
    timeOfDay: string[];           // Sessions where this regime occurs
  };
  
  // Strategy effectiveness in regime
  effectiveness: {
    preferredRegime: boolean;      // Is this a preferred regime for strategy?
    relativePerformance: number;   // vs overall performance
    consistency: number;           // Performance consistency in regime
    adaptability: number;          // How well strategy adapts to regime
  };
  
  // Sample statistics
  statistics: {
    occurrences: number;           // How often this regime occurs
    totalTrades: number;
    averageTradesPerOccurrence: number;
    regimeDuration: number;        // Average regime duration
  };
}

interface StrategyCorrelationAnalysis {
  analysisId: string;
  timestamp: Date;
  
  // Correlation Matrix
  correlationMatrix: Record<string, Record<string, number>>; // strategy1 -> strategy2 -> correlation
  
  // Portfolio Analysis
  portfolioAnalysis: {
    overallCorrelation: number;
    diversificationRatio: number;
    portfolioVolatility: number;
    individualVolatilities: Record<string, number>;
    correlationClusters: CorrelationCluster[];
  };
  
  // Diversification Benefits
  diversificationAnalysis: {
    currentDiversificationBenefit: number;
    potentialImprovement: number;
    recommendedWeightChanges: Record<string, number>;
    riskReduction: number;
    returnImpact: number;
  };
  
  // Risk Concentration
  riskConcentration: {
    concentrationRisk: number;     // 0-1, higher = more concentrated
    largestClusterWeight: number;
    independentStrategies: number;
    redundantStrategies: string[]; // Highly correlated strategies
  };
}

interface CorrelationCluster {
  clusterId: string;
  strategies: string[];
  averageCorrelation: number;
  clusterWeight: number;          // Total portfolio weight of cluster
  dominantStrategy: string;       // Best performing in cluster
  redundantStrategies: string[];  // Candidates for removal
}

interface UnderperformanceDetection {
  detectionId: string;
  strategyId: string;
  timestamp: Date;
  
  // Detection Criteria
  criteria: {
    detectionType: 'absolute_performance' | 'relative_performance' | 'consistency' | 'drawdown';
    threshold: number;
    evaluationPeriod: number;      // Days
    minimumTrades: number;
  };
  
  // Performance Issues
  issues: PerformanceIssue[];
  
  // Severity Assessment
  severity: {
    level: 'minor' | 'moderate' | 'severe' | 'critical';
    score: number;                 // 0-100
    impact: 'low' | 'medium' | 'high';
    urgency: 'low' | 'medium' | 'high';
  };
  
  // Recommendations
  recommendations: {
    immediateAction: 'monitor' | 'reduce_allocation' | 'suspend' | 'disable';
    rehabilitationPlan?: RehabilitationPlan;
    alternativeStrategies: string[];
    timeToReview: number;          // Days
  };
  
  // Automatic Actions
  automaticActions: {
    suspensionTriggered: boolean;
    allocationReduced: boolean;
    alertsSent: string[];
    manualReviewRequired: boolean;
  };
}

interface PerformanceIssue {
  issueType: 'low_win_rate' | 'high_drawdown' | 'poor_risk_reward' | 'inconsistent_performance' | 'regime_mismatch';
  description: string;
  severity: 'minor' | 'moderate' | 'severe';
  
  // Metrics
  currentValue: number;
  expectedValue: number;
  threshold: number;
  deviationMagnitude: number;
  
  // Trend
  trend: 'improving' | 'stable' | 'worsening';
  trendDuration: number;          // Days
  
  // Impact
  impactOnPortfolio: number;      // Portfolio performance impact
  riskContribution: number;       // Risk contribution
}

interface RehabilitationPlan {
  planId: string;
  strategyId: string;
  
  // Plan Details
  plan: {
    suspensionPeriod: number;      // Days
    monitoringMetrics: string[];
    recoveryThresholds: Record<string, number>;
    evaluationSchedule: number[];  // Days for evaluation checkpoints
  };
  
  // Recovery Tracking
  recovery: {
    currentPhase: 'suspended' | 'monitoring' | 'gradual_return' | 'full_return';
    progressScore: number;         // 0-100
    metricsImprovement: Record<string, number>;
    timeToFullRecovery: number;    // Estimated days
  };
  
  // Conditions for Return
  returnConditions: {
    minimumPerformancePeriod: number; // Days of good performance
    requiredMetrics: Record<string, number>;
    manualApprovalRequired: boolean;
    gradualReturnSteps: number[];  // Allocation percentages
  };
}

interface StrategyEffectivenessReport {
  reportId: string;
  reportDate: Date;
  reportPeriod: {
    start: Date;
    end: Date;
  };
  
  // Executive Summary
  executiveSummary: {
    totalStrategies: number;
    activeStrategies: number;
    suspendedStrategies: number;
    topPerformers: string[];       // Strategy IDs
    underperformers: string[];
    portfolioPerformance: PerformanceMetrics;
    diversificationScore: number;
    overallHealthScore: number;    // 0-100
  };
  
  // Strategy Rankings
  rankings: {
    byPerformance: StrategyRanking[];
    byRiskAdjustedReturn: StrategyRanking[];
    byConsistency: StrategyRanking[];
    byDiversificationBenefit: StrategyRanking[];
  };
  
  // Market Regime Analysis
  regimeAnalysis: {
    currentRegime: string;
    regimeStrategies: Record<string, string[]>; // regime -> preferred strategies
    regimeTransitions: RegimeTransition[];
    upcomingRegimeChanges: RegimeForecast[];
  };
  
  // Recommendations
  recommendations: {
    strategiesToActivate: string[];
    strategiesToSuspend: string[];
    allocationChanges: Record<string, number>;
    newStrategyNeeds: string[];    // Types of strategies needed
    portfolioOptimization: PortfolioOptimization;
  };
  
  // Action Items
  actionItems: {
    immediate: ActionItem[];       // This week
    shortTerm: ActionItem[];       // Next month
    longTerm: ActionItem[];        // Next quarter
  };
}

interface StrategyRanking {
  rank: number;
  strategyId: string;
  strategyName: string;
  score: number;
  metric: string;
  percentile: number;
  trend: 'up' | 'down' | 'stable';
  comments: string;
}

interface ActionItem {
  itemId: string;
  category: 'strategy_management' | 'allocation' | 'risk_management' | 'development';
  priority: 'low' | 'medium' | 'high' | 'critical';
  
  description: string;
  expectedImpact: string;
  estimatedEffort: string;
  deadline: Date;
  assignedTo: string;
  
  dependencies: string[];
  successCriteria: string[];
  riskMitigation: string[];
}
```

### Strategy Analysis Algorithms
[Source: docs/architecture/strategy-analysis-algorithms.md]
```python
class StrategyPerformanceAnalyzer:
    def __init__(self):
        self.significance_tester = StatisticalSignificanceTester()
        self.regime_classifier = MarketRegimeClassifier()
        self.correlation_analyzer = CorrelationAnalyzer()
        self.underperformance_detector = UnderperformanceDetector()
    
    def analyze_strategy_performance(self, strategy_id: str, 
                                   evaluation_period: timedelta) -> StrategyPerformance:
        # Gather strategy trade data
        trades = self.get_strategy_trades(strategy_id, evaluation_period)
        
        # Calculate overall performance metrics
        overall_performance = self.calculate_performance_metrics(trades)
        
        # Test statistical significance
        significance = self.significance_tester.test_significance(trades)
        
        # Analyze time-based performance
        time_based = self.analyze_time_based_performance(trades)
        
        # Analyze regime-specific performance
        regime_performance = self.analyze_regime_performance(trades)
        
        # Detect performance trends
        trend = self.detect_performance_trend(trades)
        
        return StrategyPerformance(
            overall=overall_performance,
            significance=significance,
            time_based=time_based,
            regime_performance=regime_performance,
            trend=trend
        )
    
    def analyze_regime_performance(self, trades: List[Trade]) -> Dict[str, RegimePerformance]:
        regime_performance = {}
        
        # Classify market regime for each trade
        for trade in trades:
            regime = self.regime_classifier.classify_regime(trade.timestamp)
            
            if regime not in regime_performance:
                regime_performance[regime] = {
                    'trades': [],
                    'regime_info': self.regime_classifier.get_regime_info(regime)
                }
            
            regime_performance[regime]['trades'].append(trade)
        
        # Calculate performance for each regime
        for regime, data in regime_performance.items():
            performance_metrics = self.calculate_performance_metrics(data['trades'])
            
            regime_performance[regime] = RegimePerformance(
                regime=regime,
                performance=performance_metrics,
                characteristics=data['regime_info'],
                effectiveness=self.calculate_regime_effectiveness(performance_metrics),
                statistics=self.calculate_regime_statistics(data['trades'])
            )
        
        return regime_performance

class UnderperformanceDetector:
    def __init__(self):
        self.thresholds = {
            'min_sharpe_ratio': 0.5,
            'max_drawdown': 0.15,        # 15%
            'min_win_rate': 0.45,        # 45%
            'min_profit_factor': 1.2,
            'min_trades_for_evaluation': 30
        }
    
    def detect_underperformance(self, strategy: TradingStrategy) -> Optional[UnderperformanceDetection]:
        performance = strategy.performance.overall
        
        # Check minimum sample size
        if performance.totalTrades < self.thresholds['min_trades_for_evaluation']:
            return None  # Insufficient data
        
        issues = []
        
        # Check various performance criteria
        if performance.sharpeRatio < self.thresholds['min_sharpe_ratio']:
            issues.append(PerformanceIssue(
                issue_type='poor_risk_reward',
                description=f"Sharpe ratio {performance.sharpeRatio:.2f} below threshold {self.thresholds['min_sharpe_ratio']}",
                severity='moderate',
                current_value=performance.sharpeRatio,
                expected_value=self.thresholds['min_sharpe_ratio'],
                threshold=self.thresholds['min_sharpe_ratio']
            ))
        
        if performance.maxDrawdown > self.thresholds['max_drawdown']:
            issues.append(PerformanceIssue(
                issue_type='high_drawdown',
                description=f"Drawdown {performance.maxDrawdown:.1%} exceeds threshold {self.thresholds['max_drawdown']:.1%}",
                severity='severe',
                current_value=performance.maxDrawdown,
                expected_value=self.thresholds['max_drawdown'],
                threshold=self.thresholds['max_drawdown']
            ))
        
        if performance.winRate < self.thresholds['min_win_rate']:
            issues.append(PerformanceIssue(
                issue_type='low_win_rate',
                description=f"Win rate {performance.winRate:.1%} below threshold {self.thresholds['min_win_rate']:.1%}",
                severity='moderate',
                current_value=performance.winRate,
                expected_value=self.thresholds['min_win_rate'],
                threshold=self.thresholds['min_win_rate']
            ))
        
        if not issues:
            return None  # No underperformance detected
        
        # Calculate severity
        severity = self.calculate_severity(issues)
        
        # Generate recommendations
        recommendations = self.generate_recommendations(issues, severity)
        
        return UnderperformanceDetection(
            strategy_id=strategy.strategyId,
            issues=issues,
            severity=severity,
            recommendations=recommendations
        )
    
    def calculate_severity(self, issues: List[PerformanceIssue]) -> dict:
        severity_scores = {'minor': 1, 'moderate': 2, 'severe': 3}
        total_score = sum(severity_scores[issue.severity] for issue in issues)
        max_possible = len(issues) * 3
        
        severity_percentage = (total_score / max_possible) * 100
        
        if severity_percentage >= 80:
            level = 'critical'
            impact = 'high'
            urgency = 'high'
        elif severity_percentage >= 60:
            level = 'severe'
            impact = 'medium'
            urgency = 'high'
        elif severity_percentage >= 40:
            level = 'moderate'
            impact = 'medium'
            urgency = 'medium'
        else:
            level = 'minor'
            impact = 'low'
            urgency = 'low'
        
        return {
            'level': level,
            'score': severity_percentage,
            'impact': impact,
            'urgency': urgency
        }
```

### Component Architecture
[Source: docs/architecture/backend-architecture.md]
```
agents/
├── strategy-analysis/
│   ├── StrategyPerformanceAnalyzer.py # Main analysis engine
│   ├── RegimeAnalyzer.py              # Market regime classification
│   ├── CorrelationAnalyzer.py         # Strategy correlation analysis
│   ├── UnderperformanceDetector.py    # Performance degradation detection
│   ├── StatisticalTester.py           # Statistical significance testing
│   ├── ReportGenerator.py             # Weekly effectiveness reports
│   └── StrategyController.py          # Manual enable/disable controls
```

### Testing Standards
- Test strategy performance calculation accuracy
- Verify statistical significance testing
- Test market regime classification accuracy
- Validate correlation analysis calculations
- Test underperformance detection sensitivity
- Verify report generation completeness

## Testing

### Test Requirements
[Source: docs/architecture/testing-strategy.md]
- **Unit Tests**: Performance calculations, statistical tests, correlation analysis
- **Integration Tests**: End-to-end strategy analysis pipeline
- **Statistical Tests**: Significance testing accuracy, correlation calculations
- **Performance Tests**: Analysis speed with large strategy datasets
- **Behavioral Tests**: Underperformance detection accuracy
- **Location**: `agents/strategy-analysis/__tests__/`

### Specific Testing Focus
- Strategy performance metric calculation accuracy
- Statistical significance testing validity
- Market regime classification consistency
- Correlation analysis mathematical correctness
- Underperformance detection sensitivity and specificity
- Report generation completeness and accuracy

### Mock Data Requirements
- Historical strategy performance data across market regimes
- Strategy correlation scenarios with known outcomes
- Underperforming strategy examples for detection testing
- Market regime transition data for classification testing
- Statistical significance test cases with known results

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-12 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation.*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here after implementation.*
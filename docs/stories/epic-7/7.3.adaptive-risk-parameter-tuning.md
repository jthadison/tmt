# Story 7.3: Adaptive Risk Parameter Tuning

## Status
Ready

## Story
**As an** optimization system,  
**I want** to adjust risk parameters based on performance,  
**so that** the system adapts to changing market conditions.

## Acceptance Criteria
1. Position size adjustments based on 30-day rolling performance
2. Stop loss distance optimization using recent volatility data
3. Take profit levels adjusted based on achieved vs expected results
4. Signal confidence threshold tuning (75% might become 78%)
5. Maximum 10% parameter change per month to prevent instability
6. Parameter change logging with performance impact tracking

## Tasks / Subtasks

- [ ] Task 1: Build position sizing optimization system (AC: 1)
  - [ ] Create 30-day rolling performance calculator
  - [ ] Implement Kelly Criterion-based sizing
  - [ ] Build confidence-based size adjustments
  - [ ] Add drawdown-aware sizing constraints
  - [ ] Create position sizing monitoring and validation
  
- [ ] Task 2: Develop stop loss optimization engine (AC: 2)
  - [ ] Implement volatility-based stop distance calculation
  - [ ] Create ATR-based stop loss optimization
  - [ ] Build market regime awareness for stops
  - [ ] Add stop loss effectiveness tracking
  - [ ] Create stop loss recommendation system
  
- [ ] Task 3: Build take profit optimization system (AC: 3)
  - [ ] Create achieved vs expected profit analysis
  - [ ] Implement dynamic profit target adjustment
  - [ ] Build market condition impact on profit targets
  - [ ] Add profit target effectiveness measurement
  - [ ] Create profit optimization recommendations
  
- [ ] Task 4: Implement signal confidence tuning (AC: 4)
  - [ ] Create signal confidence calibration system
  - [ ] Build performance-based threshold adjustment
  - [ ] Implement confidence score optimization
  - [ ] Add signal quality improvement tracking
  - [ ] Create confidence threshold monitoring
  
- [ ] Task 5: Build parameter change constraint system (AC: 5)
  - [ ] Implement 10% monthly change limits
  - [ ] Create parameter stability monitoring
  - [ ] Build gradual adjustment mechanisms
  - [ ] Add change impact assessment
  - [ ] Create constraint violation alerts
  
- [ ] Task 6: Develop parameter tracking and impact analysis (AC: 6)
  - [ ] Build comprehensive parameter change logging
  - [ ] Create performance impact attribution
  - [ ] Implement parameter effectiveness analysis
  - [ ] Add parameter rollback recommendations
  - [ ] Create parameter optimization reporting

## Dev Notes

### Architecture Context
This story implements the adaptive risk parameter tuning system that allows the trading system to optimize its risk management parameters based on actual performance data. This enables the system to adapt to changing market conditions while maintaining strict safety constraints to prevent parameter drift and instability.

### Adaptive Optimization Philosophy
[Source: docs/architecture/adaptive-optimization.md]
The parameter tuning follows these principles:
- **Evidence-Based**: All adjustments based on statistical evidence
- **Conservative Changes**: Small, gradual adjustments to prevent instability
- **Multi-Factor Analysis**: Consider multiple metrics before adjusting
- **Rollback Capability**: All changes can be reversed if performance degrades
- **Safety Constraints**: Hard limits prevent dangerous parameter values

### Risk Parameter Categories
[Source: docs/architecture/risk-parameters.md]
```
Risk Parameters:
├── Position Sizing
│   ├── Base Size Percentage
│   ├── Kelly Multiplier
│   ├── Maximum Position Size
│   └── Drawdown Reduction Factor
├── Stop Loss Management
│   ├── ATR Multiplier
│   ├── Minimum Stop Distance
│   ├── Maximum Stop Distance
│   └── Volatility Adjustment Factor
├── Take Profit Optimization
│   ├── Risk-Reward Ratio
│   ├── Profit Target Multiplier
│   ├── Market Condition Adjustments
│   └── Partial Profit Levels
└── Signal Filtering
    ├── Confidence Threshold
    ├── Signal Strength Minimum
    ├── Cross-Validation Requirements
    └── Pattern Reliability Thresholds
```

### Data Models
[Source: docs/architecture/data-models.md]
```typescript
interface RiskParameterSet {
  id: string;
  version: string;
  accountId: string;
  effectiveDate: Date;
  
  // Position Sizing Parameters
  positionSizing: {
    baseRiskPerTrade: number;         // 1.0% default
    kellyMultiplier: number;          // 0.25 (quarter Kelly)
    maxPositionSize: number;          // 3.0% maximum
    drawdownReductionFactor: number;  // 0.5 when in drawdown
    confidenceScaling: boolean;       // Scale size by signal confidence
    volatilityAdjustment: boolean;    // Reduce size in high volatility
  };
  
  // Stop Loss Parameters
  stopLoss: {
    atrMultiplier: number;           // 2.0x ATR default
    minStopDistance: number;         // 10 pips minimum
    maxStopDistance: number;         // 100 pips maximum
    volatilityFloor: number;         // Minimum volatility for calculation
    regimeAdjustment: Record<string, number>; // Trending vs ranging adjustments
  };
  
  // Take Profit Parameters
  takeProfit: {
    baseRiskRewardRatio: number;     // 2.0:1 default
    profitTargetMultiplier: number;  // 1.0 default
    marketConditionAdjustments: Record<string, number>;
    partialProfitLevels: number[];   // [0.5, 1.0, 1.5] R:R ratios
    maxProfitTarget: number;         // 200 pips maximum
  };
  
  // Signal Filtering Parameters
  signalFiltering: {
    confidenceThreshold: number;     // 0.75 default
    strengthMinimum: number;         // 0.6 default
    crossValidationRequired: boolean;
    patternReliabilityThreshold: number; // 0.65 default
    newsEventBuffer: number;         // 60 minutes before/after news
  };
  
  // Optimization Metadata
  optimization: {
    basedOnDataPeriod: {
      start: Date;
      end: Date;
      tradeCount: number;
    };
    optimizationReason: string;
    expectedImpact: string;
    confidence: number;              // Confidence in this optimization
    rollbackTrigger: RollbackTrigger;
  };
}

interface ParameterOptimization {
  optimizationId: string;
  timestamp: Date;
  accountId: string;
  
  // Analysis Period
  analysisPeriod: {
    start: Date;
    end: Date;
    tradeCount: number;
    marketRegimes: string[];
  };
  
  // Current Performance
  currentPerformance: {
    sharpeRatio: number;
    profitFactor: number;
    winRate: number;
    maxDrawdown: number;
    avgWin: number;
    avgLoss: number;
    expectancy: number;
  };
  
  // Optimization Results
  optimizations: ParameterAdjustment[];
  
  // Validation
  validation: {
    backtestResults: BacktestResult[];
    monteCarloResults: MonteCarloResult;
    sensitivityAnalysis: SensitivityAnalysis;
    riskAnalysis: RiskAnalysis;
  };
  
  // Implementation
  implementation: {
    implementationDate: Date;
    gradualRollout: boolean;
    rolloutPercentage: number;
    monitoringPeriod: number; // Days to monitor before full implementation
  };
}

interface ParameterAdjustment {
  parameterName: string;
  category: 'position_sizing' | 'stop_loss' | 'take_profit' | 'signal_filtering';
  
  // Change Details
  currentValue: number;
  proposedValue: number;
  changePercentage: number;
  changeReason: string;
  
  // Supporting Analysis
  analysis: {
    performanceImpact: number;       // Expected Sharpe ratio change
    riskImpact: number;              // Expected drawdown change
    confidenceLevel: number;         // Statistical confidence
    sampleSize: number;              // Trades used in analysis
    significance: number;            // P-value
  };
  
  // Constraints
  constraints: {
    withinMonthlyLimit: boolean;     // Within 10% monthly change
    withinSafetyBounds: boolean;     // Within predefined safe ranges
    correlationImpact: number;       // Impact on strategy correlation
  };
  
  // Implementation
  implementation: {
    approved: boolean;
    implementedAt?: Date;
    rollbackConditions: RollbackCondition[];
    monitoringMetrics: string[];
  };
}

interface PositionSizingOptimizer {
  accountId: string;
  
  // Kelly Criterion Calculation
  kellyCriterion: {
    winRate: number;
    avgWin: number;
    avgLoss: number;
    kellyPercentage: number;
    recommendedMultiplier: number;    // Conservative fraction of Kelly
  };
  
  // Rolling Performance Analysis
  rollingPerformance: {
    period: number;                   // 30 days
    windowStart: Date;
    windowEnd: Date;
    trades: number;
    sharpeRatio: number;
    calmarRatio: number;
    volatility: number;
    maxDrawdown: number;
  };
  
  // Size Recommendations
  recommendations: {
    currentBaseSize: number;
    recommendedBaseSize: number;
    adjustmentReason: string;
    expectedImpact: string;
    riskAssessment: string;
  };
}

interface StopLossOptimizer {
  accountId: string;
  symbol: string;
  
  // Volatility Analysis
  volatilityAnalysis: {
    currentATR: number;
    avgATR20: number;
    atrTrend: 'increasing' | 'stable' | 'decreasing';
    regimeVolatility: Record<string, number>; // Trending vs ranging
    timeOfDayVolatility: Record<string, number>;
  };
  
  // Stop Loss Effectiveness
  effectiveness: {
    currentStopDistance: number;
    stopHitRate: number;              // How often stops are hit
    avgStopSlippage: number;
    prematureStopRate: number;        // Stops hit then price reverses
    optimalStopDistance: number;
    expectedImprovement: number;
  };
  
  // Recommendations
  recommendations: {
    newATRMultiplier: number;
    adjustmentReason: string;
    expectedStopHitRate: number;
    expectedPerformanceImpact: number;
  };
}

interface TakeProfitOptimizer {
  accountId: string;
  
  // Achievement Analysis
  achievementAnalysis: {
    targetHitRate: number;            // How often TP is reached
    avgProfitRealized: number;        // vs target
    prematureExitRate: number;        // Exits before TP due to other reasons
    optimalExitPoints: number[];      // Best historical exit levels
  };
  
  // Market Condition Impact
  marketImpact: {
    trendingMarkets: {
      hitRate: number;
      avgProfit: number;
      recommendedRR: number;
    };
    rangingMarkets: {
      hitRate: number;
      avgProfit: number;
      recommendedRR: number;
    };
    volatileMarkets: {
      hitRate: number;
      avgProfit: number;
      recommendedRR: number;
    };
  };
  
  // Recommendations
  recommendations: {
    newRiskRewardRatio: number;
    adjustmentReason: string;
    expectedHitRate: number;
    expectedProfitImprovement: number;
  };
}

interface ParameterChangeLog {
  changeId: string;
  timestamp: Date;
  accountId: string;
  
  // Change Details
  parameterChanges: ParameterAdjustment[];
  implementationMethod: 'immediate' | 'gradual' | 'ab_test';
  
  // Authorization
  authorizedBy: 'system' | 'manual';
  approver?: string;
  approvalReason?: string;
  
  // Monitoring
  monitoring: {
    monitoringPeriod: number;         // Days
    monitoringMetrics: string[];
    alertThresholds: Record<string, number>;
    rollbackTriggers: RollbackCondition[];
  };
  
  // Performance Impact
  performanceTracking: {
    preChangeMetrics: PerformanceMetrics;
    postChangeMetrics?: PerformanceMetrics;
    impactAssessment?: ImpactAssessment;
    rollbackRecommendation?: boolean;
  };
}

interface RollbackCondition {
  conditionType: 'performance_degradation' | 'drawdown_increase' | 'volatility_spike' | 'manual_trigger';
  threshold: number;
  evaluationPeriod: number;         // Days
  triggerCount: number;             // How many times condition must be met
  severity: 'warning' | 'critical';
  automaticRollback: boolean;
}
```

### Optimization Algorithms
[Source: docs/architecture/optimization-algorithms.md]
```python
class AdaptiveRiskParameterTuner:
    def __init__(self):
        self.optimizers = {
            'position_sizing': PositionSizingOptimizer(),
            'stop_loss': StopLossOptimizer(),
            'take_profit': TakeProfitOptimizer(),
            'signal_filtering': SignalFilteringOptimizer()
        }
        
        self.constraints = ParameterConstraints()
        self.validator = ParameterValidator()
    
    def optimize_parameters(self, account_id: str, 
                          analysis_period: timedelta) -> ParameterOptimization:
        # Gather performance data
        performance_data = self.get_performance_data(account_id, analysis_period)
        
        # Run optimizations
        optimizations = []
        for optimizer_name, optimizer in self.optimizers.items():
            optimization = optimizer.optimize(performance_data)
            if optimization:
                optimizations.append(optimization)
        
        # Validate all optimizations
        validated_optimizations = []
        for opt in optimizations:
            if self.validator.validate_optimization(opt):
                validated_optimizations.append(opt)
        
        # Apply constraints
        constrained_optimizations = self.constraints.apply_constraints(
            validated_optimizations, account_id
        )
        
        # Create implementation plan
        implementation_plan = self.create_implementation_plan(constrained_optimizations)
        
        return ParameterOptimization(
            optimizations=constrained_optimizations,
            implementation=implementation_plan
        )

class PositionSizingOptimizer:
    def optimize(self, performance_data: PerformanceData) -> ParameterAdjustment:
        # Calculate Kelly Criterion
        kelly_percentage = self.calculate_kelly_criterion(performance_data)
        
        # Apply conservative multiplier (typically 0.25)
        conservative_kelly = kelly_percentage * 0.25
        
        # Consider recent performance
        recent_sharpe = performance_data.recent_sharpe_ratio
        baseline_sharpe = performance_data.baseline_sharpe_ratio
        
        # Adjust based on performance
        if recent_sharpe > baseline_sharpe * 1.2:  # 20% improvement
            size_adjustment = min(1.1, conservative_kelly / performance_data.current_size)
        elif recent_sharpe < baseline_sharpe * 0.8:  # 20% degradation
            size_adjustment = max(0.9, conservative_kelly / performance_data.current_size)
        else:
            size_adjustment = 1.0  # No change
        
        # Calculate new position size
        new_size = performance_data.current_size * size_adjustment
        
        # Ensure within bounds
        new_size = max(0.005, min(0.03, new_size))  # 0.5% to 3% bounds
        
        return ParameterAdjustment(
            parameter_name='base_risk_per_trade',
            current_value=performance_data.current_size,
            proposed_value=new_size,
            change_percentage=(new_size - performance_data.current_size) / performance_data.current_size,
            change_reason=f"Kelly criterion suggests {conservative_kelly:.3f}, recent Sharpe {recent_sharpe:.2f}"
        )
    
    def calculate_kelly_criterion(self, performance_data: PerformanceData) -> float:
        win_rate = performance_data.win_rate
        avg_win = performance_data.avg_win
        avg_loss = performance_data.avg_loss
        
        if avg_loss == 0:
            return 0  # Avoid division by zero
        
        # Kelly formula: f = (bp - q) / b
        # where b = avg_win/avg_loss, p = win_rate, q = 1 - win_rate
        b = avg_win / avg_loss
        p = win_rate
        q = 1 - win_rate
        
        kelly = (b * p - q) / b
        
        # Cap at reasonable maximum (5%)
        return max(0, min(0.05, kelly))

class StopLossOptimizer:
    def optimize(self, performance_data: PerformanceData) -> ParameterAdjustment:
        # Analyze stop loss effectiveness
        current_atr_multiplier = performance_data.current_stop_atr_multiplier
        
        # Calculate optimal ATR multiplier based on recent data
        optimal_multiplier = self.calculate_optimal_atr_multiplier(performance_data)
        
        # Conservative adjustment (max 20% change)
        max_change = 0.20
        adjustment_factor = min(max_change, abs(optimal_multiplier - current_atr_multiplier) / current_atr_multiplier)
        
        if optimal_multiplier > current_atr_multiplier:
            new_multiplier = current_atr_multiplier * (1 + adjustment_factor)
        else:
            new_multiplier = current_atr_multiplier * (1 - adjustment_factor)
        
        # Ensure within bounds (1.0 to 4.0)
        new_multiplier = max(1.0, min(4.0, new_multiplier))
        
        return ParameterAdjustment(
            parameter_name='stop_loss_atr_multiplier',
            current_value=current_atr_multiplier,
            proposed_value=new_multiplier,
            change_percentage=(new_multiplier - current_atr_multiplier) / current_atr_multiplier,
            change_reason=f"Optimization suggests {optimal_multiplier:.2f}x ATR for improved risk-reward"
        )
    
    def calculate_optimal_atr_multiplier(self, performance_data: PerformanceData) -> float:
        # Analyze various ATR multipliers and their outcomes
        multipliers = [1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0]
        best_multiplier = 2.0  # Default
        best_score = 0
        
        for multiplier in multipliers:
            # Simulate this multiplier on historical data
            simulated_results = self.simulate_atr_multiplier(performance_data, multiplier)
            
            # Score based on multiple factors
            score = (
                simulated_results.profit_factor * 0.4 +
                simulated_results.win_rate * 0.3 +
                (1 - simulated_results.max_drawdown) * 0.3
            )
            
            if score > best_score:
                best_score = score
                best_multiplier = multiplier
        
        return best_multiplier
```

### Component Architecture
[Source: docs/architecture/backend-architecture.md]
```
agents/
├── parameter-optimization/
│   ├── AdaptiveRiskParameterTuner.py # Main tuning orchestrator
│   ├── PositionSizingOptimizer.py    # Position size optimization
│   ├── StopLossOptimizer.py          # Stop loss optimization
│   ├── TakeProfitOptimizer.py        # Take profit optimization
│   ├── SignalFilteringOptimizer.py   # Signal threshold optimization
│   ├── ParameterConstraints.py       # Safety constraints and limits
│   ├── ParameterValidator.py         # Validation and testing
│   └── ParameterChangeLogger.py      # Change tracking and impact analysis
```

### Safety Constraints
[Source: docs/architecture/safety-constraints.md]
```python
class ParameterConstraints:
    def __init__(self):
        self.monthly_change_limits = {
            'position_sizing': 0.10,      # Max 10% change per month
            'stop_loss': 0.15,            # Max 15% change per month  
            'take_profit': 0.10,          # Max 10% change per month
            'signal_filtering': 0.05      # Max 5% change per month
        }
        
        self.absolute_bounds = {
            'base_risk_per_trade': (0.005, 0.030),    # 0.5% to 3%
            'atr_multiplier': (1.0, 4.0),             # 1x to 4x ATR
            'risk_reward_ratio': (1.0, 5.0),          # 1:1 to 5:1
            'confidence_threshold': (0.60, 0.90)      # 60% to 90%
        }
    
    def validate_change(self, adjustment: ParameterAdjustment, 
                       account_id: str) -> bool:
        # Check monthly change limit
        monthly_changes = self.get_monthly_changes(account_id, adjustment.category)
        if monthly_changes + abs(adjustment.change_percentage) > self.monthly_change_limits[adjustment.category]:
            return False
        
        # Check absolute bounds
        param_bounds = self.absolute_bounds.get(adjustment.parameter_name)
        if param_bounds:
            min_val, max_val = param_bounds
            if not (min_val <= adjustment.proposed_value <= max_val):
                return False
        
        return True
```

### Performance Impact Tracking
[Source: docs/architecture/performance-tracking.md]
The system tracks the impact of each parameter change:
- **Before/After Analysis**: Performance metrics before and after changes
- **Attribution Analysis**: Which changes contributed to performance differences
- **Rollback Triggers**: Automatic detection of negative impacts
- **Learning Feedback**: Feed results back to optimization algorithms

### Testing Standards
- Test optimization algorithms with historical data
- Verify constraint enforcement and safety bounds
- Test rollback triggers and procedures
- Validate statistical significance of optimizations
- Test gradual rollout mechanisms

## Testing

### Test Requirements
[Source: docs/architecture/testing-strategy.md]
- **Unit Tests**: Individual optimization algorithms, constraint validation
- **Integration Tests**: End-to-end optimization pipeline, parameter application
- **Backtesting**: Historical validation of optimization decisions
- **Statistical Tests**: Significance testing, optimization validity
- **Performance Tests**: Optimization speed, system impact
- **Location**: `agents/parameter-optimization/__tests__/`

### Specific Testing Focus
- Kelly Criterion calculation accuracy
- ATR-based stop loss optimization effectiveness
- Take profit level adjustment logic
- Signal confidence threshold optimization
- Parameter constraint enforcement
- Change impact attribution accuracy

### Optimization Validation
- **Historical Backtesting**: Test optimizations on past data
- **Monte Carlo Simulation**: Validate under various market scenarios
- **Cross-Validation**: Ensure optimizations don't overfit to recent data
- **Sensitivity Analysis**: Test robustness to parameter variations
- **Out-of-Sample Testing**: Validate on data not used for optimization

### Mock Data Requirements
- Historical performance data across different market regimes
- Various parameter configurations and their outcomes
- Market volatility data for stop loss optimization
- Signal confidence and outcome data for threshold tuning
- Parameter change scenarios for constraint testing

### Performance Benchmarks
- Parameter optimization: < 30 seconds per account
- Constraint validation: < 100ms per change
- Impact analysis: < 5 seconds per parameter change
- Rollback detection: < 1 minute after trigger condition
- Memory usage: < 100MB for optimization engine

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-12 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation.*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here after implementation.*
# Story 8.3: Market Order Execution

## Status
Ready

## Story
**As a** trader,
**I want** to place market orders through OANDA,
**so that** I can enter positions immediately at current market prices.

## Acceptance Criteria
1. Execute market buy/sell orders with < 100ms latency
2. Support position sizing in units (not lots)
3. Optional stop loss and take profit on order entry
4. Order fills return execution price and transaction ID
5. Client order ID tracking for TMT signal correlation
6. Slippage tracking (difference between expected and fill price)
7. Partial fill handling for large orders
8. Order rejection messages clearly explain reason

## Tasks / Subtasks
- [ ] Task 1: Build core order execution system (AC: 1, 2)
  - [ ] Create OandaOrderExecutor class
  - [ ] Implement market buy/sell order methods
  - [ ] Add unit-based position sizing logic
  - [ ] Optimize execution path for < 100ms latency
  - [ ] Create order validation pipeline
  - [ ] Add execution timing metrics

- [ ] Task 2: Implement stop loss and take profit (AC: 3)
  - [ ] Add optional SL/TP parameters to order requests
  - [ ] Implement SL/TP distance calculations
  - [ ] Create price level validation logic
  - [ ] Add SL/TP modification during execution
  - [ ] Implement guaranteed stop loss support
  - [ ] Create trailing stop loss options

- [ ] Task 3: Build order tracking and correlation (AC: 4, 5)
  - [ ] Generate unique client order IDs
  - [ ] Link TMT signals to OANDA orders
  - [ ] Store execution details in database
  - [ ] Create order status tracking
  - [ ] Implement transaction ID mapping
  - [ ] Add order lifecycle logging

- [ ] Task 4: Implement slippage monitoring (AC: 6)
  - [ ] Calculate expected vs actual fill prices
  - [ ] Track slippage statistics per instrument
  - [ ] Create slippage alerts for excessive drift
  - [ ] Add slippage reporting and analytics
  - [ ] Implement slippage-based execution quality scoring
  - [ ] Create slippage visualization tools

- [ ] Task 5: Handle partial fills and rejections (AC: 7, 8)
  - [ ] Implement partial fill tracking
  - [ ] Create remaining quantity management
  - [ ] Add order rejection handling
  - [ ] Parse OANDA error codes and messages
  - [ ] Implement retry logic for recoverable failures
  - [ ] Create detailed error reporting

## Dev Notes

### Architecture Context
Market Order Execution is the core trading functionality that enables immediate position entry through OANDA. This system must achieve sub-100ms execution while maintaining reliability and providing comprehensive tracking of all trades for compliance and analysis purposes.

### Previous Story Context
Builds on Stories 8.1-8.2 which provide authentication and account monitoring. The execution system uses established connections to place orders while tracking all execution details for comprehensive trade management.

### Technical Implementation Details

#### High-Performance Order Executor
```python
class OandaOrderExecutor:
    def __init__(self, client: OandaClient, metrics: MetricsCollector):
        self.client = client
        self.metrics = metrics
        self.order_cache = OrderCache()
        
    async def execute_market_order(
        self,
        instrument: str,
        units: int,
        side: OrderSide,
        stop_loss: Optional[Decimal] = None,
        take_profit: Optional[Decimal] = None,
        client_extensions: Optional[Dict] = None
    ) -> OrderResult:
        \"\"\"Execute market order with sub-100ms target\"\"\"
        start_time = time.perf_counter()
        
        # Generate unique client order ID
        client_order_id = self.generate_client_id()
        
        # Build order request
        order_request = {
            \"order\": {
                \"type\": \"MARKET\",
                \"instrument\": instrument,
                \"units\": str(units),
                \"clientExtensions\": {
                    \"id\": client_order_id,
                    \"tag\": client_extensions.get('tag', 'TMT'),
                    \"comment\": client_extensions.get('comment', '')\n                }\n            }\n        }\n        \n        # Add stop loss if specified\n        if stop_loss:\n            order_request[\"order\"][\"stopLossOnFill\"] = {\n                \"price\": str(stop_loss)\n            }\n            \n        # Add take profit if specified\n        if take_profit:\n            order_request[\"order\"][\"takeProfitOnFill\"] = {\n                \"price\": str(take_profit)\n            }\n        \n        try:\n            # Execute order\n            response = await self.client.post(\n                f\"/v3/accounts/{self.account_id}/orders\",\n                json=order_request\n            )\n            \n            # Calculate execution time\n            execution_time = (time.perf_counter() - start_time) * 1000\n            await self.metrics.record_execution_time(execution_time)\n            \n            # Process response\n            return await self.process_order_response(response, client_order_id)\n            \n        except Exception as e:\n            await self.handle_execution_error(e, client_order_id)\n            raise\n```

#### Slippage Monitoring System
```python\nclass SlippageMonitor:\n    def __init__(self):\n        self.slippage_history = defaultdict(list)\n        self.alert_threshold = Decimal('0.0005')  # 0.5 pips\n        \n    async def record_execution(self, order: OrderResult, expected_price: Decimal):\n        \"\"\"Record and analyze slippage\"\"\"\n        actual_price = Decimal(order.fill_price)\n        slippage = abs(actual_price - expected_price)\n        \n        # Store slippage data\n        self.slippage_history[order.instrument].append({\n            'timestamp': datetime.utcnow(),\n            'expected_price': expected_price,\n            'actual_price': actual_price,\n            'slippage': slippage,\n            'units': order.units\n        })\n        \n        # Check for excessive slippage\n        if slippage > self.alert_threshold:\n            await self.send_slippage_alert(order.instrument, slippage)\n            \n    def get_slippage_stats(self, instrument: str, period_hours: int = 24) -> Dict:\n        \"\"\"Calculate slippage statistics\"\"\"\n        cutoff = datetime.utcnow() - timedelta(hours=period_hours)\n        recent_data = [\n            s for s in self.slippage_history[instrument] \n            if s['timestamp'] >= cutoff\n        ]\n        \n        if not recent_data:\n            return {}\n            \n        slippages = [s['slippage'] for s in recent_data]\n        \n        return {\n            'average_slippage': sum(slippages) / len(slippages),\n            'max_slippage': max(slippages),\n            'min_slippage': min(slippages),\n            'total_trades': len(recent_data)\n        }\n```

### Integration Points\n- **OANDA API**: Direct order execution endpoints\n- **TMT Signal Engine**: Correlation of signals to executed orders\n- **Risk Management**: Integration with position sizing rules\n- **Monitoring**: Execution metrics and slippage tracking\n- **Database**: Order storage for audit and analysis\n\n### Performance Targets\n- Order execution: < 100ms from signal to fill\n- Slippage tracking: Real-time calculation and alerting\n- Order correlation: Immediate linking of signals to executions\n- Error handling: < 5ms additional latency for error processing\n\n## Testing\n- Execution latency validation (< 100ms)\n- Stop loss and take profit placement accuracy\n- Client order ID generation uniqueness\n- Slippage calculation correctness\n- Partial fill handling scenarios\n- Order rejection error parsing\n\n## Dev Agent Record\n\n### Agent Model Used\n(To be filled by dev agent)\n\n### File List\n(To be filled by dev agent)\n\n### Debug Log References\n(To be filled by dev agent)\n\n### Completion Notes List\n(To be filled by dev agent)\n\n### Change Log\n(To be filled by dev agent)
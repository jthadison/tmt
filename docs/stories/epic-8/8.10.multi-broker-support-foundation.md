# Story 8.10: Multi-Account Broker Support Foundation

## Status
Ready

## Story
**As a** product owner,
**I want** extensible broker integration architecture,
**so that** we can easily add more brokers beyond OANDA.

## Acceptance Criteria
1. Abstract `BrokerAdapter` interface defined
2. Broker factory pattern for instantiating adapters
3. Configuration system supports multiple broker types
4. Unified error codes across different brokers
5. Common order/position models with broker-specific mapping
6. Broker capability discovery (supported order types, instruments)
7. A/B testing framework for broker routing
8. Performance metrics comparison across brokers

## Tasks / Subtasks
- [ ] Task 1: Design abstract broker interface (AC: 1, 5)
  - [ ] Create BrokerAdapter abstract base class
  - [ ] Define common order/position models
  - [ ] Implement broker-agnostic data structures
  - [ ] Create standardized method signatures
  - [ ] Add broker capability enumeration
  - [ ] Define broker-specific configuration interface

- [ ] Task 2: Implement broker factory pattern (AC: 2)
  - [ ] Create BrokerFactory class
  - [ ] Implement broker type registration
  - [ ] Add dynamic broker instantiation
  - [ ] Create broker configuration validation
  - [ ] Implement broker lifecycle management
  - [ ] Add broker health checking

- [ ] Task 3: Build multi-broker configuration system (AC: 3)
  - [ ] Create broker-specific configuration schemas
  - [ ] Implement configuration validation
  - [ ] Add environment-based configuration
  - [ ] Create configuration hot-reloading
  - [ ] Implement configuration versioning
  - [ ] Add configuration backup/restore

- [ ] Task 4: Create unified error handling (AC: 4)
  - [ ] Define standard error code taxonomy
  - [ ] Create error code mapping from broker-specific codes
  - [ ] Implement error message normalization
  - [ ] Add error context preservation
  - [ ] Create error classification system
  - [ ] Implement error reporting aggregation

- [ ] Task 5: Build broker capability discovery (AC: 6)
  - [ ] Create capability enumeration system
  - [ ] Implement supported order types discovery
  - [ ] Add tradeable instruments listing
  - [ ] Create feature matrix comparison
  - [ ] Implement capability-based routing
  - [ ] Add capability change detection

- [ ] Task 6: Create A/B testing framework (AC: 7, 8)
  - [ ] Implement broker routing algorithms
  - [ ] Create performance metrics collection
  - [ ] Add A/B test configuration
  - [ ] Implement statistical significance testing
  - [ ] Create broker performance comparison
  - [ ] Add automated broker selection

## Dev Notes

### Architecture Context
The Multi-Account Broker Support Foundation provides the architectural framework to support multiple retail brokers beyond OANDA, enabling the platform to serve traders across different broker ecosystems while maintaining consistent functionality and performance.

### Technical Implementation Details

#### Abstract Broker Interface
```python
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any
from decimal import Decimal
from enum import Enum

class BrokerCapability(Enum):
    MARKET_ORDERS = \"market_orders\"
    LIMIT_ORDERS = \"limit_orders\"
    STOP_ORDERS = \"stop_orders\"
    TRAILING_STOPS = \"trailing_stops\"
    GUARANTEED_STOPS = \"guaranteed_stops\"
    FRACTIONAL_UNITS = \"fractional_units\"
    HEDGING = \"hedging\"
    FIFO_ONLY = \"fifo_only\"

@dataclass
class UnifiedOrder:
    \"\"\"Broker-agnostic order representation\"\"\"
    order_id: str
    client_order_id: str
    instrument: str
    order_type: OrderType
    side: OrderSide
    units: Decimal
    price: Optional[Decimal] = None
    stop_loss: Optional[Decimal] = None
    take_profit: Optional[Decimal] = None
    time_in_force: TimeInForce = TimeInForce.GTC
    broker_specific: Dict[str, Any] = field(default_factory=dict)

class BrokerAdapter(ABC):
    \"\"\"Abstract base class for all broker integrations\"\"\"
    
    @property
    @abstractmethod
    def broker_name(self) -> str:
        \"\"\"Return the broker name\"\"\"
        pass
        
    @property
    @abstractmethod
    def capabilities(self) -> Set[BrokerCapability]:
        \"\"\"Return set of supported capabilities\"\"\"
        pass
        
    @abstractmethod
    async def authenticate(self, credentials: Dict[str, str]) -> bool:
        \"\"\"Authenticate with broker\"\"\"
        pass
        
    @abstractmethod
    async def place_order(self, order: UnifiedOrder) -> OrderResult:
        \"\"\"Place order with broker\"\"\"
        pass
        
    @abstractmethod
    async def get_positions(self) -> List[UnifiedPosition]:
        \"\"\"Get all open positions\"\"\"
        pass
        
    @abstractmethod
    async def get_account_summary(self) -> UnifiedAccountSummary:
        \"\"\"Get account information\"\"\"
        pass
        
    @abstractmethod
    async def stream_prices(self, instruments: List[str]) -> AsyncIterator[PriceTick]:
        \"\"\"Stream real-time prices\"\"\"
        pass
        
    @abstractmethod
    def map_error(self, broker_error: Exception) -> StandardBrokerError:
        \"\"\"Map broker-specific error to standard error\"\"\"
        pass
```

#### Broker Factory Implementation
```python
class BrokerFactory:
    \"\"\"Factory for creating broker adapter instances\"\"\"
    
    def __init__(self):
        self._adapters: Dict[str, Type[BrokerAdapter]] = {}
        self._instances: Dict[str, BrokerAdapter] = {}
        
    def register_adapter(self, broker_name: str, adapter_class: Type[BrokerAdapter]):
        \"\"\"Register a broker adapter class\"\"\"
        self._adapters[broker_name] = adapter_class
        
    async def create_adapter(self, broker_name: str, config: Dict[str, Any]) -> BrokerAdapter:
        \"\"\"Create and configure broker adapter instance\"\"\"
        if broker_name not in self._adapters:
            raise UnsupportedBrokerError(f\"Broker '{broker_name}' not registered\")
            
        adapter_class = self._adapters[broker_name]
        
        # Create instance
        adapter = adapter_class(config)
        
        # Authenticate
        credentials = config.get('credentials', {})
        if not await adapter.authenticate(credentials):
            raise BrokerAuthenticationError(f\"Failed to authenticate with {broker_name}\")
            
        # Cache instance
        instance_key = f\"{broker_name}_{config.get('account_id', 'default')}\"
        self._instances[instance_key] = adapter
        
        return adapter
        
    def get_registered_brokers(self) -> List[str]:
        \"\"\"Get list of registered broker names\"\"\"
        return list(self._adapters.keys())
        
    def get_broker_capabilities(self, broker_name: str) -> Set[BrokerCapability]:
        \"\"\"Get capabilities for a specific broker\"\"\"
        if broker_name not in self._adapters:
            return set()
            
        adapter_class = self._adapters[broker_name]
        # Create temporary instance to get capabilities
        temp_instance = adapter_class({})
        return temp_instance.capabilities

# Register brokers
broker_factory = BrokerFactory()
broker_factory.register_adapter(\"oanda\", OandaBrokerAdapter)
broker_factory.register_adapter(\"interactive_brokers\", IBBrokerAdapter)  # Future
broker_factory.register_adapter(\"alpaca\", AlpacaBrokerAdapter)  # Future
```

#### Unified Error Handling
```python
class StandardBrokerError(Exception):
    \"\"\"Standardized broker error with unified error codes\"\"\"
    
    def __init__(self, error_code: str, message: str, broker_specific_code: str = None):
        self.error_code = error_code
        self.message = message
        self.broker_specific_code = broker_specific_code
        super().__init__(f\"{error_code}: {message}\")

class ErrorCodeMapper:
    \"\"\"Maps broker-specific errors to standard codes\"\"\"
    
    def __init__(self):
        self.mappings = {
            'oanda': {
                'INSUFFICIENT_MARGIN': 'INSUFFICIENT_FUNDS',
                'INVALID_INSTRUMENT': 'INVALID_SYMBOL',
                'MARKET_CLOSED': 'MARKET_CLOSED',
                'INVALID_UNITS': 'INVALID_QUANTITY'
            }
            # Add mappings for other brokers
        }
        
    def map_error(self, broker_name: str, broker_error_code: str, message: str) -> StandardBrokerError:
        \"\"\"Map broker error to standard error\"\"\"
        standard_code = self.mappings.get(broker_name, {}).get(
            broker_error_code, 
            'UNKNOWN_ERROR'
        )
        
        return StandardBrokerError(
            error_code=standard_code,
            message=message,
            broker_specific_code=broker_error_code
        )
```

#### A/B Testing Framework
```python
class BrokerABTestingFramework:
    \"\"\"Framework for A/B testing different brokers\"\"\"
    
    def __init__(self):
        self.test_configurations = {}
        self.performance_metrics = defaultdict(list)
        
    def create_ab_test(self, test_name: str, brokers: List[str], traffic_split: Dict[str, float]):
        \"\"\"Create A/B test configuration\"\"\"
        if sum(traffic_split.values()) != 1.0:
            raise ValueError(\"Traffic split must sum to 1.0\")
            
        self.test_configurations[test_name] = {
            'brokers': brokers,
            'traffic_split': traffic_split,
            'start_time': datetime.utcnow(),
            'active': True
        }
        
    async def route_order(self, test_name: str, order: UnifiedOrder) -> str:
        \"\"\"Route order to broker based on A/B test configuration\"\"\"
        config = self.test_configurations.get(test_name)
        if not config or not config['active']:
            return config['brokers'][0]  # Default to first broker
            
        # Use deterministic routing based on client_order_id
        hash_val = hash(order.client_order_id) % 100
        cumulative_probability = 0
        
        for broker, probability in config['traffic_split'].items():
            cumulative_probability += probability * 100
            if hash_val < cumulative_probability:
                return broker
                
        return config['brokers'][-1]  # Fallback
        
    async def record_performance(self, broker_name: str, metric: str, value: float):
        \"\"\"Record performance metric for broker\"\"\"
        self.performance_metrics[broker_name].append({
            'metric': metric,
            'value': value,
            'timestamp': datetime.utcnow()
        })
```

## Testing
- Abstract interface implementation compliance
- Broker factory instantiation
- Configuration validation
- Error code mapping accuracy
- Capability discovery completeness
- A/B testing traffic distribution

## Dev Agent Record

### Agent Model Used
(To be filled by dev agent)

### File List
(To be filled by dev agent)

### Debug Log References
(To be filled by dev agent)

### Completion Notes List
(To be filled by dev agent)

### Change Log
(To be filled by dev agent)
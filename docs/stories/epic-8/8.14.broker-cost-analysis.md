# Story 8.14: Broker Cost Analysis & Optimization

## Status
Ready

## Story
**As a** trader,
**I want** to see the true cost of trading with each broker,
**so that** I can optimize my broker selection for profitability.

## Acceptance Criteria
1. Track spreads, commissions, and swap rates per broker
2. Calculate all-in cost per trade including all fees
3. Compare execution quality across brokers
4. Slippage analysis and reporting
5. Optimal broker routing recommendations
6. Historical cost trends and analysis
7. Break-even calculator including broker costs
8. Export cost reports for accounting

## Tasks / Subtasks
- [ ] Task 1: Build cost tracking system (AC: 1, 2)
  - [ ] Create cost data collection framework
  - [ ] Track spreads by instrument and time
  - [ ] Monitor commission structures
  - [ ] Record swap/rollover rates
  - [ ] Calculate total cost per trade
  - [ ] Add cost categorization

- [ ] Task 2: Implement execution quality analysis (AC: 3, 4)
  - [ ] Create slippage measurement system
  - [ ] Track fill quality metrics
  - [ ] Monitor execution speed
  - [ ] Add rejection rate tracking
  - [ ] Create quality scoring algorithm
  - [ ] Build execution reports

- [ ] Task 3: Build broker comparison engine (AC: 5)
  - [ ] Create cost comparison algorithms
  - [ ] Add broker ranking system
  - [ ] Implement routing recommendations
  - [ ] Create A/B testing for brokers
  - [ ] Add optimal allocation suggestions
  - [ ] Build decision support system

- [ ] Task 4: Create historical analysis (AC: 6)
  - [ ] Build cost trend analysis
  - [ ] Add seasonal cost patterns
  - [ ] Create cost forecasting
  - [ ] Track cost evolution over time
  - [ ] Add benchmark comparisons
  - [ ] Create cost alerts

- [ ] Task 5: Build break-even calculator (AC: 7)
  - [ ] Create profitability calculator
  - [ ] Add break-even analysis
  - [ ] Calculate minimum trade size
  - [ ] Add risk-reward calculations
  - [ ] Create optimization suggestions
  - [ ] Build scenario planning

- [ ] Task 6: Create reporting and export (AC: 8)
  - [ ] Build cost analysis reports
  - [ ] Add CSV/Excel export
  - [ ] Create PDF reports
  - [ ] Add automated reporting
  - [ ] Create custom report builder
  - [ ] Add report scheduling

## Dev Notes

### Technical Implementation Details

#### Cost Tracking System
```python
from dataclasses import dataclass
from typing import Dict, List, Optional
from decimal import Decimal
from datetime import datetime

@dataclass
class TradeCost:
    broker: str
    instrument: str
    trade_id: str
    timestamp: datetime
    spread_cost: Decimal
    commission: Decimal
    swap_cost: Decimal
    slippage_cost: Decimal
    total_cost: Decimal
    trade_size: Decimal
    cost_per_unit: Decimal

class BrokerCostAnalyzer:
    def __init__(self, database: DatabaseClient):
        self.database = database
        self.cost_cache = {}
        
    async def calculate_trade_cost(self, broker: str, trade_data: Dict) -> TradeCost:
        """Calculate comprehensive cost for a trade"""
        # Get spread at execution time
        spread_cost = await self._calculate_spread_cost(trade_data)
        
        # Get commission from broker
        commission = await self._get_commission_cost(broker, trade_data)
        
        # Calculate swap cost if position held overnight
        swap_cost = await self._calculate_swap_cost(broker, trade_data)
        
        # Calculate slippage cost
        slippage_cost = await self._calculate_slippage_cost(trade_data)
        
        # Total cost
        total_cost = spread_cost + commission + swap_cost + slippage_cost
        
        trade_cost = TradeCost(
            broker=broker,
            instrument=trade_data['instrument'],
            trade_id=trade_data['trade_id'],
            timestamp=trade_data['timestamp'],
            spread_cost=spread_cost,
            commission=commission,
            swap_cost=swap_cost,
            slippage_cost=slippage_cost,
            total_cost=total_cost,
            trade_size=abs(Decimal(trade_data['units'])),
            cost_per_unit=total_cost / abs(Decimal(trade_data['units']))
        )
        
        # Store for analysis
        await self._store_cost_data(trade_cost)
        
        return trade_cost
        
    async def _calculate_spread_cost(self, trade_data: Dict) -> Decimal:
        """Calculate cost from bid-ask spread"""
        spread = Decimal(trade_data['ask']) - Decimal(trade_data['bid'])
        units = abs(Decimal(trade_data['units']))
        
        # Cost is half spread * units (assuming mid-price execution)
        return (spread / 2) * units
        
    async def _calculate_slippage_cost(self, trade_data: Dict) -> Decimal:
        """Calculate cost from slippage"""
        expected_price = Decimal(trade_data['expected_price'])
        actual_price = Decimal(trade_data['fill_price'])
        units = abs(Decimal(trade_data['units']))
        
        slippage = abs(actual_price - expected_price)
        return slippage * units
        
    async def generate_broker_cost_comparison(self, 
                                            period_days: int = 30) -> Dict[str, Dict]:
        """Generate cost comparison across brokers"""
        end_date = datetime.utcnow()
        start_date = end_date - timedelta(days=period_days)
        
        cost_data = await self.database.get_cost_data(
            start_date=start_date,
            end_date=end_date
        )
        
        broker_stats = defaultdict(lambda: {
            'total_cost': Decimal('0'),
            'total_volume': Decimal('0'),
            'avg_spread': Decimal('0'),
            'avg_commission': Decimal('0'),
            'avg_slippage': Decimal('0'),
            'trade_count': 0
        })
        
        for cost in cost_data:
            stats = broker_stats[cost.broker]
            stats['total_cost'] += cost.total_cost
            stats['total_volume'] += cost.trade_size
            stats['trade_count'] += 1
            
        # Calculate averages
        for broker, stats in broker_stats.items():
            if stats['trade_count'] > 0:
                stats['avg_cost_per_trade'] = stats['total_cost'] / stats['trade_count']
                stats['cost_per_million'] = (stats['total_cost'] / stats['total_volume']) * 1000000
                
        return dict(broker_stats)
```

#### Execution Quality Analyzer
```python
class ExecutionQualityAnalyzer:
    def __init__(self):
        self.quality_metrics = {}
        
    async def analyze_execution_quality(self, broker: str, 
                                       period_days: int = 30) -> ExecutionQuality:
        """Analyze execution quality metrics"""
        end_date = datetime.utcnow()
        start_date = end_date - timedelta(days=period_days)
        
        executions = await self.get_executions(broker, start_date, end_date)
        
        # Calculate metrics
        total_executions = len(executions)
        successful_executions = len([e for e in executions if e.success])
        
        avg_latency = sum(e.latency_ms for e in executions) / len(executions)
        avg_slippage = sum(abs(e.slippage) for e in executions) / len(executions)
        
        # Fill quality score (0-100)
        fill_rate = successful_executions / total_executions
        latency_score = max(0, 100 - (avg_latency - 50))  # Penalty after 50ms
        slippage_score = max(0, 100 - (avg_slippage * 10000))  # Penalty per pip
        
        overall_score = (fill_rate * 40) + (latency_score * 0.3) + (slippage_score * 0.3)
        
        return ExecutionQuality(
            broker=broker,
            period_start=start_date,
            period_end=end_date,
            total_executions=total_executions,
            success_rate=fill_rate,
            avg_latency_ms=avg_latency,
            avg_slippage_pips=avg_slippage,
            quality_score=overall_score
        )
```

#### Broker Routing Optimizer
```python
class BrokerRoutingOptimizer:
    def __init__(self, cost_analyzer: BrokerCostAnalyzer, 
                 quality_analyzer: ExecutionQualityAnalyzer):
        self.cost_analyzer = cost_analyzer
        self.quality_analyzer = quality_analyzer
        
    async def recommend_optimal_broker(self, 
                                      instrument: str,
                                      trade_size: Decimal,
                                      trade_type: str) -> BrokerRecommendation:
        """Recommend optimal broker for a trade"""
        available_brokers = await self.get_available_brokers(instrument)
        
        recommendations = []
        
        for broker in available_brokers:
            # Get cost analysis
            cost_data = await self.cost_analyzer.get_broker_costs(
                broker, instrument, period_days=7
            )
            
            # Get execution quality
            quality_data = await self.quality_analyzer.analyze_execution_quality(
                broker, period_days=7
            )
            
            # Estimate trade cost
            estimated_cost = self._estimate_trade_cost(
                cost_data, trade_size, trade_type
            )
            
            # Calculate composite score
            cost_score = self._normalize_cost_score(estimated_cost)
            quality_score = quality_data.quality_score
            
            # Weighted composite (60% cost, 40% quality)
            composite_score = (cost_score * 0.6) + (quality_score * 0.4)
            
            recommendations.append(BrokerScore(
                broker=broker,
                estimated_cost=estimated_cost,
                quality_score=quality_score,
                composite_score=composite_score
            ))
            
        # Sort by composite score (highest is best)
        recommendations.sort(key=lambda x: x.composite_score, reverse=True)
        
        return BrokerRecommendation(
            instrument=instrument,
            trade_size=trade_size,
            recommended_broker=recommendations[0].broker,
            all_options=recommendations,
            confidence=self._calculate_confidence(recommendations)
        )
```

### Integration Points
- **Broker Adapters**: Cost and execution data collection
- **Database**: Historical cost and quality data storage
- **Dashboard**: Cost analysis visualization
- **Reporting**: Automated cost reports and exports
- **Trading Engine**: Broker routing optimization

## Testing
- Cost calculation accuracy
- Execution quality metrics
- Broker comparison algorithms
- Report generation functionality
- Export format validation
- Optimization recommendations

## Dev Agent Record

### Agent Model Used
(To be filled by dev agent)

### File List
(To be filled by dev agent)

### Debug Log References
(To be filled by dev agent)

### Completion Notes List
(To be filled by dev agent)

### Change Log
(To be filled by dev agent)
# Story 8.7: Limit & Stop Order Management

## Status
Ready

## Story
**As a** trader,
**I want** to place limit and stop orders,
**so that** I can enter positions at specific price levels.

## Acceptance Criteria
1. Place limit orders (buy below/sell above market)
2. Place stop orders (buy above/sell below market)
3. Good Till Cancelled (GTC) and Good Till Date (GTD) support
4. View all pending orders with distance from current price
5. Modify pending order price, stop loss, take profit
6. Cancel individual or all pending orders
7. Order expiry handling and notifications
8. Market-if-touched order type support

## Tasks / Subtasks
- [ ] Task 1: Implement limit order placement (AC: 1)
  - [ ] Create place_limit_order method
  - [ ] Add buy limit below market validation
  - [ ] Implement sell limit above market validation
  - [ ] Add order price validation logic
  - [ ] Create limit order confirmation system
  - [ ] Add limit order tracking

- [ ] Task 2: Build stop order functionality (AC: 2)
  - [ ] Create place_stop_order method
  - [ ] Add buy stop above market validation
  - [ ] Implement sell stop below market validation
  - [ ] Add stop order price validation
  - [ ] Create stop order confirmation
  - [ ] Implement stop order tracking

- [ ] Task 3: Implement order time management (AC: 3, 7)
  - [ ] Add GTC (Good Till Cancelled) support
  - [ ] Implement GTD (Good Till Date) functionality
  - [ ] Create order expiry monitoring
  - [ ] Add expiry notification system
  - [ ] Implement automatic order cleanup
  - [ ] Create expiry alert system

- [ ] Task 4: Build pending order viewer (AC: 4)
  - [ ] Create get_pending_orders method
  - [ ] Calculate distance from current price
  - [ ] Add order status tracking
  - [ ] Implement order sorting and filtering
  - [ ] Create order performance metrics
  - [ ] Add order visualization

- [ ] Task 5: Create order modification system (AC: 5)
  - [ ] Implement modify_pending_order method
  - [ ] Add price level modification
  - [ ] Create SL/TP modification for pending orders
  - [ ] Add modification validation
  - [ ] Implement modification history
  - [ ] Create modification confirmation

- [ ] Task 6: Build order cancellation system (AC: 6, 8)
  - [ ] Create cancel_pending_order method
  - [ ] Implement cancel_all_orders functionality
  - [ ] Add selective cancellation by instrument
  - [ ] Create MIT (Market-if-Touched) order support
  - [ ] Add bulk cancellation confirmation
  - [ ] Implement cancellation audit trail

## Dev Notes

### Architecture Context
Limit & Stop Order Management enables precise entry and exit strategies by placing orders at specific price levels. This system integrates with price streaming to monitor market conditions and automatically execute orders when price targets are reached.

### Technical Implementation Details

#### Pending Order Manager
```python
class OandaPendingOrderManager:
    def __init__(self, client: OandaClient, price_stream: OandaStreamManager):
        self.client = client
        self.price_stream = price_stream
        self.pending_orders = {}
        
    async def place_limit_order(self, instrument: str, units: Decimal, price: Decimal,
                               time_in_force: str = 'GTC', 
                               stop_loss: Optional[Decimal] = None,
                               take_profit: Optional[Decimal] = None) -> OrderResult:
        """Place a limit order"""
        # Validate limit order price
        current_price = await self._get_current_price(instrument)
        if not self._validate_limit_order_price(units, price, current_price):
            raise ValueError(f"Invalid limit order price {price}")
            
        order_request = {
            "order": {
                "type": "LIMIT",
                "instrument": instrument,
                "units": str(units),
                "price": str(price),
                "timeInForce": time_in_force
            }
        }
        
        # Add stop loss and take profit if specified
        if stop_loss:
            order_request["order"]["stopLossOnFill"] = {"price": str(stop_loss)}
        if take_profit:
            order_request["order"]["takeProfitOnFill"] = {"price": str(take_profit)}
            
        response = await self.client.post(
            f"/v3/accounts/{self.client.account_id}/orders",
            json=order_request
        )
        
        return self._process_order_response(response)
        
    def _validate_limit_order_price(self, units: Decimal, limit_price: Decimal, 
                                   current_price: Decimal) -> bool:
        """Validate limit order price is correct relative to market"""
        if units > 0:  # Buy limit
            return limit_price < current_price  # Must be below market
        else:  # Sell limit
            return limit_price > current_price  # Must be above market
```

#### Order Expiry Management
```python
class OrderExpiryManager:
    def __init__(self, order_manager: OandaPendingOrderManager):
        self.order_manager = order_manager
        self.expiring_orders = {}
        
    async def monitor_order_expiry(self):
        """Monitor orders for expiry"""
        while True:
            try:
                await asyncio.sleep(60)  # Check every minute
                current_time = datetime.utcnow()
                
                for order_id, expiry_time in list(self.expiring_orders.items()):
                    if current_time >= expiry_time:
                        await self._handle_order_expiry(order_id)
                        
            except Exception as e:
                logger.error(f"Error monitoring order expiry: {e}")
                
    async def _handle_order_expiry(self, order_id: str):
        """Handle expired order"""
        try:
            # Cancel expired order
            await self.order_manager.cancel_pending_order(order_id)
            
            # Send expiry notification
            await self._send_expiry_notification(order_id)
            
            # Remove from expiry tracking
            del self.expiring_orders[order_id]
            
            logger.info(f"Handled expiry for order {order_id}")
            
        except Exception as e:
            logger.error(f"Failed to handle order expiry {order_id}: {e}")
```

### Integration Points
- **OANDA Orders API**: Pending order placement and management
- **Price Streaming**: Price monitoring for order execution
- **Position Management**: Coordination with position tracking
- **Dashboard**: Order visualization and management interface

## Testing
- Limit/stop order placement validation
- Order price validation accuracy
- Time-in-force functionality
- Order modification capabilities
- Expiry handling automation
- Bulk cancellation operations

## Dev Agent Record

### Agent Model Used
(To be filled by dev agent)

### File List
(To be filled by dev agent)

### Debug Log References
(To be filled by dev agent)

### Completion Notes List
(To be filled by dev agent)

### Change Log
(To be filled by dev agent)
# Story 8.13: Production Deployment & Monitoring

## Status
Ready

## Story
**As a** DevOps engineer,
**I want** production-ready deployment with monitoring,
**so that** we can operate the broker integration reliably.

## Acceptance Criteria
1. Docker containers for broker integration services
2. Kubernetes deployment manifests with auto-scaling
3. Prometheus metrics for API latency, errors, throughput
4. Grafana dashboards for broker health monitoring
5. PagerDuty alerts for critical failures
6. Log aggregation in ELK stack
7. Secrets management via HashiCorp Vault
8. Blue-green deployment support for zero downtime

## Tasks / Subtasks
- [ ] Task 1: Create Docker containerization (AC: 1)
  - [ ] Build Dockerfile for broker services
  - [ ] Create multi-stage builds for optimization
  - [ ] Add health check endpoints
  - [ ] Configure container security
  - [ ] Create Docker Compose for local dev
  - [ ] Add container image scanning

- [ ] Task 2: Build Kubernetes manifests (AC: 2, 8)
  - [ ] Create deployment manifests
  - [ ] Add horizontal pod autoscaler
  - [ ] Configure service discovery
  - [ ] Create ingress controllers
  - [ ] Add blue-green deployment configs
  - [ ] Configure rolling updates

- [ ] Task 3: Implement monitoring stack (AC: 3, 4)
  - [ ] Add Prometheus metrics collection
  - [ ] Create custom broker metrics
  - [ ] Build Grafana dashboards
  - [ ] Add performance monitoring
  - [ ] Create SLA tracking
  - [ ] Add capacity planning metrics

- [ ] Task 4: Configure alerting system (AC: 5)
  - [ ] Set up PagerDuty integration
  - [ ] Create alerting rules
  - [ ] Add escalation policies
  - [ ] Configure Slack notifications
  - [ ] Create alert runbooks
  - [ ] Add alert fatigue prevention

- [ ] Task 5: Set up logging infrastructure (AC: 6)
  - [ ] Configure ELK stack
  - [ ] Add structured logging
  - [ ] Create log parsing rules
  - [ ] Add log retention policies
  - [ ] Create log analysis dashboards
  - [ ] Add log-based alerting

- [ ] Task 6: Implement secrets management (AC: 7)
  - [ ] Configure Vault integration
  - [ ] Add secret rotation
  - [ ] Create access policies
  - [ ] Add audit logging
  - [ ] Configure secret injection
  - [ ] Add emergency access procedures

## Dev Notes

### Technical Implementation Details

#### Docker Configuration
```dockerfile
# Multi-stage build for broker service
FROM python:3.11-slim as builder
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

FROM python:3.11-slim as runtime
WORKDIR /app
COPY --from=builder /usr/local/lib/python3.11/site-packages /usr/local/lib/python3.11/site-packages
COPY src/ ./src/
COPY config/ ./config/

# Add health check
HEALTHCHECK --interval=30s --timeout=10s --retries=3 \
    CMD curl -f http://localhost:8000/health || exit 1

# Run as non-root user
RUN adduser --disabled-password --gecos '' appuser
USER appuser

EXPOSE 8000
CMD ["python", "-m", "src.broker_service"]
```

#### Kubernetes Deployment
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: oanda-broker-service
  labels:
    app: oanda-broker
    version: v1
spec:
  replicas: 3
  selector:
    matchLabels:
      app: oanda-broker
  template:
    metadata:
      labels:
        app: oanda-broker
        version: v1
    spec:
      containers:
      - name: broker-service
        image: tmt/oanda-broker:latest
        ports:
        - containerPort: 8000
        env:
        - name: VAULT_ADDR
          value: "https://vault.tmt.internal"
        - name: PROMETHEUS_PORT
          value: "9090"
        resources:
          requests:
            memory: "256Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 8000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 8000
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: oanda-broker-service
spec:
  selector:
    app: oanda-broker
  ports:
  - port: 80
    targetPort: 8000
  type: ClusterIP
```

#### Monitoring Configuration
```yaml
# Prometheus ServiceMonitor
apiVersion: monitoring.coreos.com/v1
kind: ServiceMonitor
metadata:
  name: broker-metrics
spec:
  selector:
    matchLabels:
      app: oanda-broker
  endpoints:
  - port: metrics
    interval: 30s
    path: /metrics
---
# Grafana Dashboard ConfigMap
apiVersion: v1
kind: ConfigMap
metadata:
  name: broker-dashboard
data:
  dashboard.json: |
    {
      "dashboard": {
        "title": "Broker Integration Metrics",
        "panels": [
          {
            "title": "Order Execution Latency",
            "type": "graph",
            "targets": [
              {
                "expr": "histogram_quantile(0.95, broker_order_duration_seconds)",
                "legendFormat": "95th percentile"
              }
            ]
          },
          {
            "title": "API Error Rate",
            "type": "singlestat",
            "targets": [
              {
                "expr": "rate(broker_api_errors_total[5m])",
                "legendFormat": "Errors/sec"
              }
            ]
          }
        ]
      }
    }
```

#### Application Metrics
```python
from prometheus_client import Counter, Histogram, Gauge
import time

# Define metrics
ORDER_COUNTER = Counter('broker_orders_total', 'Total orders placed', ['broker', 'status'])
ORDER_LATENCY = Histogram('broker_order_duration_seconds', 'Order execution latency')
API_ERRORS = Counter('broker_api_errors_total', 'API errors', ['broker', 'error_type'])
CONNECTION_STATUS = Gauge('broker_connection_status', 'Connection status', ['broker'])

class MetricsCollector:
    def __init__(self):
        self.start_time = time.time()
        
    def record_order_placed(self, broker: str, success: bool):
        status = 'success' if success else 'failure'
        ORDER_COUNTER.labels(broker=broker, status=status).inc()
        
    def record_order_latency(self, latency_seconds: float):
        ORDER_LATENCY.observe(latency_seconds)
        
    def record_api_error(self, broker: str, error_type: str):
        API_ERRORS.labels(broker=broker, error_type=error_type).inc()
        
    def update_connection_status(self, broker: str, connected: bool):
        CONNECTION_STATUS.labels(broker=broker).set(1 if connected else 0)
        
# Usage in broker adapter
class OandaBrokerAdapter:
    def __init__(self, config):
        self.metrics = MetricsCollector()
        
    async def place_order(self, order: UnifiedOrder) -> OrderResult:
        start_time = time.time()
        
        try:
            result = await self._execute_order(order)
            self.metrics.record_order_placed('oanda', result.success)
            return result
        except Exception as e:
            self.metrics.record_api_error('oanda', type(e).__name__)
            raise
        finally:
            latency = time.time() - start_time
            self.metrics.record_order_latency(latency)
```

### Integration Points
- **Kubernetes Cluster**: Container orchestration
- **Prometheus**: Metrics collection and storage
- **Grafana**: Visualization and dashboards
- **ELK Stack**: Log aggregation and analysis
- **HashiCorp Vault**: Secrets management
- **PagerDuty**: Incident management

## Testing
- Container image security scanning
- Kubernetes deployment validation
- Monitoring metrics accuracy
- Alert firing validation
- Log aggregation functionality
- Secrets rotation testing

## Dev Agent Record

### Agent Model Used
(To be filled by dev agent)

### File List
(To be filled by dev agent)

### Debug Log References
(To be filled by dev agent)

### Completion Notes List
(To be filled by dev agent)

### Change Log
(To be filled by dev agent)
# Story 8.6: Position Management & Modification

## Status
Ready

## Story
**As a** trader,
**I want** to manage my open OANDA positions,
**so that** I can adjust stops, targets, and close positions.

## Acceptance Criteria
1. List all open positions with current P&L
2. Modify stop loss and take profit for open positions
3. Partial position closing (e.g., close 50% of position)
4. Close all positions with single command
5. Position details show entry price, current price, swap charges
6. Calculate position P&L in account currency
7. Position age tracking (time since opened)
8. Trailing stop loss modification support

## Tasks / Subtasks
- [ ] Task 1: Build position data fetcher (AC: 1, 5, 6, 7)
  - [ ] Create OandaPositionManager class
  - [ ] Implement get_open_positions method
  - [ ] Add real-time P&L calculation
  - [ ] Fetch position entry details
  - [ ] Calculate swap/rollover charges
  - [ ] Add position age calculation

- [ ] Task 2: Implement stop loss and take profit modification (AC: 2)
  - [ ] Create modify_position_sl method
  - [ ] Add modify_position_tp functionality
  - [ ] Implement price level validation
  - [ ] Add modification confirmation
  - [ ] Create batch modification for multiple positions
  - [ ] Add modification history tracking

- [ ] Task 3: Build partial position closing (AC: 3)
  - [ ] Implement partial_close_position method
  - [ ] Add unit/percentage-based closing
  - [ ] Create remaining position tracking
  - [ ] Add partial close validation
  - [ ] Implement FIFO compliance for partial closes
  - [ ] Create partial close confirmation

- [ ] Task 4: Create bulk position management (AC: 4)
  - [ ] Implement close_all_positions method
  - [ ] Add selective bulk closing by instrument
  - [ ] Create position filtering for bulk operations
  - [ ] Add bulk operation confirmation
  - [ ] Implement emergency close functionality
  - [ ] Create bulk operation status tracking

- [ ] Task 5: Build trailing stop loss system (AC: 8)
  - [ ] Create trailing stop configuration
  - [ ] Implement trailing stop monitoring
  - [ ] Add distance-based trailing stops
  - [ ] Create percentage-based trailing stops
  - [ ] Implement trailing stop activation levels
  - [ ] Add trailing stop visualization

- [ ] Task 6: Create position monitoring and alerts
  - [ ] Implement position P&L alerts
  - [ ] Add position age warnings
  - [ ] Create margin level monitoring
  - [ ] Add position risk scoring
  - [ ] Implement position performance tracking
  - [ ] Create position optimization suggestions

## Dev Notes

### Architecture Context
Position Management & Modification provides comprehensive control over open trading positions, enabling traders to actively manage risk and optimize performance. This system integrates with the risk management framework while providing intuitive position control capabilities.

### Previous Story Context
Builds on Stories 8.3 (Market Order Execution) and 8.4 (US Regulatory Compliance) to provide ongoing position management after trades are executed. Works with 8.5 (Price Streaming) to provide real-time position valuation.

### Technical Implementation Details

#### Position Manager Implementation
```python
from typing import List, Optional, Dict, Union
from decimal import Decimal
from datetime import datetime, timezone
from dataclasses import dataclass

@dataclass
class PositionInfo:
    position_id: str
    instrument: str
    side: str  # 'long' or 'short'
    units: Decimal
    entry_price: Decimal
    current_price: Decimal
    unrealized_pl: Decimal
    swap_charges: Decimal
    commission: Decimal
    margin_used: Decimal
    opened_at: datetime
    age_hours: float

class OandaPositionManager:
    def __init__(self, client: OandaClient, price_stream: OandaStreamManager):
        self.client = client
        self.price_stream = price_stream
        self.position_cache = {}
        self.trailing_stops = {}
        
    async def get_open_positions(self) -> List[PositionInfo]:
        """Fetch all open positions with current P&L"""
        try:
            response = await self.client.get(f"/v3/accounts/{self.client.account_id}/openPositions")
            positions = []
            
            for pos_data in response.get('positions', []):
                position = await self._parse_position_data(pos_data)
                positions.append(position)
                
            # Cache positions for quick access
            self.position_cache = {pos.position_id: pos for pos in positions}
            
            return positions
            
        except Exception as e:
            logger.error(f"Failed to fetch open positions: {e}")
            raise
            
    async def _parse_position_data(self, pos_data: Dict) -> PositionInfo:
        """Parse OANDA position data into PositionInfo"""
        instrument = pos_data['instrument']
        
        # Determine if long or short position
        long_units = Decimal(pos_data['long']['units'])
        short_units = Decimal(pos_data['short']['units'])
        
        if long_units > 0:
            side = 'long'
            units = long_units
            entry_price = Decimal(pos_data['long']['averagePrice'])
            unrealized_pl = Decimal(pos_data['long']['unrealizedPL'])
        else:
            side = 'short'
            units = abs(short_units)
            entry_price = Decimal(pos_data['short']['averagePrice'])
            unrealized_pl = Decimal(pos_data['short']['unrealizedPL'])
            
        # Get current market price
        current_price = await self._get_current_price(instrument, side)
        
        # Calculate position age
        opened_at = datetime.fromisoformat(pos_data['long']['openTime'] if long_units > 0 else pos_data['short']['openTime'])
        age_hours = (datetime.utcnow().replace(tzinfo=timezone.utc) - opened_at).total_seconds() / 3600
        
        return PositionInfo(
            position_id=f"{instrument}_{side}",
            instrument=instrument,
            side=side,
            units=units,
            entry_price=entry_price,
            current_price=current_price,
            unrealized_pl=unrealized_pl,
            swap_charges=Decimal(pos_data.get('financing', '0')),
            commission=Decimal(pos_data.get('commission', '0')),
            margin_used=Decimal(pos_data.get('marginUsed', '0')),
            opened_at=opened_at,
            age_hours=age_hours
        )
        
    async def modify_stop_loss(self, position_id: str, stop_loss_price: Decimal) -> bool:
        """Modify stop loss for an open position"""
        try:
            position = self.position_cache.get(position_id)
            if not position:
                raise ValueError(f"Position {position_id} not found")
                
            # Validate stop loss price
            if not self._validate_stop_loss_price(position, stop_loss_price):
                raise ValueError(f"Invalid stop loss price {stop_loss_price}")
                
            # Build modification request
            modification_request = {
                "stopLossOnFill": {
                    "price": str(stop_loss_price),
                    "timeInForce": "GTC"
                }
            }
            
            # Send modification to OANDA
            response = await self.client.patch(
                f"/v3/accounts/{self.client.account_id}/positions/{position.instrument}/close",
                json=modification_request
            )
            
            # Update cache
            position.stop_loss = stop_loss_price
            
            logger.info(f"Successfully modified stop loss for {position_id} to {stop_loss_price}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to modify stop loss for {position_id}: {e}")
            return False
            
    async def modify_take_profit(self, position_id: str, take_profit_price: Decimal) -> bool:
        """Modify take profit for an open position"""
        try:
            position = self.position_cache.get(position_id)
            if not position:
                raise ValueError(f"Position {position_id} not found")
                
            # Validate take profit price
            if not self._validate_take_profit_price(position, take_profit_price):
                raise ValueError(f"Invalid take profit price {take_profit_price}")
                
            # Build modification request
            modification_request = {
                "takeProfitOnFill": {
                    "price": str(take_profit_price),
                    "timeInForce": "GTC"
                }
            }
            
            # Send modification to OANDA
            response = await self.client.patch(
                f"/v3/accounts/{self.client.account_id}/positions/{position.instrument}/close",
                json=modification_request
            )
            
            logger.info(f"Successfully modified take profit for {position_id} to {take_profit_price}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to modify take profit for {position_id}: {e}")
            return False
```

#### Partial Position Closing
```python
class PartialCloseManager:
    def __init__(self, position_manager: OandaPositionManager, compliance_engine):
        self.position_manager = position_manager
        self.compliance_engine = compliance_engine
        
    async def partial_close_position(self, position_id: str, close_units: Union[Decimal, str]) -> bool:
        """Close partial amount of a position"""
        try:
            position = self.position_manager.position_cache.get(position_id)
            if not position:
                raise ValueError(f"Position {position_id} not found")
                
            # Handle percentage-based closing
            if isinstance(close_units, str) and close_units.endswith('%'):
                percentage = Decimal(close_units[:-1]) / 100
                units_to_close = position.units * percentage
            else:
                units_to_close = Decimal(close_units)
                
            # Validate close amount
            if units_to_close <= 0 or units_to_close > position.units:
                raise ValueError(f"Invalid close amount: {units_to_close}")
                
            # Check FIFO compliance for US accounts
            if await self._requires_fifo_compliance(position):
                fifo_result = await self.compliance_engine.validate_fifo_close(
                    position.instrument, units_to_close
                )
                if not fifo_result.valid:
                    raise ValueError(f"FIFO violation: {fifo_result.reason}")
                    
            # Execute partial close
            close_request = {
                "longUnits": str(-units_to_close) if position.side == 'long' else "0",
                "shortUnits": str(-units_to_close) if position.side == 'short' else "0"
            }
            
            response = await self.position_manager.client.put(
                f"/v3/accounts/{self.position_manager.client.account_id}/positions/{position.instrument}/close",
                json=close_request
            )
            
            # Update position cache
            position.units -= units_to_close
            
            logger.info(f"Successfully closed {units_to_close} units of {position_id}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to partially close position {position_id}: {e}")
            return False
            
    async def close_all_positions(self, filter_by_instrument: Optional[str] = None) -> Dict[str, bool]:
        """Close all open positions"""
        positions = await self.position_manager.get_open_positions()
        results = {}
        
        for position in positions:
            if filter_by_instrument and position.instrument != filter_by_instrument:
                continue
                
            try:
                success = await self.partial_close_position(position.position_id, position.units)
                results[position.position_id] = success
            except Exception as e:
                logger.error(f"Failed to close position {position.position_id}: {e}")
                results[position.position_id] = False
                
        return results
```

#### Trailing Stop Loss System
```python
class TrailingStopManager:
    def __init__(self, position_manager: OandaPositionManager):
        self.position_manager = position_manager
        self.trailing_stops: Dict[str, TrailingStopConfig] = {}
        self.is_monitoring = False
        
    @dataclass
    class TrailingStopConfig:
        position_id: str
        trail_distance: Decimal  # In pips
        activation_level: Optional[Decimal]  # Price level to start trailing
        current_stop: Decimal
        highest_price: Decimal  # For long positions
        lowest_price: Decimal   # For short positions
        
    async def set_trailing_stop(self, position_id: str, trail_distance: Decimal, 
                               activation_level: Optional[Decimal] = None) -> bool:
        """Set trailing stop for a position"""
        try:
            position = self.position_manager.position_cache.get(position_id)
            if not position:
                raise ValueError(f"Position {position_id} not found")
                
            # Calculate initial stop level
            if position.side == 'long':
                initial_stop = position.current_price - trail_distance
                highest_price = position.current_price
                lowest_price = Decimal('0')
            else:
                initial_stop = position.current_price + trail_distance
                highest_price = Decimal('0')
                lowest_price = position.current_price
                
            # Create trailing stop configuration
            trailing_config = self.TrailingStopConfig(
                position_id=position_id,
                trail_distance=trail_distance,
                activation_level=activation_level,
                current_stop=initial_stop,
                highest_price=highest_price,
                lowest_price=lowest_price
            )
            
            self.trailing_stops[position_id] = trailing_config
            
            # Start monitoring if not already running
            if not self.is_monitoring:
                asyncio.create_task(self._monitor_trailing_stops())
                
            logger.info(f"Set trailing stop for {position_id} with {trail_distance} pip trail")
            return True
            
        except Exception as e:
            logger.error(f"Failed to set trailing stop for {position_id}: {e}")
            return False
            
    async def _monitor_trailing_stops(self):
        """Monitor and update trailing stops"""
        self.is_monitoring = True
        
        while self.trailing_stops:
            try:
                await asyncio.sleep(1)  # Check every second
                
                for position_id, config in list(self.trailing_stops.items()):
                    await self._update_trailing_stop(position_id, config)
                    
            except Exception as e:
                logger.error(f"Error in trailing stop monitoring: {e}")
                
        self.is_monitoring = False
        
    async def _update_trailing_stop(self, position_id: str, config: TrailingStopConfig):
        """Update trailing stop based on price movement"""
        try:
            position = self.position_manager.position_cache.get(position_id)
            if not position:
                # Position closed, remove trailing stop
                del self.trailing_stops[position_id]
                return
                
            current_price = position.current_price
            needs_update = False
            new_stop_price = config.current_stop
            
            if position.side == 'long':
                # Update highest price seen
                if current_price > config.highest_price:
                    config.highest_price = current_price
                    new_stop_price = current_price - config.trail_distance
                    needs_update = True
            else:
                # Update lowest price seen
                if current_price < config.lowest_price:
                    config.lowest_price = current_price
                    new_stop_price = current_price + config.trail_distance
                    needs_update = True
                    
            # Update stop loss if needed
            if needs_update and new_stop_price != config.current_stop:
                success = await self.position_manager.modify_stop_loss(position_id, new_stop_price)
                if success:
                    config.current_stop = new_stop_price
                    logger.info(f"Updated trailing stop for {position_id} to {new_stop_price}")
                    
        except Exception as e:
            logger.error(f"Failed to update trailing stop for {position_id}: {e}")
```

### Integration Points
- **OANDA Position API**: Real-time position data and modification
- **Price Streaming**: Current market prices for P&L calculation
- **Compliance Engine**: FIFO validation for US accounts
- **Risk Management**: Position-level risk monitoring
- **Dashboard**: Position display and management interface

### Performance Targets
- Position data refresh: <2 seconds
- Position modification: <1 second execution
- Trailing stop updates: <5 seconds after price change
- Bulk operations: <10 seconds for up to 50 positions

## Testing
- Position data accuracy validation
- Stop loss/take profit modification
- Partial closing calculations
- FIFO compliance enforcement
- Trailing stop functionality
- Bulk operation reliability

## Dev Agent Record

### Agent Model Used
(To be filled by dev agent)

### File List
(To be filled by dev agent)

### Debug Log References
(To be filled by dev agent)

### Completion Notes List
(To be filled by dev agent)

### Change Log
(To be filled by dev agent)
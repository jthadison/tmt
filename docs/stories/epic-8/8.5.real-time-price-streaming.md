# Story 8.5: Real-Time Price Streaming

## Status
Ready

## Story
**As a** trader,
**I want** to receive real-time price updates from OANDA,
**so that** my trading decisions are based on current market data.

## Acceptance Criteria
1. Stream bid/ask prices for subscribed instruments
2. Calculate and display spread in pips
3. Show if instrument is currently tradeable
4. Automatic reconnection on stream interruption
5. Price update frequency of at least 1 update/second
6. Subscribe/unsubscribe to instruments dynamically
7. Price data includes timestamp for latency monitoring
8. Handle market closed periods gracefully

## Tasks / Subtasks
- [ ] Task 1: Implement OANDA streaming connection (AC: 1, 4)
  - [ ] Create OandaStreamManager class
  - [ ] Establish WebSocket connection to OANDA streaming API
  - [ ] Implement streaming authentication
  - [ ] Add connection health monitoring
  - [ ] Create automatic reconnection with exponential backoff
  - [ ] Handle streaming API rate limits

- [ ] Task 2: Build price data processing (AC: 2, 3, 7)
  - [ ] Parse streaming price messages
  - [ ] Calculate pip spreads for each instrument
  - [ ] Add timestamp validation and latency calculation
  - [ ] Implement tradeable status tracking
  - [ ] Create price data validation logic
  - [ ] Add price history buffering

- [ ] Task 3: Create dynamic subscription management (AC: 6)
  - [ ] Implement subscribe/unsubscribe methods
  - [ ] Track active subscriptions per connection
  - [ ] Add subscription validation
  - [ ] Create subscription state management
  - [ ] Implement subscription recovery on reconnect
  - [ ] Add subscription metrics tracking

- [ ] Task 4: Handle market sessions and closures (AC: 8)
  - [ ] Detect market closed periods
  - [ ] Implement graceful handling during closures
  - [ ] Add market session tracking
  - [ ] Create weekend/holiday handling
  - [ ] Implement stale price detection
  - [ ] Add market status indicators

- [ ] Task 5: Build real-time data distribution (AC: 5)
  - [ ] Create WebSocket server for UI updates
  - [ ] Implement price update broadcasting
  - [ ] Add update frequency monitoring (≥1/sec)
  - [ ] Create price change notifications
  - [ ] Implement data compression for efficiency
  - [ ] Add selective update filtering

- [ ] Task 6: Create latency monitoring system (AC: 7)
  - [ ] Track end-to-end latency from OANDA to UI
  - [ ] Implement latency alerting
  - [ ] Create latency performance metrics
  - [ ] Add latency visualization
  - [ ] Monitor network performance
  - [ ] Create latency optimization recommendations

## Dev Notes

### Architecture Context
Real-Time Price Streaming provides the live market data foundation for all trading decisions. This system must maintain low-latency, high-frequency price updates while handling network disruptions and market closures gracefully. It serves as the data backbone for the entire broker integration.

### Previous Story Context
Builds on Story 8.1's connection management to establish streaming data connections. The price stream feeds into trading decision engines and provides real-time market context for the execution systems built in Stories 8.3-8.4.

### Technical Implementation Details

#### OANDA Stream Manager
```python
import asyncio
import websockets
import json
from typing import Dict, Set, Callable, AsyncIterator
from dataclasses import dataclass
from datetime import datetime, timedelta

@dataclass
class PriceTick:
    instrument: str
    bid: Decimal
    ask: Decimal
    spread_pips: Decimal
    timestamp: datetime
    tradeable: bool
    latency_ms: float

class OandaStreamManager:
    def __init__(self, client: OandaClient):
        self.client = client
        self.subscriptions: Set[str] = set()
        self.subscribers: Dict[str, List[Callable]] = defaultdict(list)
        self.websocket = None
        self.is_streaming = False
        self.reconnect_attempts = 0
        self.max_reconnect_attempts = 10
        
    async def start_streaming(self):
        """Start the price streaming connection"""
        while self.reconnect_attempts < self.max_reconnect_attempts:
            try:
                await self._establish_connection()
                await self._stream_prices()
            except Exception as e:
                logger.error(f"Streaming connection failed: {e}")
                await self._handle_disconnection()
                
    async def _establish_connection(self):
        """Establish WebSocket connection to OANDA"""
        stream_url = f"wss://stream-{self.client.environment}.oanda.com/v3/accounts/{self.client.account_id}/pricing/stream"
        
        headers = {
            "Authorization": f"Bearer {self.client.api_key}",
            "Accept-Datetime-Format": "RFC3339"
        }
        
        instruments = ",".join(self.subscriptions) if self.subscriptions else "EUR_USD"
        url_with_params = f"{stream_url}?instruments={instruments}"
        
        self.websocket = await websockets.connect(url_with_params, extra_headers=headers)
        self.is_streaming = True
        self.reconnect_attempts = 0
        
        logger.info(f"Established OANDA price stream for {len(self.subscriptions)} instruments")
        
    async def _stream_prices(self):
        """Process incoming price messages"""
        async for message in self.websocket:
            try:
                data = json.loads(message)
                
                if data.get("type") == "PRICE":
                    await self._process_price_update(data)
                elif data.get("type") == "HEARTBEAT":
                    await self._handle_heartbeat(data)
                    
            except Exception as e:
                logger.error(f"Error processing price message: {e}")
                continue
                
    async def _process_price_update(self, price_data: Dict):
        """Process individual price update"""
        instrument = price_data["instrument"]
        
        # Parse price data
        bid = Decimal(price_data["closeoutBid"])
        ask = Decimal(price_data["closeoutAsk"])
        
        # Calculate spread in pips
        spread_pips = self._calculate_spread_pips(instrument, bid, ask)
        
        # Create price tick
        price_tick = PriceTick(
            instrument=instrument,
            bid=bid,
            ask=ask,
            spread_pips=spread_pips,
            timestamp=datetime.fromisoformat(price_data["time"].replace('Z', '+00:00')),
            tradeable=price_data.get("tradeable", True),
            latency_ms=self._calculate_latency(price_data["time"])
        )
        
        # Distribute to subscribers
        await self._distribute_price_update(price_tick)
        
    def _calculate_spread_pips(self, instrument: str, bid: Decimal, ask: Decimal) -> Decimal:
        """Calculate spread in pips for the instrument"""
        spread = ask - bid
        
        # Get pip value for instrument (most majors use 4 decimal places)
        if "JPY" in instrument:
            pip_value = Decimal("0.01")  # 2 decimal places for JPY pairs
        else:
            pip_value = Decimal("0.0001")  # 4 decimal places for most pairs
            
        return spread / pip_value
        
    def _calculate_latency(self, oanda_timestamp: str) -> float:
        """Calculate latency from OANDA timestamp to now"""
        oanda_time = datetime.fromisoformat(oanda_timestamp.replace('Z', '+00:00'))
        now = datetime.utcnow().replace(tzinfo=timezone.utc)
        latency = (now - oanda_time).total_seconds() * 1000  # Convert to ms
        return latency
```

#### Dynamic Subscription Management
```python
class SubscriptionManager:
    def __init__(self, stream_manager: OandaStreamManager):
        self.stream_manager = stream_manager
        self.active_subscriptions: Set[str] = set()
        self.pending_subscriptions: Set[str] = set()
        
    async def subscribe(self, instruments: List[str]) -> bool:
        """Subscribe to price updates for instruments"""
        new_instruments = set(instruments) - self.active_subscriptions
        
        if not new_instruments:
            return True  # Already subscribed
            
        try:
            # Add to pending subscriptions
            self.pending_subscriptions.update(new_instruments)
            
            # Update stream connection
            all_instruments = self.active_subscriptions | new_instruments
            await self.stream_manager.update_subscriptions(all_instruments)
            
            # Move from pending to active
            self.active_subscriptions.update(new_instruments)
            self.pending_subscriptions -= new_instruments
            
            logger.info(f"Successfully subscribed to {new_instruments}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to subscribe to {new_instruments}: {e}")
            self.pending_subscriptions -= new_instruments
            return False
            
    async def unsubscribe(self, instruments: List[str]) -> bool:
        """Unsubscribe from price updates"""
        instruments_to_remove = set(instruments) & self.active_subscriptions
        
        if not instruments_to_remove:
            return True  # Not subscribed
            
        try:
            # Update active subscriptions
            self.active_subscriptions -= instruments_to_remove
            
            # Update stream connection
            await self.stream_manager.update_subscriptions(self.active_subscriptions)
            
            logger.info(f"Successfully unsubscribed from {instruments_to_remove}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to unsubscribe from {instruments_to_remove}: {e}")
            # Rollback
            self.active_subscriptions.update(instruments_to_remove)
            return False
```

#### Market Session Handler
```python
class MarketSessionHandler:
    def __init__(self):
        self.market_schedules = {
            'EUR_USD': {
                'open': {'day': 0, 'hour': 22, 'minute': 0},  # Sunday 22:00 GMT
                'close': {'day': 4, 'hour': 22, 'minute': 0}  # Friday 22:00 GMT
            }
            # Add more instrument schedules
        }
        
    def is_market_open(self, instrument: str) -> bool:
        """Check if market is currently open for instrument"""
        schedule = self.market_schedules.get(instrument)
        if not schedule:
            return True  # Assume open if no schedule defined
            
        now = datetime.utcnow()
        current_day = now.weekday()  # 0 = Monday, 6 = Sunday
        current_hour = now.hour
        
        # Handle weekend closures
        if current_day >= 5:  # Saturday or Sunday
            if current_day == 6 and current_hour >= 22:  # Sunday after 22:00
                return True
            return False
            
        # Handle Friday closures
        if current_day == 4 and current_hour >= 22:  # Friday after 22:00
            return False
            
        return True
        
    async def handle_market_closure(self, instrument: str):
        """Handle market closure gracefully"""
        logger.info(f"Market closed for {instrument}")
        
        # Send market closed notification
        await self.send_market_status_update(instrument, "CLOSED")
        
        # Stop price updates but maintain connection
        # Prices will resume when market reopens
        
    async def send_market_status_update(self, instrument: str, status: str):
        """Send market status update to subscribers"""
        status_update = {
            'type': 'MARKET_STATUS',
            'instrument': instrument,
            'status': status,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        # Broadcast to WebSocket subscribers
        await self.broadcast_update(status_update)
```

### Integration Points
- **OANDA Streaming API**: Real-time price data source
- **WebSocket Server**: Distribution to dashboard and trading systems
- **Trading Signals**: Price data feeds signal generation systems
- **Risk Management**: Price updates trigger risk calculations
- **Monitoring**: Latency and performance metrics collection

### Performance Targets
- Price update frequency: ≥1 update/second per subscribed instrument
- End-to-end latency: <500ms from OANDA to UI
- Reconnection time: <5 seconds after disconnection
- Subscription changes: <1 second to take effect

## Testing
- Streaming connection reliability
- Price update frequency validation
- Spread calculation accuracy
- Subscription management functionality
- Market closure handling
- Latency monitoring accuracy

## Dev Agent Record

### Agent Model Used
(To be filled by dev agent)

### File List
(To be filled by dev agent)

### Debug Log References
(To be filled by dev agent)

### Completion Notes List
(To be filled by dev agent)

### Change Log
(To be filled by dev agent)
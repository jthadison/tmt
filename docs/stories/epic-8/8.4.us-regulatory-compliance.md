# Story 8.4: US Regulatory Compliance Validation

## Status
Ready

## Story
**As a** US trader,
**I want** automatic FIFO and leverage compliance,
**so that** I never violate NFA regulations.

## Acceptance Criteria
1. Enforce FIFO (First In, First Out) for US accounts
2. Prevent hedging (no simultaneous long/short positions)
3. Limit leverage to 50:1 for major pairs, 20:1 for minors
4. Block orders that would violate FIFO rules
5. Display clear error messages for compliance violations
6. Automatic position selection for FIFO closes
7. Compliance rules configurable per account region
8. Audit log of all compliance checks and results

## Tasks / Subtasks
- [ ] Task 1: Implement FIFO compliance engine (AC: 1, 4, 6)
  - [ ] Create position queue tracking (first in, first out)
  - [ ] Implement automatic position selection for closes
  - [ ] Add FIFO validation before order execution
  - [ ] Create position merge logic for same-direction trades
  - [ ] Implement partial close FIFO handling
  - [ ] Add FIFO violation detection and blocking

- [ ] Task 2: Build anti-hedging system (AC: 2)
  - [ ] Check existing positions before new orders
  - [ ] Block orders that would create hedge positions
  - [ ] Implement position direction validation
  - [ ] Create hedge detection algorithms
  - [ ] Add hedge violation error messages
  - [ ] Implement position consolidation logic

- [ ] Task 3: Create leverage limit enforcement (AC: 3)
  - [ ] Define major/minor currency pair classifications
  - [ ] Implement 50:1 leverage limit for majors
  - [ ] Add 20:1 leverage limit for minors
  - [ ] Calculate effective leverage per order
  - [ ] Block orders exceeding leverage limits
  - [ ] Create leverage calculation display

- [ ] Task 4: Build compliance validation framework (AC: 5, 7, 8)
  - [ ] Create configurable rule engine
  - [ ] Implement region-specific compliance rules
  - [ ] Add comprehensive audit logging
  - [ ] Create compliance violation reporting
  - [ ] Build error message templating system
  - [ ] Implement compliance metrics tracking

## Dev Notes

### Architecture Context
US Regulatory Compliance is critical for serving US-based retail traders who must comply with NFA (National Futures Association) regulations. The system must prevent violations before they occur while providing clear guidance to users about regulatory requirements.

### Technical Implementation Details

#### FIFO Compliance Engine
```python
class FIFOComplianceEngine:
    def __init__(self):
        self.position_queues = defaultdict(deque)  # instrument -> queue of positions
        
    async def validate_order(self, order: OrderRequest) -> ComplianceResult:
        \"\"\"Validate order against FIFO rules\"\"\"
        if order.account_region != 'US':
            return ComplianceResult(valid=True)
            
        # Check for FIFO violations
        if order.order_type == 'CLOSE':
            return await self.validate_fifo_close(order)
        elif order.order_type == 'MARKET':
            return await self.validate_new_position(order)
            
    async def validate_fifo_close(self, order: OrderRequest) -> ComplianceResult:
        \"\"\"Ensure closes follow FIFO order\"\"\"
        position_queue = self.position_queues[order.instrument]
        
        if not position_queue:
            return ComplianceResult(
                valid=False,
                reason=\"No positions to close for FIFO compliance\"
            )
            
        # Must close oldest position first
        oldest_position = position_queue[0]
        if order.units > oldest_position.units:
            return ComplianceResult(
                valid=False,
                reason=f\"FIFO violation: Must close oldest position ({oldest_position.units} units) before newer positions\"
            )
            
        return ComplianceResult(valid=True)
        
    def auto_select_fifo_positions(self, instrument: str, units_to_close: int) -> List[Position]:
        \"\"\"Automatically select positions for FIFO-compliant closing\"\"\"
        position_queue = self.position_queues[instrument]
        selected_positions = []
        remaining_units = units_to_close
        
        while remaining_units > 0 and position_queue:
            oldest_position = position_queue[0]
            
            if oldest_position.units <= remaining_units:
                # Close entire position
                selected_positions.append(oldest_position)
                remaining_units -= oldest_position.units
                position_queue.popleft()
            else:
                # Partial close
                partial_position = Position(
                    units=remaining_units,
                    entry_price=oldest_position.entry_price,
                    timestamp=oldest_position.timestamp
                )
                selected_positions.append(partial_position)
                oldest_position.units -= remaining_units
                remaining_units = 0
                
        return selected_positions
```

#### Anti-Hedging System
```python
class AntiHedgingValidator:
    def __init__(self, position_manager: PositionManager):
        self.position_manager = position_manager
        
    async def validate_no_hedging(self, order: OrderRequest) -> ComplianceResult:
        \"\"\"Prevent hedging for US accounts\"\"\"
        if order.account_region != 'US':
            return ComplianceResult(valid=True)
            
        # Get existing positions
        existing_positions = await self.position_manager.get_positions(
            instrument=order.instrument
        )
        
        # Check for opposite direction positions\        for position in existing_positions:
            if self.would_create_hedge(position, order):
                return ComplianceResult(
                    valid=False,
                    reason=f\"Hedging violation: Cannot open {order.side} position while {position.side} position exists\"
                )
                
        return ComplianceResult(valid=True)
        
    def would_create_hedge(self, position: Position, order: OrderRequest) -> bool:
        \"\"\"Check if order would create a hedge\"\"\"
        return (
            position.instrument == order.instrument and
            position.side != order.side and
            position.units > 0
        )
```

#### Leverage Limit Enforcement
```python
class LeverageLimitValidator:
    def __init__(self):
        self.major_pairs = {
            'EUR_USD', 'GBP_USD', 'USD_JPY', 'USD_CHF', 
            'USD_CAD', 'AUD_USD', 'NZD_USD'
        }
        self.leverage_limits = {
            'major': Decimal('50'),  # 50:1
            'minor': Decimal('20')   # 20:1
        }
        
    async def validate_leverage(self, order: OrderRequest, account: AccountSummary) -> ComplianceResult:
        \"\"\"Validate order doesn't exceed leverage limits\"\"\"
        if order.account_region != 'US':
            return ComplianceResult(valid=True)
            
        # Calculate effective leverage
        pair_type = 'major' if order.instrument in self.major_pairs else 'minor'
        max_leverage = self.leverage_limits[pair_type]
        
        # Calculate position value
        position_value = abs(order.units) * order.price
        required_margin = position_value / max_leverage
        
        if required_margin > account.margin_available:
            return ComplianceResult(
                valid=False,
                reason=f\"Leverage limit exceeded: {pair_type} pairs limited to {max_leverage}:1 leverage\"
            )
            
        return ComplianceResult(valid=True)
```

## Testing
- FIFO position ordering validation
- Anti-hedging prevention accuracy  
- Leverage limit calculations
- Compliance rule configuration
- Audit log completeness
- Error message clarity

## Dev Agent Record

### Agent Model Used
(To be filled by dev agent)

### File List
(To be filled by dev agent)

### Debug Log References
(To be filled by dev agent)

### Completion Notes List
(To be filled by dev agent)

### Change Log
(To be filled by dev agent)
# Story 6.3: Decision Disagreement System

## Status
Ready

## Story
**As a** correlation masking system,  
**I want** accounts to occasionally make different decisions,  
**so that** they don't appear coordinated.

## Acceptance Criteria
1. 15-20% of signals result in different actions across accounts
2. Some accounts skip signals due to "personal" risk preferences
3. Entry timing spreads increased during high-signal periods
4. Different take profit levels based on personality "greed" factor
5. Disagreement logging showing rationale for variance
6. Correlation coefficient maintained below 0.7 between any two accounts

## Tasks / Subtasks

- [ ] Task 1: Implement signal disagreement engine (AC: 1)
  - [ ] Create 15-20% disagreement rate calculator
  - [ ] Build personality-based decision divergence
  - [ ] Implement signal strength impact on disagreement
  - [ ] Create market condition disagreement triggers
  - [ ] Add disagreement decision logging system
  
- [ ] Task 2: Build risk-based signal skipping (AC: 2)
  - [ ] Create personality risk threshold system
  - [ ] Implement "personal preference" skip logic
  - [ ] Build market condition risk assessment
  - [ ] Add skip reason generation with human-like explanations
  - [ ] Create skip pattern tracking and validation
  
- [ ] Task 3: Develop timing spread mechanism (AC: 3)
  - [ ] Implement high-signal period detection
  - [ ] Create entry timing spread algorithms
  - [ ] Build personality-based timing preferences
  - [ ] Add coordination avoidance during high activity
  - [ ] Create timing distribution monitoring
  
- [ ] Task 4: Build dynamic take profit system (AC: 4)
  - [ ] Implement personality "greed factor" calculations
  - [ ] Create variable take profit level assignment
  - [ ] Build market condition impact on profit targets
  - [ ] Add profit target rationalization system
  - [ ] Create profit level disagreement tracking
  
- [ ] Task 5: Create disagreement logging system (AC: 5)
  - [ ] Build comprehensive disagreement audit trail
  - [ ] Implement rationale generation for all decisions
  - [ ] Create human-readable decision explanations
  - [ ] Add disagreement pattern analysis tools
  - [ ] Build disagreement performance tracking
  
- [ ] Task 6: Implement correlation monitoring (AC: 6)
  - [ ] Create real-time correlation coefficient calculation
  - [ ] Build correlation threshold enforcement (< 0.7)
  - [ ] Implement correlation alert system
  - [ ] Add correlation adjustment algorithms
  - [ ] Create correlation reporting dashboard

## Dev Notes

### Architecture Context
This story implements the decision disagreement system that ensures accounts don't appear coordinated by making different trading decisions on the same signals. This is critical for avoiding prop firm detection algorithms that look for correlated behavior patterns across multiple accounts.

### Anti-Correlation Strategy
[Source: docs/architecture/anti-detection-architecture.md]
The disagreement system operates on multiple levels:
- **Signal Level**: Different interpretations of the same market signal
- **Timing Level**: Staggered entry times to avoid simultaneous execution
- **Risk Level**: Varied position sizes based on "personal" risk preferences
- **Exit Level**: Different profit targets and stop loss levels
- **Skip Level**: Some accounts skip signals others take

### Mathematical Foundation
[Source: docs/architecture/correlation-analysis.md]
```python
# Correlation coefficient must stay below 0.7
def calculate_correlation_coefficient(account1_returns, account2_returns):
    return np.corrcoef(account1_returns, account2_returns)[0, 1]

# Target correlation range: 0.3 - 0.6 (realistic for similar strategies)
TARGET_CORRELATION_MIN = 0.3
TARGET_CORRELATION_MAX = 0.6
ALERT_THRESHOLD = 0.7
```

### Data Models
[Source: docs/architecture/data-models.md]
```typescript
interface SignalDisagreement {
  signalId: string;
  timestamp: Date;
  
  // Original Signal
  originalSignal: {
    symbol: string;
    direction: 'long' | 'short';
    strength: number;        // 0-1 confidence
    price: number;
    stopLoss: number;
    takeProfit: number;
  };
  
  // Account Decisions
  accountDecisions: AccountDecision[];
  
  // Disagreement Analysis
  disagreementMetrics: {
    participationRate: number;     // % of accounts that took signal
    directionConsensus: number;    // % agreement on direction
    timingSpread: number;          // Seconds between first and last entry
    sizingVariation: number;       // Coefficient of variation in sizes
    profitTargetSpread: number;    // Range of take profit levels
  };
  
  // Correlation Impact
  correlationImpact: {
    beforeSignal: Record<string, number>;  // Account pair correlations
    afterSignal: Record<string, number>;   // Updated correlations
    targetAdjustments: CorrelationAdjustment[];
  };
}

interface AccountDecision {
  accountId: string;
  personalityId: string;
  
  // Decision Details
  decision: 'take' | 'skip' | 'modify' | 'delay';
  reasoning: string;             // Human-readable explanation
  
  // Modifications (if decision = 'modify')
  modifications: {
    direction?: 'long' | 'short';
    size?: number;
    entryPrice?: number;
    stopLoss?: number;
    takeProfit?: number;
    timing?: number;             // Delay in seconds
  };
  
  // Risk Assessment
  riskAssessment: {
    personalRiskLevel: number;   // 0-1
    marketRiskLevel: number;     // 0-1
    portfolioRiskLevel: number;  // 0-1
    combinedRiskLevel: number;   // 0-1
    riskThreshold: number;       // Personal threshold
  };
  
  // Personality Factors
  personalityFactors: {
    greedFactor: number;         // Affects take profit
    fearFactor: number;          // Affects stop loss
    impatienceLevel: number;     // Affects timing
    conformityLevel: number;     // Likelihood to follow crowd
    contrarian: boolean;         // Tendency to go against consensus
  };
  
  processedAt: Date;
  executedAt?: Date;
}

interface DisagreementProfile {
  personalityId: string;
  
  // Base Disagreement Rates
  baseDisagreementRate: number;    // 0.15 - 0.20 (15-20%)
  
  // Decision Biases
  biases: {
    riskAversion: number;          // 0-1, higher = more likely to skip
    signalSkepticism: number;      // 0-1, tendency to question signals
    crowdFollowing: number;        // 0-1, follow vs. oppose majority
    profitTaking: number;          // 0-1, greedy vs. conservative
    lossAvoidance: number;         // 0-1, tight vs. loose stops
  };
  
  // Situational Modifiers
  situationalModifiers: {
    marketVolatility: number;      // How vol affects disagreement
    newsEvents: number;            // News impact on decisions
    timeOfDay: Record<string, number>; // Hour-specific disagreement rates
    dayOfWeek: Record<string, number>; // Day-specific patterns
  };
  
  // Correlation Awareness
  correlationAwareness: {
    monitorCorrelation: boolean;   // Whether this personality monitors correlation
    correlationSensitivity: number; // How much correlation affects decisions
    antiCorrelationBias: number;   // Tendency to deliberately disagree
  };
}

interface CorrelationMonitor {
  accountPairs: AccountPair[];
  
  // Real-time Correlation Tracking
  currentCorrelations: Record<string, number>; // accountId1_accountId2 -> correlation
  correlationHistory: CorrelationDataPoint[];
  
  // Alert System
  alerts: CorrelationAlert[];
  thresholds: {
    warning: number;    // 0.6
    critical: number;   // 0.7
    emergency: number;  // 0.8
  };
  
  // Adjustment Mechanisms
  adjustmentStrategies: CorrelationAdjustmentStrategy[];
  
  lastUpdate: Date;
}

interface CorrelationDataPoint {
  timestamp: Date;
  accountPair: string;
  correlation: number;
  signalCount: number;        // Number of signals in this period
  agreementRate: number;      // How often they agreed
}
```

### Disagreement Algorithms
[Source: docs/architecture/disagreement-engine.md]
```python
class DisagreementEngine:
    def generate_disagreements(self, signal: Signal, accounts: List[Account]) -> List[AccountDecision]:
        decisions = []
        
        # Step 1: Calculate base participation (80-85% should participate)
        participation_rate = self.calculate_participation_rate(signal, accounts)
        participating_accounts = self.select_participants(accounts, participation_rate)
        
        # Step 2: Generate disagreements for participants
        for account in participating_accounts:
            personality = self.get_personality(account.id)
            decision = self.generate_account_decision(signal, account, personality)
            decisions.append(decision)
        
        # Step 3: Create non-participants (skippers)
        for account in accounts:
            if account not in participating_accounts:
                skip_decision = self.generate_skip_decision(signal, account)
                decisions.append(skip_decision)
        
        # Step 4: Adjust for correlation constraints
        decisions = self.adjust_for_correlation(decisions, signal)
        
        return decisions
    
    def generate_account_decision(self, signal: Signal, account: Account, personality: TradingPersonality) -> AccountDecision:
        # Base decision: take the signal
        decision = AccountDecision(account_id=account.id, decision='take')
        
        # Apply personality-based modifications
        
        # 1. Greed factor affects take profit
        greed_factor = personality.modifiers.greed_factor
        tp_multiplier = 0.8 + (greed_factor * 0.4)  # 0.8x to 1.2x
        decision.modifications.take_profit = signal.take_profit * tp_multiplier
        
        # 2. Fear factor affects stop loss
        fear_factor = personality.modifiers.fear_factor
        sl_multiplier = 1.2 - (fear_factor * 0.4)  # 0.8x to 1.2x
        decision.modifications.stop_loss = signal.stop_loss * sl_multiplier
        
        # 3. Impatience affects timing
        impatience = personality.modifiers.impatience_level
        max_delay = 30 * (1 - impatience)  # 0 to 30 seconds
        decision.modifications.timing = random.uniform(0, max_delay)
        
        # 4. Risk assessment
        risk_level = self.calculate_risk_level(signal, account, personality)
        if risk_level > personality.risk_threshold:
            decision.decision = 'skip'
            decision.reasoning = f"Risk level {risk_level:.2f} exceeds personal threshold {personality.risk_threshold:.2f}"
        
        return decision
    
    def adjust_for_correlation(self, decisions: List[AccountDecision], signal: Signal) -> List[AccountDecision]:
        # Monitor current correlation levels
        current_correlations = self.correlation_monitor.get_current_correlations()
        
        # Identify account pairs with high correlation
        high_correlation_pairs = [
            (pair, corr) for pair, corr in current_correlations.items() 
            if corr > 0.65
        ]
        
        # Force disagreements for high-correlation pairs
        for pair, correlation in high_correlation_pairs:
            account1, account2 = pair.split('_')
            
            # Find decisions for this pair
            decision1 = next(d for d in decisions if d.account_id == account1)
            decision2 = next(d for d in decisions if d.account_id == account2)
            
            # Force disagreement (one skips or modifies significantly)
            if decision1.decision == 'take' and decision2.decision == 'take':
                # Randomly choose one to skip or modify
                if random.random() < 0.5:
                    decision1.decision = 'skip'
                    decision1.reasoning = "Avoiding correlation with related account"
                else:
                    # Modify decision2 significantly
                    decision2.decision = 'modify'
                    decision2.modifications.take_profit *= random.uniform(0.7, 1.3)
                    decision2.reasoning = "Personal profit target preference"
        
        return decisions
```

### Component Architecture
[Source: docs/architecture/backend-architecture.md]
```
agents/
├── disagreement-engine/
│   ├── DisagreementEngine.py      # Main disagreement logic
│   ├── DecisionGenerator.py       # Individual account decisions
│   ├── CorrelationMonitor.py      # Real-time correlation tracking
│   ├── RiskAssessment.py          # Risk-based decision making
│   ├── TimingSpread.py           # Entry timing distribution
│   └── DisagreementLogger.py      # Audit and logging
```

### Correlation Monitoring
[Source: docs/architecture/correlation-monitoring.md]
```python
class CorrelationMonitor:
    def __init__(self):
        self.correlation_window = 100  # Last 100 trades
        self.update_frequency = 'per_signal'  # Update after each signal
        
    def calculate_rolling_correlation(self, account1_trades, account2_trades):
        # Use last N trades for correlation calculation
        recent1 = account1_trades[-self.correlation_window:]
        recent2 = account2_trades[-self.correlation_window:]
        
        # Align trades by timestamp (within 1 hour window)
        aligned_returns1, aligned_returns2 = self.align_trades(recent1, recent2)
        
        if len(aligned_returns1) < 10:  # Need minimum trades
            return None
            
        return np.corrcoef(aligned_returns1, aligned_returns2)[0, 1]
    
    def trigger_correlation_alert(self, account_pair, correlation):
        if correlation > 0.7:
            alert = CorrelationAlert(
                account_pair=account_pair,
                correlation=correlation,
                severity='critical',
                recommended_action='force_disagreement'
            )
            self.send_alert(alert)
```

### Human-Like Decision Reasoning
[Source: docs/architecture/decision-reasoning.md]
```python
SKIP_REASONS = [
    "Market too volatile for my risk appetite",
    "Already have similar exposure",
    "Waiting for better entry opportunity",
    "Not convinced by signal strength",
    "Taking a break after recent losses",
    "Prefer to trade different session",
    "Signal came during lunch break",
    "Weekend gap makes me cautious",
    "News event uncertainty",
    "Account approaching daily limit"
]

MODIFICATION_REASONS = [
    "Taking smaller position due to volatility",
    "Adjusting profit target based on support/resistance",
    "Tighter stop loss for risk management",
    "Wider stop loss for volatility buffer",
    "Personal preference for this pair",
    "Account size adjustment",
    "End of week position sizing",
    "Conservative approach during news"
]
```

### Performance Impact Analysis
[Source: docs/architecture/performance-analysis.md]
The disagreement system must balance:
- **Stealth Benefits**: Reduced correlation risk, improved longevity
- **Performance Cost**: Some accounts miss profitable signals
- **Optimization**: Target 5-10% performance reduction for 90% correlation reduction

### Testing Standards
- Test disagreement rate accuracy (15-20% ± 2%)
- Verify correlation coefficient maintenance (< 0.7)
- Test timing spread during high-signal periods
- Validate decision reasoning quality
- Test correlation adjustment algorithms

## Testing

### Test Requirements
[Source: docs/architecture/testing-strategy.md]
- **Unit Tests**: Disagreement algorithms, correlation calculations, decision logic
- **Integration Tests**: Multi-account signal processing, correlation monitoring
- **Statistical Tests**: Disagreement rate accuracy, correlation distribution
- **Performance Tests**: Decision processing speed, correlation calculation performance
- **Behavioral Tests**: Decision reasoning quality, human-likeness validation
- **Location**: `agents/disagreement-engine/__tests__/`

### Specific Testing Focus
- Disagreement rate accuracy across different signal strengths
- Correlation coefficient enforcement and monitoring
- Decision reasoning quality and variety
- Timing spread effectiveness during high-signal periods
- Performance impact measurement and optimization

### Statistical Validation
- Binomial tests for disagreement rate accuracy (15-20%)
- Correlation analysis between account pairs over time
- Chi-square tests for decision reason distribution
- ANOVA for timing spread effectiveness
- Monte Carlo simulation for correlation impact

### Mock Data Requirements
- Signal datasets with varying strengths and frequencies
- Multiple personality profiles with different bias patterns
- Historical trading data for correlation baseline
- High-signal period scenarios for timing spread testing

### Correlation Testing Scenarios
- Account pairs starting with high correlation (> 0.8)
- Gradual correlation increase over time
- Emergency correlation reduction scenarios
- Multiple account correlation network effects

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-12 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation.*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here after implementation.*
# Story 6.4: Human-Like Behavior Patterns

## Status
Ready

## Story
**As a** behavioral simulation system,  
**I want** to replicate common human trading behaviors,  
**so that** the system appears genuinely human.

## Acceptance Criteria
1. Gradual position size increases after winning streaks
2. Slightly reduced activity after losing days (risk aversion)
3. End-of-week position flattening for some personalities
4. Lunch break patterns for day-trader personalities
5. Occasional manual-looking adjustments to round numbers
6. Session preference consistency (London trader focuses on London session)

## Tasks / Subtasks

- [ ] Task 1: Implement winning streak behavior (AC: 1)
  - [ ] Create streak detection algorithms
  - [ ] Build gradual position size scaling system
  - [ ] Implement confidence-based size adjustments
  - [ ] Add streak-based risk tolerance changes
  - [ ] Create streak behavior logging and monitoring
  
- [ ] Task 2: Develop loss aversion patterns (AC: 2)
  - [ ] Create losing day detection system
  - [ ] Implement activity reduction algorithms
  - [ ] Build risk reduction after losses
  - [ ] Add emotional recovery simulation
  - [ ] Create loss impact tracking system
  
- [ ] Task 3: Build end-of-week behavior (AC: 3)
  - [ ] Create weekend risk management system
  - [ ] Implement selective position flattening
  - [ ] Build personality-based weekend preferences
  - [ ] Add Friday afternoon behavior patterns
  - [ ] Create weekend preparation algorithms
  
- [ ] Task 4: Implement daily routine patterns (AC: 4)
  - [ ] Create lunch break detection and behavior
  - [ ] Build session-based activity patterns
  - [ ] Implement time-of-day trading preferences
  - [ ] Add break and routine simulation
  - [ ] Create daily schedule consistency
  
- [ ] Task 5: Develop manual adjustment simulation (AC: 5)
  - [ ] Create round number preference system
  - [ ] Implement manual-looking position adjustments
  - [ ] Build psychological level attraction
  - [ ] Add occasional "human error" simulation
  - [ ] Create adjustment rationale generation
  
- [ ] Task 6: Build session consistency system (AC: 6)
  - [ ] Create trader location-based preferences
  - [ ] Implement session focus algorithms
  - [ ] Build consistent session behavior patterns
  - [ ] Add session preference evolution
  - [ ] Create session performance tracking

## Dev Notes

### Architecture Context
This story implements human-like behavioral patterns that make the automated trading system appear as genuine human traders. These patterns simulate the psychological and practical aspects of human trading, including emotional responses, daily routines, and behavioral biases that are characteristic of real traders.

### Behavioral Psychology Integration
[Source: docs/architecture/behavioral-psychology.md]
The system incorporates established trading psychology principles:
- **Confirmation Bias**: Increased confidence after wins leads to larger positions
- **Loss Aversion**: Reduced activity after losses due to emotional impact
- **Availability Heuristic**: Recent performance heavily influences decision-making
- **Anchoring Bias**: Preference for round numbers and psychological levels
- **Routine Dependence**: Consistent patterns based on personal schedules

### Data Models
[Source: docs/architecture/data-models.md]
```typescript
interface HumanBehaviorProfile {
  personalityId: string;
  traderType: 'scalper' | 'day_trader' | 'swing_trader';
  location: string;           // Used for session preferences
  timezone: string;
  
  // Streak Behavior
  streakBehavior: {
    winStreakSensitivity: number;     // 0-1, how much wins affect size
    maxSizeMultiplier: number;        // Max position size increase
    streakMemory: number;             // How many trades to consider
    confidenceGrowthRate: number;     // How fast confidence builds
    overconfidenceThreshold: number;  // When to start reducing size
  };
  
  // Loss Response
  lossResponse: {
    lossAversion: number;             // 0-1, sensitivity to losses
    recoveryTime: number;             // Hours to recover from losses
    activityReduction: number;        // % reduction in trading activity
    riskReduction: number;            // % reduction in position size
    emotionalVolatility: number;      // How much emotions fluctuate
  };
  
  // Weekly Patterns
  weeklyPatterns: {
    endOfWeekFlattening: boolean;     // Flatten positions on Friday
    fridayReduction: number;          // % activity reduction on Friday
    mondayMorningCaution: number;     // Extra caution Monday morning
    weekendGapAversion: number;       // Avoid weekend gap risk
  };
  
  // Daily Routines
  dailyRoutines: {
    lunchBreaks: boolean;             // Take lunch breaks
    lunchStartTime: string;           // "12:00" in local time
    lunchDuration: number;            // Minutes
    morningWarmup: boolean;           // Gradual activity increase
    eveningWinddown: boolean;         // Gradual activity decrease
    sessionPreferences: SessionPreference[];
  };
  
  // Manual Adjustment Tendencies
  manualTendencies: {
    roundNumberPreference: number;    // 0-1, attraction to round numbers
    adjustmentFrequency: number;      // How often to make manual adjustments
    psychologicalLevels: boolean;     // Prefer .00, .50 levels
    errorRate: number;               // Occasional "typos" or mistakes
    secondGuessing: number;          // Tendency to modify orders
  };
}

interface BehaviorState {
  personalityId: string;
  currentState: {
    // Streak Information
    currentWinStreak: number;
    currentLossStreak: number;
    streakStartDate: Date;
    confidenceLevel: number;          // 0-1
    
    // Recent Performance Impact
    recentLosses: number;             // Last 24h losses
    emotionalState: 'confident' | 'neutral' | 'cautious' | 'fearful';
    lastLossDate?: Date;
    recoveryProgress: number;         // 0-1
    
    // Weekly State
    weeklyPnL: number;
    positionsToFlatten: string[];     // Positions to close Friday
    fridayBehavior: 'normal' | 'reducing' | 'flattening';
    
    // Daily State
    currentSession: 'asian' | 'london' | 'newyork' | 'overlap';
    inLunchBreak: boolean;
    lunchBreakStart?: Date;
    dailyActivity: number;            // 0-1 current activity level
    
    // Manual Adjustment State
    lastManualAdjustment?: Date;
    adjustmentsMadeToday: number;
    pendingAdjustments: ManualAdjustment[];
  };
  
  lastUpdated: Date;
}

interface SessionPreference {
  session: 'asian' | 'london' | 'newyork';
  preference: number;               // 0-1, how much this trader likes this session
  activityMultiplier: number;       // Activity level during this session
  pairPreferences: string[];        // Preferred pairs during this session
}

interface ManualAdjustment {
  id: string;
  positionId: string;
  adjustmentType: 'stop_loss' | 'take_profit' | 'position_size';
  originalValue: number;
  newValue: number;
  reasoning: string;
  triggerType: 'round_number' | 'psychological_level' | 'second_guessing' | 'error_correction';
  scheduledFor: Date;
}

interface BehaviorMetrics {
  personalityId: string;
  period: {
    start: Date;
    end: Date;
  };
  
  // Streak Metrics
  streakMetrics: {
    averageWinStreak: number;
    maxWinStreak: number;
    averageLossStreak: number;
    maxLossStreak: number;
    sizeAdjustmentAccuracy: number;   // How well size adjusts to streaks
  };
  
  // Loss Response Metrics
  lossResponseMetrics: {
    averageRecoveryTime: number;      // Hours
    activityReductionAccuracy: number;
    riskAdjustmentEffectiveness: number;
    emotionalResponseConsistency: number;
  };
  
  // Weekly Pattern Metrics
  weeklyMetrics: {
    fridayFlatteningRate: number;     // % of Fridays with flattening
    weekendGapAvoidance: number;      // % positions closed before weekend
    mondayMorningCaution: number;     // Activity reduction Monday AM
  };
  
  // Daily Routine Metrics
  routineMetrics: {
    lunchBreakConsistency: number;    // How consistently lunch breaks taken
    sessionPreferenceAccuracy: number;
    routineAdherence: number;         // How well daily patterns followed
  };
  
  // Manual Adjustment Metrics
  adjustmentMetrics: {
    roundNumberFrequency: number;     // % of adjustments to round numbers
    adjustmentReasonDistribution: Record<string, number>;
    adjustmentSuccessRate: number;    // Impact on performance
  };
}
```

### Behavioral Algorithms
[Source: docs/architecture/human-behavior-engine.md]
```python
class HumanBehaviorEngine:
    def apply_behavioral_modifications(self, signal: Signal, personality: TradingPersonality, 
                                     behavior_state: BehaviorState) -> SignalModification:
        modifications = SignalModification()
        
        # 1. Streak-based position sizing
        size_modifier = self.calculate_streak_size_modifier(behavior_state, personality)
        modifications.position_size = signal.size * size_modifier
        
        # 2. Loss aversion activity reduction
        activity_modifier = self.calculate_activity_modifier(behavior_state, personality)
        if random.random() > activity_modifier:
            modifications.skip_signal = True
            modifications.skip_reason = "Reduced activity after recent losses"
        
        # 3. End-of-week behavior
        if self.is_friday_afternoon() and personality.weekly_patterns.end_of_week_flattening:
            modifications.position_size *= 0.5  # Reduce size
            modifications.early_exit_bias = 0.3  # 30% more likely to exit early
        
        # 4. Daily routine patterns
        if self.is_lunch_time(personality, behavior_state):
            modifications.skip_signal = True
            modifications.skip_reason = "Lunch break"
        
        # 5. Manual adjustments
        manual_adjustments = self.generate_manual_adjustments(signal, personality)
        modifications.manual_adjustments = manual_adjustments
        
        # 6. Session preferences
        session_modifier = self.calculate_session_preference_modifier(personality)
        modifications.position_size *= session_modifier
        
        return modifications
    
    def calculate_streak_size_modifier(self, behavior_state: BehaviorState, 
                                     personality: TradingPersonality) -> float:
        win_streak = behavior_state.current_state.current_win_streak
        
        if win_streak <= 0:
            return 1.0  # No modification for no streak
        
        # Gradual size increase with diminishing returns
        sensitivity = personality.streak_behavior.win_streak_sensitivity
        max_multiplier = personality.streak_behavior.max_size_multiplier
        
        # Logarithmic growth to prevent extreme position sizes
        size_multiplier = 1.0 + (math.log(1 + win_streak) * sensitivity * 0.1)
        
        # Cap at maximum multiplier
        size_multiplier = min(size_multiplier, max_multiplier)
        
        # Add overconfidence reduction for very long streaks
        overconfidence_threshold = personality.streak_behavior.overconfidence_threshold
        if win_streak > overconfidence_threshold:
            reduction = 0.1 * (win_streak - overconfidence_threshold)
            size_multiplier *= (1 - min(reduction, 0.5))  # Max 50% reduction
        
        return size_multiplier
    
    def calculate_activity_modifier(self, behavior_state: BehaviorState, 
                                  personality: TradingPersonality) -> float:
        recent_losses = behavior_state.current_state.recent_losses
        recovery_progress = behavior_state.current_state.recovery_progress
        
        if recent_losses <= 0:
            return 1.0  # Normal activity
        
        # Loss aversion impact
        loss_aversion = personality.loss_response.loss_aversion
        base_reduction = personality.loss_response.activity_reduction
        
        # Calculate activity reduction based on losses and recovery
        loss_impact = min(recent_losses / 1000, 1.0)  # Normalize to $1000 loss
        activity_reduction = base_reduction * loss_impact * loss_aversion
        
        # Recovery factor
        recovery_factor = recovery_progress  # 0 = no recovery, 1 = full recovery
        final_reduction = activity_reduction * (1 - recovery_factor)
        
        return max(0.3, 1.0 - final_reduction)  # Minimum 30% activity
    
    def generate_manual_adjustments(self, signal: Signal, personality: TradingPersonality) -> List[ManualAdjustment]:
        adjustments = []
        
        # Round number attractions
        if random.random() < personality.manual_tendencies.round_number_preference:
            # Adjust stop loss or take profit to nearest round number
            if signal.stop_loss % 10 != 0:  # Not already on round number
                rounded_sl = round(signal.stop_loss / 10) * 10
                if abs(rounded_sl - signal.stop_loss) <= 3:  # Within 3 pips
                    adjustment = ManualAdjustment(
                        adjustment_type='stop_loss',
                        original_value=signal.stop_loss,
                        new_value=rounded_sl,
                        reasoning="Prefer round number stop loss",
                        trigger_type='round_number'
                    )
                    adjustments.append(adjustment)
        
        # Occasional second-guessing
        if random.random() < personality.manual_tendencies.second_guessing:
            # Modify take profit slightly
            tp_adjustment = random.uniform(-0.95, 1.05)  # ±5% adjustment
            new_tp = signal.take_profit * tp_adjustment
            adjustment = ManualAdjustment(
                adjustment_type='take_profit',
                original_value=signal.take_profit,
                new_value=new_tp,
                reasoning="Second thoughts on profit target",
                trigger_type='second_guessing'
            )
            adjustments.append(adjustment)
        
        return adjustments
```

### Component Architecture
[Source: docs/architecture/backend-architecture.md]
```
agents/
├── human-behavior/
│   ├── HumanBehaviorEngine.py     # Main behavior application
│   ├── StreakBehavior.py          # Winning/losing streak patterns
│   ├── LossAversion.py            # Post-loss behavior changes
│   ├── WeeklyPatterns.py          # End-of-week behaviors
│   ├── DailyRoutines.py           # Time-of-day patterns
│   ├── ManualAdjustments.py       # Human-like modifications
│   └── SessionPreferences.py      # Trading session behaviors
```

### Daily Routine Modeling
[Source: docs/architecture/daily-routines.md]
```python
def check_lunch_break(personality, current_time, behavior_state):
    if not personality.daily_routines.lunch_breaks:
        return False
    
    # Convert times to trader's local timezone
    local_time = current_time.astimezone(personality.timezone)
    lunch_start = parse_time(personality.daily_routines.lunch_start_time)
    lunch_end = lunch_start + timedelta(minutes=personality.daily_routines.lunch_duration)
    
    # Check if currently in lunch break
    current_time_only = local_time.time()
    return lunch_start <= current_time_only <= lunch_end

def calculate_session_activity(personality, current_session):
    session_pref = next(
        (pref for pref in personality.daily_routines.session_preferences 
         if pref.session == current_session), 
        None
    )
    
    if session_pref:
        return session_pref.activity_multiplier
    else:
        return 0.3  # Low activity during non-preferred sessions
```

### Weekend Behavior Patterns
[Source: docs/architecture/weekend-behavior.md]
- **Friday Afternoon**: 40% of day traders reduce position sizes
- **Friday Evening**: 60% of swing traders flatten positions
- **Sunday Open**: Different personalities have varying gap strategies
- **Monday Morning**: 20% more cautious behavior in first hour

### Performance Impact Monitoring
[Source: docs/architecture/performance-monitoring.md]
The human behavior patterns should:
- Reduce overall returns by 10-15% (cost of appearing human)
- Increase variance to match human trading patterns
- Maintain overall profitability while adding realistic inefficiencies
- Track behavioral consistency over time

### Testing Standards
- Test streak behavior with simulated win/loss sequences
- Verify loss aversion triggers and recovery patterns
- Test weekly pattern consistency
- Validate lunch break and routine adherence
- Test manual adjustment realism and frequency

## Testing

### Test Requirements
[Source: docs/architecture/testing-strategy.md]
- **Unit Tests**: Individual behavior algorithms, streak calculations, routine patterns
- **Integration Tests**: Behavior modification pipeline, state management
- **Behavioral Tests**: Human-likeness validation, pattern consistency
- **Performance Tests**: Behavior processing speed, memory usage
- **Statistical Tests**: Behavior distribution analysis, realism validation
- **Location**: `agents/human-behavior/__tests__/`

### Specific Testing Focus
- Streak behavior scaling accuracy and bounds checking
- Loss aversion recovery time and activity reduction
- Weekly pattern consistency and Friday behavior
- Daily routine adherence and lunch break patterns
- Manual adjustment frequency and realism
- Session preference consistency

### Behavioral Validation
- Expert trader review of generated behaviors
- Statistical comparison with human trading data
- Pattern analysis for detecting artificial behaviors
- Consistency testing across different market conditions
- Long-term behavior evolution validation

### Mock Data Requirements
- Win/loss streak sequences for streak behavior testing
- Historical loss scenarios for aversion testing
- Weekly trading data for pattern validation
- Daily routine scenarios for schedule testing
- Manual adjustment examples from real traders

### Performance Benchmarks
- Behavior modification: < 2ms per signal
- State updates: < 1ms per update
- Memory usage: < 5MB per personality
- Pattern consistency: > 90% adherence to defined behaviors

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-12 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation.*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here after implementation.*
# Story 6.2: Execution Variance Engine

## Status
Ready

## Story
**As an** anti-detection system,  
**I want** natural variance in trade execution,  
**so that** patterns don't appear algorithmic.

## Acceptance Criteria
1. Entry timing variance of 1-30 seconds from signal generation
2. Position size rounding to human-friendly numbers (0.01, 0.05, 0.1 lots)
3. Stop loss/take profit placement with 1-3 pip variance
4. Occasional "missed" opportunities (5% of signals ignored)
5. Random micro-delays in order modifications (100-500ms)
6. Weekend behavior variance (some accounts trade Sunday open, others don't)

## Tasks / Subtasks

- [ ] Task 1: Implement entry timing variance system (AC: 1)
  - [ ] Create signal delay calculation engine
  - [ ] Implement personality-based timing preferences
  - [ ] Build market volatility impact on delays
  - [ ] Add session-based timing adjustments
  - [ ] Create timing variance logging and monitoring
  
- [ ] Task 2: Build position size rounding engine (AC: 2)
  - [ ] Create human-friendly lot size calculator
  - [ ] Implement personality-based rounding preferences
  - [ ] Build account size impact on lot sizes
  - [ ] Add psychological level preferences (0.01, 0.05, 0.1)
  - [ ] Create size variance documentation system
  
- [ ] Task 3: Develop stop/take profit variance system (AC: 3)
  - [ ] Implement 1-3 pip placement variance
  - [ ] Create personality-based level preferences
  - [ ] Build market condition impact on placement
  - [ ] Add round number avoidance logic
  - [ ] Create variance tracking and analysis
  
- [ ] Task 4: Create signal skip mechanism (AC: 4)
  - [ ] Implement 5% signal ignoring system
  - [ ] Create personality-based skip reasons
  - [ ] Build market condition skip triggers
  - [ ] Add skip decision logging with rationale
  - [ ] Create skip pattern analysis tools
  
- [ ] Task 5: Build micro-delay system (AC: 5)
  - [ ] Implement 100-500ms random delays
  - [ ] Create personality-based delay patterns
  - [ ] Build execution context awareness
  - [ ] Add network simulation delays
  - [ ] Create delay performance monitoring
  
- [ ] Task 6: Implement weekend behavior variance (AC: 6)
  - [ ] Create Sunday trading preference profiles
  - [ ] Build weekend gap trading logic
  - [ ] Implement personality-based weekend behavior
  - [ ] Add regional market preference handling
  - [ ] Create weekend behavior analytics

## Dev Notes

### Architecture Context
This story implements the execution variance engine that introduces natural human-like imperfections into trade execution. This system ensures that the perfectly precise algorithmic signals are transformed into realistic human trading behavior with natural timing variations, sizing preferences, and occasional mistakes.

### Execution Pipeline Integration
[Source: docs/architecture/execution-engine.md]
The variance engine sits between signal generation and order placement:
```
Signal Generation → Personality Filter → Variance Engine → Order Execution
```

The variance engine must:
- Receive clean algorithmic signals
- Apply personality-driven modifications
- Introduce realistic execution delays
- Log all variance decisions for analysis

### Data Models
[Source: docs/architecture/data-models.md]
```typescript
interface ExecutionVariance {
  signalId: string;
  accountId: string;
  personalityId: string;
  
  // Original Signal
  originalSignal: {
    symbol: string;
    direction: 'long' | 'short';
    size: number;
    entryPrice: number;
    stopLoss: number;
    takeProfit: number;
    confidence: number;
    generatedAt: Date;
  };
  
  // Applied Variances
  variances: {
    entryTiming: {
      originalDelay: 0;
      appliedDelay: number;        // 1-30 seconds
      reason: string;              // "personality_hesitation", "market_volatility"
    };
    positionSize: {
      originalSize: number;
      adjustedSize: number;        // Rounded to human-friendly
      roundingMethod: 'up' | 'down' | 'nearest';
      reason: string;
    };
    stopLoss: {
      originalLevel: number;
      adjustedLevel: number;       // +/- 1-3 pips
      variance: number;
      reason: string;
    };
    takeProfit: {
      originalLevel: number;
      adjustedLevel: number;       // +/- 1-3 pips
      variance: number;
      reason: string;
    };
    execution: {
      microDelay: number;          // 100-500ms
      skipSignal: boolean;         // 5% chance
      skipReason?: string;
    };
  };
  
  // Execution Results
  execution: {
    actualEntryTime: Date;
    actualEntryPrice: number;
    slippage: number;
    executionLatency: number;
    success: boolean;
    errorReason?: string;
  };
  
  appliedAt: Date;
}

interface VarianceProfile {
  personalityId: string;
  
  // Timing Preferences
  timing: {
    baseDelay: number;             // Base delay in seconds
    volatilityMultiplier: number;  // Higher vol = more delay
    sessionPreferences: Record<string, number>; // Session-specific delays
    marketOpenBehavior: 'eager' | 'cautious' | 'avoiding';
  };
  
  // Sizing Preferences
  sizing: {
    preferredIncrements: number[]; // [0.01, 0.05, 0.1, 0.25, 0.5, 1.0]
    roundingBias: 'up' | 'down' | 'nearest' | 'psychological';
    maxDeviation: number;          // Max deviation from suggested size
    accountSizeImpact: number;     // How account size affects sizing
  };
  
  // Level Placement
  levels: {
    stopLossVariance: {
      min: number;                 // Min pips variance
      max: number;                 // Max pips variance
      bias: 'conservative' | 'aggressive' | 'neutral';
    };
    takeProfitVariance: {
      min: number;
      max: number;
      bias: 'greedy' | 'cautious' | 'neutral';
    };
    roundNumberAvoidance: number;  // 0-1, how much to avoid round numbers
  };
  
  // Skip Behavior
  skipping: {
    baseSkipRate: number;          // Base 5% skip rate
    skipTriggers: string[];        // Conditions that increase skip rate
    skipReasons: string[];         // Pool of human-like reasons
    consecutiveSkipLimit: number;  // Max consecutive skips
  };
  
  // Weekend Behavior
  weekend: {
    tradeSundayOpen: boolean;
    sundayRiskReduction: number;   // Risk reduction factor
    gapTradingPreference: 'avoid' | 'fade' | 'follow';
    weekendNewsReaction: 'ignore' | 'cautious' | 'opportunistic';
  };
}

interface VarianceMetrics {
  accountId: string;
  period: {
    start: Date;
    end: Date;
  };
  
  // Timing Metrics
  timing: {
    averageDelay: number;
    delayStandardDeviation: number;
    delayDistribution: Record<string, number>; // Histogram
  };
  
  // Sizing Metrics
  sizing: {
    roundingAccuracy: number;      // How often sizes are rounded
    sizeDeviationAverage: number;
    preferredSizeUsage: Record<string, number>;
  };
  
  // Skip Metrics
  skipping: {
    actualSkipRate: number;
    skipReasonDistribution: Record<string, number>;
    consecutiveSkipPatterns: number[];
  };
  
  // Execution Quality
  execution: {
    averageSlippage: number;
    executionSuccessRate: number;
    latencyDistribution: Record<string, number>;
  };
}
```

### Variance Algorithms
[Source: docs/architecture/variance-engine.md]
```python
class ExecutionVarianceEngine:
    def apply_variance(self, signal: Signal, personality: TradingPersonality) -> ExecutionVariance:
        variance = ExecutionVariance()
        
        # 1. Entry Timing Variance (1-30 seconds)
        base_delay = personality.get_base_delay()
        volatility_factor = self.get_market_volatility_factor(signal.symbol)
        session_factor = self.get_session_factor(signal.timestamp)
        
        delay = base_delay * volatility_factor * session_factor
        delay = clamp(delay, 1, 30)  # Ensure 1-30 second range
        
        # 2. Position Size Rounding
        human_size = self.round_to_human_friendly(
            signal.size, 
            personality.sizing_preferences
        )
        
        # 3. Level Placement Variance
        sl_variance = random_normal(0, personality.sl_variance_std)
        tp_variance = random_normal(0, personality.tp_variance_std)
        
        # 4. Skip Decision (5% base rate)
        skip_probability = self.calculate_skip_probability(signal, personality)
        skip_signal = random.random() < skip_probability
        
        # 5. Micro-delays
        micro_delay = random_uniform(100, 500)  # milliseconds
        
        return variance
    
    def round_to_human_friendly(self, size: float, preferences: SizingPreferences) -> float:
        # Preferred increments: 0.01, 0.05, 0.1, 0.25, 0.5, 1.0
        increments = preferences.preferred_increments
        
        # Find closest increment
        closest_increment = min(increments, key=lambda x: abs(size % x))
        
        # Round to that increment based on personality bias
        if preferences.rounding_bias == 'up':
            return math.ceil(size / closest_increment) * closest_increment
        elif preferences.rounding_bias == 'down':
            return math.floor(size / closest_increment) * closest_increment
        else:  # nearest
            return round(size / closest_increment) * closest_increment
```

### Component Architecture
[Source: docs/architecture/backend-architecture.md]
```
agents/
├── variance-engine/
│   ├── VarianceEngine.py           # Main variance application
│   ├── TimingVariance.py          # Entry timing calculations
│   ├── SizingVariance.py          # Position size rounding
│   ├── LevelVariance.py           # Stop/TP placement
│   ├── SkipEngine.py              # Signal skipping logic
│   ├── WeekendBehavior.py         # Weekend-specific behavior
│   └── VarianceMetrics.py         # Performance tracking
```

### Integration Points
[Source: docs/architecture/system-integration.md]
- **Signal Generation Agent**: Receives clean signals
- **Personality Engine**: Gets personality preferences
- **Execution Engine**: Sends modified signals for execution
- **Audit System**: Logs all variance decisions
- **Monitoring Dashboard**: Displays variance metrics

### Timing Variance Logic
[Source: docs/architecture/behavioral-modeling.md]
```python
def calculate_entry_delay(signal, personality, market_conditions):
    # Base delay from personality (1-10 seconds typically)
    base_delay = personality.timing.base_delay
    
    # Market volatility impact (higher volatility = more hesitation)
    volatility_multiplier = min(2.0, market_conditions.atr_ratio * 1.5)
    
    # Session-based adjustments
    session_multiplier = personality.get_session_confidence(market_conditions.session)
    
    # News event proximity (more delay near news)
    news_multiplier = calculate_news_proximity_factor(signal.timestamp)
    
    # Apply personality consistency (some traders always fast, others always slow)
    consistency_factor = personality.modifiers.consistency_level
    
    total_delay = base_delay * volatility_multiplier * session_multiplier * news_multiplier
    
    # Add random component but keep within personality bounds
    random_component = random_normal(0, base_delay * 0.3)
    final_delay = clamp(total_delay + random_component, 1, 30)
    
    return final_delay
```

### Weekend Behavior Modeling
[Source: docs/architecture/weekend-behavior.md]
- **Sunday Trading**: 30% of personalities trade Sunday open, 70% wait for Monday
- **Gap Strategies**: Different approaches to weekend gaps (fade/follow/avoid)
- **Risk Adjustment**: Reduced position sizes on Sunday for some personalities
- **Regional Preferences**: Asian personalities more likely to trade Sunday

### Performance Monitoring
[Source: docs/architecture/monitoring.md]
- **Variance Distribution**: Ensure variance appears natural, not systematic
- **Execution Quality**: Monitor slippage and latency impact
- **Pattern Detection**: Alert if variance patterns become detectable
- **Performance Impact**: Track how variance affects overall returns

### Testing Standards
- Test variance distribution across 10,000 signals
- Verify human-like sizing distribution
- Test weekend behavior variation
- Validate skip rate accuracy (5% ± 1%)
- Test micro-delay performance impact

## Testing

### Test Requirements
[Source: docs/architecture/testing-strategy.md]
- **Unit Tests**: Individual variance algorithms, timing calculations, sizing logic
- **Integration Tests**: End-to-end signal modification, execution pipeline
- **Statistical Tests**: Variance distribution analysis, pattern detection
- **Performance Tests**: Latency impact of variance calculations
- **Behavioral Tests**: Human-likeness validation
- **Location**: `agents/variance-engine/__tests__/`

### Specific Testing Focus
- Entry timing variance distribution (should appear natural)
- Position sizing human-friendliness validation
- Stop/take profit variance accuracy
- Skip mechanism randomness and reasoning
- Weekend behavior consistency with personalities

### Statistical Validation
- Chi-square tests for timing variance distribution
- Analysis of variance (ANOVA) for sizing patterns
- Kolmogorov-Smirnov tests for natural behavior simulation
- Entropy analysis for randomness quality
- Pattern detection algorithms for systematic behavior

### Mock Data Requirements
- Signal datasets with various market conditions
- Personality profiles with different variance preferences
- Historical execution data for comparison
- Weekend trading scenarios and market conditions

### Performance Benchmarks
- Variance calculation: < 5ms per signal
- Memory usage: < 10MB for variance engine
- Throughput: > 1000 signals/second with variance applied
- Latency impact: < 50ms additional execution delay

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-12 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation.*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here after implementation.*
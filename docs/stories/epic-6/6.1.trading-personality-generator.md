# Story 6.1: Trading Personality Generator

## Status
Ready

## Story
**As a** stealth system,  
**I want** unique trading personalities per account,  
**so that** each account appears as a different human trader.

## Acceptance Criteria
1. Personality profiles with preferred trading times, pairs, and risk levels
2. Personality traits: aggressive/conservative, morning/evening trader
3. Favorite pairs assignment (2-3 primary, 2-3 secondary per account)
4. Risk appetite variance (0.5%-2% per trade) per personality
5. Personality evolution over time simulating skill improvement
6. Personality configuration interface in dashboard

## Tasks / Subtasks

- [ ] Task 1: Create personality profile data model (AC: 1)
  - [ ] Define personality attributes structure
  - [ ] Implement trading time preference system
  - [ ] Create currency pair preference modeling
  - [ ] Build risk level profiling system
  - [ ] Add personality validation and constraints
  
- [ ] Task 2: Implement personality trait system (AC: 2)
  - [ ] Create aggressive vs conservative trait modeling
  - [ ] Build morning vs evening trader preferences
  - [ ] Implement risk tolerance scaling factors
  - [ ] Add session-based activity modifiers
  - [ ] Create trait interaction algorithms
  
- [ ] Task 3: Build currency pair preference engine (AC: 3)
  - [ ] Create pair categorization system (majors, minors, exotics)
  - [ ] Implement primary pair selection (2-3 pairs)
  - [ ] Build secondary pair assignment (2-3 pairs)
  - [ ] Add pair preference strength weighting
  - [ ] Create pair rotation logic over time
  
- [ ] Task 4: Develop risk appetite variance system (AC: 4)
  - [ ] Implement dynamic position sizing (0.5%-2% range)
  - [ ] Create personality-based risk scaling
  - [ ] Build risk appetite evolution over time
  - [ ] Add account balance impact on risk levels
  - [ ] Create risk adjustment triggers
  
- [ ] Task 5: Build personality evolution engine (AC: 5)
  - [ ] Create skill improvement simulation algorithms
  - [ ] Implement gradual risk tolerance changes
  - [ ] Build experience-based preference shifts
  - [ ] Add seasonal personality adjustments
  - [ ] Create milestone-based evolution triggers
  
- [ ] Task 6: Create dashboard configuration interface (AC: 6)
  - [ ] Build personality editor components
  - [ ] Create personality preview and testing tools
  - [ ] Implement bulk personality generation
  - [ ] Add personality template system
  - [ ] Create personality analytics and monitoring

## Dev Notes

### Architecture Context
This story creates the foundation for the anti-detection system by generating unique trading personalities for each account. Each personality acts as a behavioral template that influences all trading decisions, making accounts appear as distinct human traders with individual preferences and characteristics.

### Core Anti-Detection Strategy
[Source: docs/architecture/anti-detection-architecture.md]
The personality system is central to avoiding prop firm AI detection by:
- Creating behavioral diversity across accounts
- Establishing consistent but evolving trading patterns
- Masking the underlying algorithmic nature of decisions
- Providing plausible explanations for trading choices

### Data Models
[Source: docs/architecture/data-models.md]
```typescript
interface TradingPersonality {
  id: string;
  accountId: string;
  profileName: string;
  
  // Core Traits
  traits: {
    riskTolerance: 'conservative' | 'moderate' | 'aggressive';
    tradingStyle: 'scalper' | 'daytrader' | 'swingtrader';
    timePreference: 'morning' | 'afternoon' | 'evening' | 'night';
    sessionFocus: 'asian' | 'london' | 'newyork' | 'mixed';
    experienceLevel: 'novice' | 'intermediate' | 'advanced';
  };
  
  // Trading Preferences
  preferences: {
    primaryPairs: string[];        // 2-3 favorite pairs
    secondaryPairs: string[];      // 2-3 secondary pairs
    avoidedPairs: string[];        // Pairs this personality dislikes
    preferredTimeWindows: TimeWindow[];
    riskPerTrade: {
      min: number;                 // 0.5%
      max: number;                 // 2.0%
      preferred: number;           // Sweet spot
    };
    holdingPeriods: {
      min: number;                 // Minutes
      max: number;                 // Minutes
      average: number;
    };
  };
  
  // Evolution Parameters
  evolution: {
    skillGrowthRate: number;       // How fast they "learn"
    riskEvolutionRate: number;     // Risk tolerance changes
    preferenceStability: number;   // How much preferences change
    experiencePoints: number;      // Accumulated experience
    lastEvolution: Date;
  };
  
  // Behavioral Modifiers
  modifiers: {
    impatienceLevel: number;       // 0-1, affects entry timing
    greedFactor: number;           // 0-1, affects take profit levels
    fearFactor: number;            // 0-1, affects stop loss placement
    consistencyLevel: number;      // 0-1, how much they vary from plan
    newsReactionLevel: number;     // 0-1, how much news affects them
  };
  
  createdAt: Date;
  lastActive: Date;
  version: string;
}

interface TimeWindow {
  start: string;                   // "09:00" in account timezone
  end: string;                     // "17:00" in account timezone
  timezone: string;                // Account's preferred timezone
  daysOfWeek: number[];            // 0-6, days active
  activity: number;                // 0-1, how active during this window
}

interface PersonalityTemplate {
  id: string;
  name: string;
  description: string;
  baseTraits: Partial<TradingPersonality>;
  varianceRanges: PersonalityVarianceRanges;
}

interface PersonalityEvolutionEvent {
  personalityId: string;
  eventType: 'skill_improvement' | 'risk_adjustment' | 'preference_shift';
  previousValue: any;
  newValue: any;
  trigger: string;
  timestamp: Date;
}
```

### Component Architecture
[Source: docs/architecture/frontend-architecture.md]
```
components/
├── personality/
│   ├── PersonalityManager.tsx       # Main management interface
│   ├── PersonalityEditor.tsx        # Individual personality editor
│   ├── TraitSelector.tsx           # Trait selection components
│   ├── PairPreferenceManager.tsx   # Currency pair preferences
│   ├── RiskProfileEditor.tsx       # Risk appetite configuration
│   ├── EvolutionSettings.tsx       # Evolution parameter settings
│   ├── PersonalityPreview.tsx      # Preview personality behavior
│   └── PersonalityTemplates.tsx    # Template management
```

### Personality Generation Algorithm
[Source: docs/architecture/personality-engine.md]
```python
def generate_personality(account_id: str, template: Optional[PersonalityTemplate] = None) -> TradingPersonality:
    # Base trait selection with realistic distributions
    traits = select_realistic_traits(template)
    
    # Generate correlated preferences based on traits
    preferences = generate_correlated_preferences(traits)
    
    # Add realistic variance to avoid perfect correlations
    preferences = add_personality_variance(preferences, variance_factor=0.15)
    
    # Set evolution parameters based on experience level
    evolution = generate_evolution_parameters(traits.experienceLevel)
    
    # Create behavioral modifiers with personality consistency
    modifiers = generate_behavioral_modifiers(traits, preferences)
    
    return TradingPersonality(...)
```

### API Integration
[Source: docs/architecture/rest-api-spec.md]
- `GET /api/personalities` - List all personalities
- `POST /api/personalities` - Create new personality
- `GET /api/personalities/{id}` - Get personality details
- `PUT /api/personalities/{id}` - Update personality
- `DELETE /api/personalities/{id}` - Delete personality
- `POST /api/personalities/generate` - Auto-generate personality
- `POST /api/personalities/{id}/evolve` - Trigger evolution
- `GET /api/personalities/templates` - Get personality templates

### Database Schema
[Source: docs/architecture/database-schema.md]
```sql
CREATE TABLE trading_personalities (
    id UUID PRIMARY KEY,
    account_id UUID NOT NULL REFERENCES accounts(id),
    profile_name VARCHAR(100) NOT NULL,
    traits JSONB NOT NULL,
    preferences JSONB NOT NULL,
    evolution JSONB NOT NULL,
    modifiers JSONB NOT NULL,
    created_at TIMESTAMP DEFAULT NOW(),
    updated_at TIMESTAMP DEFAULT NOW(),
    version INTEGER DEFAULT 1
);

CREATE TABLE personality_evolution_log (
    id UUID PRIMARY KEY,
    personality_id UUID REFERENCES trading_personalities(id),
    event_type VARCHAR(50) NOT NULL,
    previous_value JSONB,
    new_value JSONB,
    trigger VARCHAR(100),
    created_at TIMESTAMP DEFAULT NOW()
);

CREATE INDEX idx_personalities_account ON trading_personalities(account_id);
CREATE INDEX idx_evolution_log_personality ON personality_evolution_log(personality_id);
```

### Realistic Personality Distribution
[Source: docs/architecture/behavioral-modeling.md]
- **Risk Tolerance**: 30% conservative, 50% moderate, 20% aggressive
- **Trading Style**: 25% scalper, 45% day trader, 30% swing trader
- **Time Preferences**: Distributed based on global trading sessions
- **Experience Levels**: 40% intermediate, 35% novice, 25% advanced
- **Session Focus**: Weighted by account location and time zone

### Evolution Mechanics
[Source: docs/architecture/personality-evolution.md]
- **Skill Improvement**: Gradual increase in win rate and risk tolerance
- **Risk Evolution**: Conservative traders become more aggressive over time
- **Preference Shifts**: Occasional changes in preferred pairs or timing
- **Experience Points**: Accumulated through successful trades and time
- **Evolution Triggers**: Performance milestones, time-based, market events

### Security Considerations
[Source: docs/architecture/security.md]
- **Personality Fingerprinting**: Ensure personalities are not too unique to be tracked
- **Template Mixing**: Avoid using identical templates across accounts
- **Evolution Logging**: Audit trail for all personality changes
- **Rollback Capability**: Ability to revert personality changes if detected
- **Anonymization**: No personally identifiable information in personalities

### Testing Standards
- Test personality generation diversity (1000 generated personalities should be unique)
- Verify trait correlation logic and realistic distributions
- Test evolution mechanics over simulated time periods
- Validate personality influence on trading decisions
- Test dashboard interface for personality management

## Testing

### Test Requirements
[Source: docs/architecture/testing-strategy.md]
- **Unit Tests**: Personality generation algorithms, trait correlations, evolution mechanics
- **Integration Tests**: Database operations, API endpoints, personality application
- **Behavioral Tests**: Personality influence on trading decisions
- **Statistical Tests**: Personality distribution analysis, uniqueness validation
- **UI Tests**: Dashboard interface functionality
- **Location**: `agents/personality-engine/__tests__/`

### Specific Testing Focus
- Personality uniqueness across large datasets (1000+ personalities)
- Trait correlation accuracy and realism
- Evolution algorithm correctness over time
- API integration and data persistence
- Dashboard interface usability and functionality

### Statistical Validation
- Chi-square tests for trait distribution realism
- Correlation analysis between personality traits
- Diversity metrics for generated personality sets
- Evolution path analysis over time
- Behavioral consistency validation

### Mock Data Requirements
- Personality templates for different trader types
- Historical account data for evolution testing
- Reference personality datasets for validation
- Trading session data for time preference testing

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-12 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation.*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here after implementation.*
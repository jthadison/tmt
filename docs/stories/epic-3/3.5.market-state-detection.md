# Story 3.5: Market State Detection Agent

## Status
Done

## Story
**As a** risk management system,
**I want** to understand current market conditions,
**so that** I can adjust trading behavior appropriately.

## Acceptance Criteria
1. Market regime classification: trending, ranging, volatile, quiet
2. Session detection: Asian, London, New York with overlap periods
3. Economic event monitoring with 30-minute pre/post event windows
4. Correlation analysis between forex pairs and indices
5. Volatility measurement using ATR and historical volatility
6. Market state changes trigger strategy parameter adjustments

## Tasks / Subtasks
- [x] Task 1: Implement market regime classification (AC: 1)
  - [x] Create trending market detection using ADX and moving average slopes
  - [x] Implement ranging market identification using volatility and price oscillation
  - [x] Build volatile market detection using volatility spikes and gap analysis
  - [x] Create quiet market classification using volume and price movement thresholds
  - [x] Add regime transition detection with confirmation criteria
  - [x] Implement regime confidence scoring and validation
- [x] Task 2: Build trading session detection system (AC: 2)
  - [x] Implement Asian session detection (21:00-06:00 GMT)
  - [x] Create London session detection (07:00-16:00 GMT)
  - [x] Build New York session detection (12:00-21:00 GMT)
  - [x] Add session overlap period identification and characteristics
  - [x] Implement timezone handling and daylight saving time adjustments
  - [x] Create session-specific volatility and behavior profiles
- [x] Task 3: Integrate economic calendar monitoring (AC: 3)
  - [x] Connect to Trading Economics API for economic events
  - [x] Filter high-impact events affecting traded currencies
  - [x] Implement 30-minute pre/post event trading restrictions
  - [x] Create event impact severity classification
  - [x] Add automatic event monitoring and alert system
  - [x] Implement historical event impact analysis
- [x] Task 4: Build correlation analysis engine (AC: 4)
  - [x] Calculate rolling correlation between major forex pairs
  - [x] Implement forex-index correlation tracking (USD pairs vs DXY)
  - [x] Create correlation breakdowns and divergence detection
  - [x] Add correlation regime classification (normal/abnormal)
  - [x] Implement correlation-based risk assessment
  - [x] Build correlation network visualization and analysis
- [x] Task 5: Implement volatility measurement system (AC: 5)
  - [x] Calculate Average True Range (ATR) across multiple periods
  - [x] Implement historical volatility using standard deviation
  - [x] Create volatility percentile ranking system
  - [x] Add volatility expansion and contraction detection
  - [x] Implement volatility regime classification
  - [x] Create volatility forecasting models
- [x] Task 6: Build strategy parameter adjustment system (AC: 6)
  - [x] Define parameter adjustment rules based on market state
  - [x] Implement dynamic stop loss adjustment for volatility
  - [x] Create position sizing modifications for different regimes
  - [x] Add signal generation frequency adjustments
  - [x] Implement timeout and holding period modifications
  - [x] Create parameter change notification and logging system

## Dev Notes

### Architecture Context
The Market State Detection Agent provides crucial market context intelligence that enhances all other system components. By understanding current market conditions, the system can adapt its trading behavior to optimize performance across different market regimes. This agent integrates with the Signal Generation System, Risk Management, and Circuit Breaker systems to provide comprehensive market awareness. [Source: architecture/components.md#market-analysis-agent]

### Previous Story Context
Stories 3.1-3.4 established the complete Market Intelligence pipeline with data integration, Wyckoff detection, volume analysis, and signal generation. The Market State Detection Agent completes this intelligence layer by providing the contextual awareness needed to adapt trading strategies to current market conditions.

### Market Regime Classification Implementation
Advanced regime detection using multiple indicators:
```python
class MarketRegimeClassifier:
    def __init__(self):
        self.adx_threshold = 25  # ADX > 25 indicates trend
        self.volatility_percentiles = {'low': 20, 'high': 80}
        self.range_detection_period = 50
        
    def classify_market_regime(self, price_data, volume_data):
        """
        Classify market regime using multiple factors
        """
        current_time = price_data[-1]['timestamp']
        
        # Calculate indicators
        adx = self.calculate_adx(price_data)
        volatility = self.calculate_historical_volatility(price_data)
        volatility_percentile = self.get_volatility_percentile(volatility)
        range_factor = self.calculate_range_factor(price_data)
        volume_profile = self.analyze_volume_profile(volume_data)
        
        # Classification logic
        regime = self.determine_regime(
            adx, volatility_percentile, range_factor, volume_profile
        )
        
        confidence = self.calculate_regime_confidence(
            adx, volatility_percentile, range_factor
        )
        
        return {
            'regime': regime,
            'confidence': confidence,
            'timestamp': current_time,
            'indicators': {
                'adx': adx,
                'volatility_percentile': volatility_percentile,
                'range_factor': range_factor,
                'volume_profile': volume_profile
            },
            'characteristics': self.get_regime_characteristics(regime)
        }
    
    def determine_regime(self, adx, vol_percentile, range_factor, volume_profile):
        """
        Determine market regime based on indicator combination
        """
        if adx > self.adx_threshold and range_factor < 0.3:
            if vol_percentile > self.volatility_percentiles['high']:
                return 'volatile_trending'
            else:
                return 'trending'
                
        elif range_factor > 0.7:
            if vol_percentile > self.volatility_percentiles['high']:
                return 'volatile_ranging'
            else:
                return 'ranging'
                
        elif vol_percentile < self.volatility_percentiles['low']:
            return 'quiet'
            
        else:
            return 'transitional'
```

### Trading Session Detection System
Comprehensive session analysis with overlap handling:
```python
class TradingSessionDetector:
    def __init__(self):
        self.sessions = {
            'asian': {'start': 21, 'end': 6, 'peak': [23, 2]},
            'london': {'start': 7, 'end': 16, 'peak': [8, 12]}, 
            'new_york': {'start': 12, 'end': 21, 'peak': [13, 17]}
        }
        self.overlaps = {
            'london_tokyo': {'start': 7, 'end': 9},
            'london_ny': {'start': 12, 'end': 16},
            'asian_sydney': {'start': 21, 'end': 6}
        }
        
    def detect_current_session(self, timestamp):
        """
        Detect current trading session with overlap analysis
        """
        utc_hour = timestamp.astimezone(timezone.utc).hour
        
        # Check for overlaps first (higher activity)
        for overlap_name, overlap_time in self.overlaps.items():
            if self.is_time_in_range(utc_hour, overlap_time['start'], overlap_time['end']):
                return {
                    'primary_session': overlap_name,
                    'type': 'overlap',
                    'characteristics': self.get_overlap_characteristics(overlap_name),
                    'expected_volatility': 'high',
                    'typical_volume': 'above_average'
                }
        
        # Check individual sessions
        for session_name, session_time in self.sessions.items():
            if self.is_time_in_range(utc_hour, session_time['start'], session_time['end']):
                return {
                    'primary_session': session_name,
                    'type': 'single',
                    'characteristics': self.get_session_characteristics(session_name),
                    'peak_hours': session_time['peak'],
                    'is_peak': utc_hour in range(session_time['peak'][0], session_time['peak'][1]+1)
                }
        
        return {
            'primary_session': 'off_hours',
            'type': 'quiet',
            'characteristics': {'volatility': 'low', 'volume': 'below_average'}
        }
    
    def is_time_in_range(self, hour, start, end):
        """Handle overnight sessions (e.g., Asian session 21:00-06:00)"""
        if start <= end:
            return start <= hour <= end
        else:  # Overnight session
            return hour >= start or hour <= end
```

### Economic Calendar Integration
Real-time economic event monitoring:
```python
class EconomicEventMonitor:
    def __init__(self):
        self.api_client = TradingEconomicsAPI()
        self.event_buffer_minutes = 30
        self.high_impact_indicators = [
            'Non Farm Payrolls', 'FOMC Rate Decision', 'GDP',
            'Inflation Rate', 'Unemployment Rate', 'Retail Sales'
        ]
        
    async def get_upcoming_events(self, hours_ahead=24):
        """
        Get upcoming high-impact economic events
        """
        end_time = datetime.utcnow() + timedelta(hours=hours_ahead)
        events = await self.api_client.get_calendar_events(
            start_date=datetime.utcnow().date(),
            end_date=end_time.date()
        )
        
        # Filter for high-impact events affecting traded currencies
        high_impact_events = []
        for event in events:
            if (event['importance'] == 'high' or 
                event['event'] in self.high_impact_indicators):
                
                # Calculate trading restriction windows
                restriction_start = event['date'] - timedelta(minutes=self.event_buffer_minutes)
                restriction_end = event['date'] + timedelta(minutes=self.event_buffer_minutes)
                
                high_impact_events.append({
                    'event': event['event'],
                    'country': event['country'],
                    'currency': self.get_currency_from_country(event['country']),
                    'date': event['date'],
                    'importance': event['importance'],
                    'previous': event.get('previous'),
                    'forecast': event.get('forecast'),
                    'restriction_window': {
                        'start': restriction_start,
                        'end': restriction_end
                    },
                    'affected_pairs': self.get_affected_pairs(event['country'])
                })
        
        return high_impact_events
    
    def is_trading_restricted(self, symbol, current_time):
        """
        Check if trading is restricted due to upcoming economic events
        """
        upcoming_events = self.get_cached_events()
        
        for event in upcoming_events:
            if symbol in event['affected_pairs']:
                if (event['restriction_window']['start'] <= current_time <= 
                    event['restriction_window']['end']):
                    return {
                        'restricted': True,
                        'reason': f"{event['event']} - {event['country']}",
                        'restriction_ends': event['restriction_window']['end'],
                        'event_impact': event['importance']
                    }
        
        return {'restricted': False}
```

### Correlation Analysis Engine
Advanced correlation tracking and analysis:
```python
class CorrelationAnalyzer:
    def __init__(self):
        self.major_pairs = ['EURUSD', 'GBPUSD', 'USDJPY', 'USDCHF', 'AUDUSD', 'USDCAD', 'NZDUSD']
        self.indices = ['DXY', 'US30', 'NAS100', 'SPX500']
        self.correlation_periods = [20, 50, 200]  # Different timeframes
        
    def calculate_correlation_matrix(self, price_data_dict, period=50):
        """
        Calculate correlation matrix for all tracked instruments
        """
        # Prepare price series
        instruments = list(price_data_dict.keys())
        price_changes = {}
        
        for instrument in instruments:
            prices = [candle['close'] for candle in price_data_dict[instrument]]
            price_changes[instrument] = np.diff(np.log(prices))[-period:]
        
        # Calculate correlation matrix
        correlation_matrix = {}
        for i, inst1 in enumerate(instruments):
            correlation_matrix[inst1] = {}
            for j, inst2 in enumerate(instruments):
                if i <= j:  # Avoid duplicate calculations
                    if inst1 == inst2:
                        corr = 1.0
                    else:
                        corr = np.corrcoef(
                            price_changes[inst1], 
                            price_changes[inst2]
                        )[0, 1]
                    
                    correlation_matrix[inst1][inst2] = corr
                    if inst1 != inst2:
                        if inst2 not in correlation_matrix:
                            correlation_matrix[inst2] = {}
                        correlation_matrix[inst2][inst1] = corr
        
        return correlation_matrix
    
    def detect_correlation_anomalies(self, current_correlations, historical_avg):
        """
        Detect unusual correlation patterns that might indicate market stress
        """
        anomalies = []
        
        for pair1 in current_correlations:
            for pair2 in current_correlations[pair1]:
                if pair1 < pair2:  # Avoid duplicates
                    current_corr = current_correlations[pair1][pair2]
                    historical_corr = historical_avg.get(pair1, {}).get(pair2, 0)
                    
                    deviation = abs(current_corr - historical_corr)
                    
                    if deviation > 0.3:  # Significant deviation threshold
                        anomalies.append({
                            'pair1': pair1,
                            'pair2': pair2,
                            'current_correlation': current_corr,
                            'historical_correlation': historical_corr,
                            'deviation': deviation,
                            'severity': 'high' if deviation > 0.5 else 'moderate'
                        })
        
        return anomalies
```

### Volatility Measurement System
Comprehensive volatility analysis:
```python
class VolatilityAnalyzer:
    def __init__(self):
        self.atr_periods = [14, 21, 50]
        self.historical_vol_period = 252  # 1 year of daily data
        
    def calculate_comprehensive_volatility(self, price_data):
        """
        Calculate multiple volatility measures
        """
        # Average True Range
        atr_values = {}
        for period in self.atr_periods:
            atr_values[f'atr_{period}'] = self.calculate_atr(price_data, period)
        
        # Historical Volatility (annualized)
        returns = self.calculate_returns(price_data)
        historical_vol = np.std(returns) * np.sqrt(252) * 100  # Annualized %
        
        # Volatility percentile ranking
        vol_percentile = self.calculate_volatility_percentile(historical_vol, price_data)
        
        # Volatility regime classification
        vol_regime = self.classify_volatility_regime(vol_percentile)
        
        return {
            'atr_values': atr_values,
            'historical_volatility': historical_vol,
            'volatility_percentile': vol_percentile,
            'volatility_regime': vol_regime,
            'expansion_detected': self.detect_volatility_expansion(returns),
            'contraction_detected': self.detect_volatility_contraction(returns)
        }
    
    def classify_volatility_regime(self, percentile):
        """
        Classify current volatility regime
        """
        if percentile < 20:
            return 'very_low'
        elif percentile < 40:
            return 'low'
        elif percentile < 60:
            return 'normal'
        elif percentile < 80:
            return 'high'
        else:
            return 'very_high'
```

### Strategy Parameter Adjustment System
Dynamic parameter modification based on market state:
```python
class ParameterAdjustmentEngine:
    def __init__(self):
        self.base_parameters = {
            'stop_loss_atr_multiple': 2.0,
            'position_size_percentage': 2.0,
            'signal_confidence_threshold': 75.0,
            'max_signals_per_week': 3,
            'holding_time_multiplier': 1.0
        }
        
    def adjust_parameters_for_market_state(self, market_state, base_params=None):
        """
        Adjust trading parameters based on current market state
        """
        params = base_params or self.base_parameters.copy()
        adjustments = {}
        
        # Regime-based adjustments
        if market_state['regime'] == 'trending':
            adjustments.update({
                'stop_loss_atr_multiple': params['stop_loss_atr_multiple'] * 1.5,  # Wider stops
                'holding_time_multiplier': params['holding_time_multiplier'] * 2.0,  # Longer holds
                'signal_confidence_threshold': params['signal_confidence_threshold'] - 5  # Accept more signals
            })
            
        elif market_state['regime'] == 'ranging':
            adjustments.update({
                'stop_loss_atr_multiple': params['stop_loss_atr_multiple'] * 0.8,  # Tighter stops
                'holding_time_multiplier': params['holding_time_multiplier'] * 0.5,  # Shorter holds
                'signal_confidence_threshold': params['signal_confidence_threshold'] + 5  # Higher bar
            })
            
        elif market_state['regime'] == 'volatile':
            adjustments.update({
                'position_size_percentage': params['position_size_percentage'] * 0.6,  # Smaller size
                'stop_loss_atr_multiple': params['stop_loss_atr_multiple'] * 2.0,  # Wider stops
                'max_signals_per_week': max(1, params['max_signals_per_week'] - 1)  # Fewer signals
            })
            
        elif market_state['regime'] == 'quiet':
            adjustments.update({
                'signal_confidence_threshold': params['signal_confidence_threshold'] + 10,  # Much higher bar
                'max_signals_per_week': max(1, params['max_signals_per_week'] - 1)  # Fewer signals
            })
        
        # Volatility-based adjustments
        if market_state.get('volatility_regime') == 'very_high':
            adjustments['position_size_percentage'] = adjustments.get('position_size_percentage', params['position_size_percentage']) * 0.5
        
        # Session-based adjustments
        if market_state.get('session', {}).get('type') == 'overlap':
            adjustments['stop_loss_atr_multiple'] = adjustments.get('stop_loss_atr_multiple', params['stop_loss_atr_multiple']) * 1.2
        
        return adjustments
```

### Database Schema for Market State
Comprehensive market state storage:
```sql
CREATE TABLE market_states (
    state_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    symbol VARCHAR(20) NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    regime VARCHAR(20) NOT NULL, -- trending, ranging, volatile, quiet
    regime_confidence DECIMAL(5,2),
    session VARCHAR(20) NOT NULL,
    volatility_regime VARCHAR(20),
    volatility_percentile DECIMAL(5,2),
    correlation_anomalies JSONB,
    economic_events JSONB,
    indicators JSONB NOT NULL,
    parameter_adjustments JSONB,
    
    INDEX idx_market_states_symbol_time (symbol, timestamp),
    INDEX idx_market_states_regime (regime)
);

CREATE TABLE economic_events (
    event_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    event_name VARCHAR(200) NOT NULL,
    country VARCHAR(50) NOT NULL,
    currency VARCHAR(3) NOT NULL,
    event_time TIMESTAMP WITH TIME ZONE NOT NULL,
    importance VARCHAR(10) NOT NULL,
    previous_value DECIMAL(10,2),
    forecast_value DECIMAL(10,2),
    actual_value DECIMAL(10,2),
    restriction_start TIMESTAMP WITH TIME ZONE,
    restriction_end TIMESTAMP WITH TIME ZONE,
    affected_pairs JSONB,
    
    INDEX idx_events_time (event_time),
    INDEX idx_events_currency (currency)
);
```

### Integration Events
Market state change events:
```json
{
  "event_type": "market.state.changed",
  "symbol": "EURUSD",
  "previous_state": {
    "regime": "ranging",
    "confidence": 78.5
  },
  "new_state": {
    "regime": "trending",
    "confidence": 85.2,
    "session": "london_ny_overlap",
    "volatility_regime": "high"
  },
  "parameter_changes": {
    "stop_loss_atr_multiple": 3.0,
    "holding_time_multiplier": 2.0
  },
  "timestamp": "2024-01-01T10:00:00Z",
  "correlation_id": "uuid"
}
```

### Testing Requirements
- **Regime classification tests:** Validate classification accuracy against historical data
- **Session detection tests:** Test timezone handling and overlap detection
- **Economic event tests:** Verify restriction window calculations
- **Correlation tests:** Validate correlation calculations and anomaly detection
- **Volatility tests:** Test volatility measurements against market data
- **Parameter adjustment tests:** Verify parameter changes are applied correctly
- **Integration tests:** Test market state integration with signal generation

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-06 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record

### Agent Model Used
Claude Opus 4.1 (claude-opus-4-1-20250805)

### Debug Log References
- Market state detection implementation: 2025-08-09
- Session detector implementation: 2025-08-09
- Economic event monitor integration: 2025-08-09
- Correlation analyzer development: 2025-08-09
- Volatility analyzer implementation: 2025-08-09
- Parameter adjustment engine creation: 2025-08-09

### Completion Notes List
- Successfully implemented comprehensive market state detection system with 6 core components
- Market regime classifier supports trending/ranging/volatile/quiet state detection using ADX, MA slopes, volatility analysis
- Trading session detector handles all major sessions (Asian/London/NY) with overlap detection and timezone management
- Economic event monitor integrates with external APIs for high-impact event filtering and trading restrictions
- Correlation analyzer provides anomaly detection and breakdown analysis for forex pairs and indices
- Volatility analyzer includes ATR calculation, historical volatility, GARCH forecasting, and cluster detection
- Parameter adjustment engine dynamically modifies trading parameters based on market conditions
- Main market state agent coordinates all components and publishes state change events
- Comprehensive test suite covers all major components with unit tests
- All acceptance criteria successfully met with robust error handling and logging

### File List
- `agents/market-analysis/app/market_state_detector.py` - Core market regime classification logic
- `agents/market-analysis/app/session_detector.py` - Trading session detection and analysis
- `agents/market-analysis/app/economic_event_monitor.py` - Economic calendar integration and event monitoring
- `agents/market-analysis/app/correlation_analyzer.py` - Correlation analysis and anomaly detection
- `agents/market-analysis/app/volatility_analyzer.py` - Comprehensive volatility measurement and forecasting
- `agents/market-analysis/app/parameter_adjustment_engine.py` - Dynamic parameter adjustment system
- `agents/market-analysis/app/market_state_agent.py` - Main integration agent coordinating all components
- `agents/market-analysis/tests/test_market_state_detector.py` - Comprehensive test suite covering all components

## QA Results
*Results from QA Agent review will be populated here*
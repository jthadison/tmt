# Story 3.4: Signal Generation and Scoring System

## Status
Draft

## Story
**As a** trading system,
**I want** high-confidence trade signals with entry/exit parameters,
**so that** I can execute profitable trades systematically.

## Acceptance Criteria
1. Signal generation only when confidence score >75%
2. Entry price, stop loss, and take profit levels calculated for each signal
3. Risk-reward ratio minimum 1:2 enforced for all signals
4. Maximum 3 signals per week per account to avoid overtrading
5. Signal metadata includes pattern type, confidence, expected hold time
6. Signal performance tracking with win rate and profit factor metrics

## Tasks / Subtasks
- [ ] Task 1: Build signal generation engine (AC: 1)
  - [ ] Integrate Wyckoff pattern detection with confidence threshold filtering
  - [ ] Combine volume analysis confirmation for signal validation
  - [ ] Implement multi-timeframe alignment requirement for signal generation
  - [ ] Create signal strength amplification based on confluence factors
  - [ ] Add market state context filtering (avoid signals in choppy conditions)
  - [ ] Implement signal cooling-off periods to prevent overtrading
- [ ] Task 2: Calculate precise entry/exit parameters (AC: 2)
  - [ ] Implement dynamic entry price calculation based on pattern type
  - [ ] Calculate stop loss levels using pattern invalidation points
  - [ ] Determine take profit targets using measured moves and resistance levels
  - [ ] Add multiple take profit levels for position scaling
  - [ ] Implement trailing stop mechanisms for trend following
  - [ ] Create entry confirmation requirements (volume, momentum)
- [ ] Task 3: Enforce risk-reward ratio requirements (AC: 3)
  - [ ] Calculate risk-reward ratio for each signal before generation
  - [ ] Filter out signals with R:R ratio <1:2
  - [ ] Implement dynamic R:R adjustment based on market volatility
  - [ ] Add position sizing optimization based on R:R ratio
  - [ ] Create R:R ratio improvement algorithms (better entries/exits)
  - [ ] Track actual vs predicted R:R performance
- [ ] Task 4: Implement signal frequency controls (AC: 4)
  - [ ] Create per-account signal counting system
  - [ ] Implement weekly signal limits (max 3 per account)
  - [ ] Add signal quality ranking when multiple signals compete
  - [ ] Create signal substitution logic (replace lower quality signals)
  - [ ] Implement account-specific signal preferences
  - [ ] Add manual override capability for exceptional opportunities
- [ ] Task 5: Create comprehensive signal metadata (AC: 5)
  - [ ] Include pattern type (accumulation, spring, distribution, etc.)
  - [ ] Add confidence score breakdown by component
  - [ ] Calculate expected hold time based on pattern and timeframe
  - [ ] Include market context data (session, volatility, trend)
  - [ ] Add signal lineage (which patterns/factors contributed)
  - [ ] Create signal uniqueness identifiers for tracking
- [ ] Task 6: Build signal performance tracking system (AC: 6)
  - [ ] Track signal outcomes (win/loss/neutral/cancelled)
  - [ ] Calculate win rate by signal type and confidence level
  - [ ] Compute profit factor and Sharpe ratio by signal category
  - [ ] Track actual vs predicted hold times and targets hit
  - [ ] Create signal attribution analysis (which factors predict success)
  - [ ] Implement feedback loop for algorithm improvement

## Dev Notes

### Architecture Context
The Signal Generation and Scoring System is the culmination of the Market Analysis Agent's intelligence, combining Wyckoff pattern detection and volume analysis to produce high-confidence trading signals. The system must maintain the balance between signal quality and frequency to achieve the PRD target of 70%+ profitable months while avoiding overtrading. [Source: architecture/components.md#market-analysis-agent]

### Previous Story Context
Stories 3.1-3.3 established the Market Data Pipeline, Wyckoff Pattern Detection Engine, and Volume Price Analysis Integration. The Signal Generation System integrates all these components to produce actionable trading signals with precise entry/exit parameters and comprehensive metadata.

### Signal Generation Architecture
Comprehensive signal generation workflow:
```python
class SignalGenerator:
    def __init__(self):
        self.confidence_threshold = 75.0
        self.min_risk_reward = 2.0
        self.weekly_signal_limit = 3
        self.pattern_detector = WyckoffPatternDetector()
        self.volume_analyzer = VolumeAnalyzer()
        self.market_state_detector = MarketStateDetector()
        
    async def generate_signal(self, symbol, timeframe):
        """
        Main signal generation pipeline with quality gates
        """
        # Step 1: Detect patterns with confidence scoring
        patterns = await self.pattern_detector.detect_patterns(symbol, timeframe)
        if not patterns:
            return None
            
        # Step 2: Enhance with volume analysis
        volume_analysis = await self.volume_analyzer.analyze(symbol, timeframe)
        enhanced_patterns = self.enhance_patterns_with_volume(patterns, volume_analysis)
        
        # Step 3: Filter by confidence threshold
        high_confidence_patterns = [
            p for p in enhanced_patterns if p['confidence'] >= self.confidence_threshold
        ]
        
        if not high_confidence_patterns:
            return None
            
        # Step 4: Check market state suitability
        market_state = await self.market_state_detector.get_current_state(symbol)
        if not self.is_market_state_suitable(market_state):
            return None
            
        # Step 5: Generate signal parameters
        signal = await self.create_signal_from_pattern(
            high_confidence_patterns[0], symbol, timeframe
        )
        
        # Step 6: Validate risk-reward ratio
        if signal['risk_reward_ratio'] < self.min_risk_reward:
            return None
            
        # Step 7: Check frequency limits
        if not await self.check_signal_frequency_limit(symbol):
            return None
            
        return signal
```

### Entry/Exit Parameter Calculation
Precise parameter calculation based on pattern types:
```python
class SignalParameterCalculator:
    def calculate_signal_parameters(self, pattern, market_data):
        """
        Calculate entry, stop loss, and take profit levels
        """
        if pattern['type'] == 'accumulation':
            return self.calculate_accumulation_parameters(pattern, market_data)
        elif pattern['type'] == 'spring':
            return self.calculate_spring_parameters(pattern, market_data)
        elif pattern['type'] == 'distribution':
            return self.calculate_distribution_parameters(pattern, market_data)
        else:
            return self.calculate_generic_parameters(pattern, market_data)
    
    def calculate_spring_parameters(self, spring_pattern, market_data):
        """
        Calculate parameters for spring pattern signals
        """
        # Entry: Above spring high with confirmation
        entry_price = spring_pattern['spring_high'] + (0.0005 * spring_pattern['atr'])
        
        # Stop loss: Below spring low
        stop_loss = spring_pattern['spring_low'] - (0.0005 * spring_pattern['atr'])
        
        # Take profit: Measured move from accumulation range
        accumulation_range = spring_pattern['accumulation_high'] - spring_pattern['accumulation_low']
        take_profit = spring_pattern['accumulation_high'] + accumulation_range
        
        # Calculate risk-reward
        risk = entry_price - stop_loss
        reward = take_profit - entry_price
        risk_reward_ratio = reward / risk if risk > 0 else 0
        
        return {
            'entry_price': entry_price,
            'stop_loss': stop_loss,
            'take_profit_1': take_profit,
            'take_profit_2': take_profit + (accumulation_range * 0.5),  # Extension target
            'risk_reward_ratio': risk_reward_ratio,
            'expected_hold_time_hours': self.estimate_hold_time(spring_pattern),
            'entry_confirmation': {
                'volume_spike_required': True,
                'momentum_threshold': 0.3,
                'timeout_minutes': 60
            }
        }
```

### Risk-Reward Optimization
Advanced R:R calculation and optimization:
```python
class RiskRewardOptimizer:
    def optimize_risk_reward(self, signal, market_context):
        """
        Optimize signal parameters to improve risk-reward ratio
        """
        current_rr = signal['risk_reward_ratio']
        if current_rr >= self.min_risk_reward:
            return signal
            
        # Try to improve R:R by adjusting parameters
        optimized_signal = signal.copy()
        
        # Strategy 1: Tighten entry (closer to support/resistance)
        improved_entry = self.optimize_entry_price(signal, market_context)
        if improved_entry:
            optimized_signal['entry_price'] = improved_entry
            
        # Strategy 2: Extend targets based on higher timeframe levels
        extended_targets = self.find_extended_targets(signal, market_context)
        if extended_targets:
            optimized_signal['take_profit_1'] = extended_targets[0]
            optimized_signal['take_profit_2'] = extended_targets[1]
            
        # Strategy 3: Adjust stop based on volatility
        volatility_adjusted_stop = self.adjust_stop_for_volatility(signal, market_context)
        if volatility_adjusted_stop:
            optimized_signal['stop_loss'] = volatility_adjusted_stop
            
        # Recalculate R:R ratio
        new_risk = abs(optimized_signal['entry_price'] - optimized_signal['stop_loss'])
        new_reward = abs(optimized_signal['take_profit_1'] - optimized_signal['entry_price'])
        optimized_signal['risk_reward_ratio'] = new_reward / new_risk if new_risk > 0 else 0
        
        return optimized_signal if optimized_signal['risk_reward_ratio'] >= self.min_risk_reward else None
```

### Signal Frequency Management
System to prevent overtrading:
```python
class SignalFrequencyManager:
    def __init__(self):
        self.weekly_limits = {}  # account_id -> limit
        self.signal_history = {}  # account_id -> [signals]
        
    async def check_signal_allowance(self, account_id, new_signal):
        """
        Check if account can accept new signal based on frequency limits
        """
        current_week_signals = self.get_current_week_signals(account_id)
        
        if len(current_week_signals) >= self.get_weekly_limit(account_id):
            # Check if new signal is higher quality than existing ones
            return await self.evaluate_signal_substitution(
                account_id, new_signal, current_week_signals
            )
        
        return True
        
    async def evaluate_signal_substitution(self, account_id, new_signal, existing_signals):
        """
        Determine if new signal should replace an existing lower-quality signal
        """
        # Sort existing signals by quality score
        sorted_existing = sorted(
            existing_signals, 
            key=lambda s: self.calculate_signal_quality_score(s)
        )
        
        lowest_quality = sorted_existing[0]
        new_quality = self.calculate_signal_quality_score(new_signal)
        
        if new_quality > self.calculate_signal_quality_score(lowest_quality):
            # Cancel lowest quality signal and accept new one
            await self.cancel_signal(lowest_quality['signal_id'])
            return True
            
        return False
        
    def calculate_signal_quality_score(self, signal):
        """
        Calculate comprehensive signal quality score
        """
        return (
            signal['confidence'] * 0.4 +
            min(signal['risk_reward_ratio'], 5) * 20 * 0.3 +  # Cap at 5:1 R:R
            signal['pattern_strength'] * 0.2 +
            signal['volume_confirmation'] * 0.1
        )
```

### Signal Metadata Structure
Comprehensive signal data model:
```python
@dataclass
class TradingSignal:
    signal_id: str
    symbol: str
    timeframe: str
    signal_type: str  # 'long' or 'short'
    pattern_type: str  # 'accumulation', 'spring', 'distribution', etc.
    confidence: float
    confidence_breakdown: dict
    
    # Price levels
    entry_price: Decimal
    stop_loss: Decimal
    take_profit_1: Decimal
    take_profit_2: Optional[Decimal]
    risk_reward_ratio: float
    
    # Timing
    generated_at: datetime
    valid_until: datetime
    expected_hold_time_hours: int
    
    # Market context
    market_state: str
    session: str  # 'asian', 'london', 'new_york'
    volatility_regime: str  # 'low', 'normal', 'high'
    
    # Pattern details
    pattern_data: dict
    volume_analysis: dict
    key_levels: dict
    
    # Entry confirmation requirements
    entry_confirmation: dict
    
    # Attribution
    contributing_factors: List[str]
    model_version: str
    
    def to_dict(self):
        return {
            'signal_id': self.signal_id,
            'symbol': self.symbol,
            'timeframe': self.timeframe,
            'signal_type': self.signal_type,
            'pattern_type': self.pattern_type,
            'confidence': self.confidence,
            'confidence_breakdown': self.confidence_breakdown,
            'entry_price': float(self.entry_price),
            'stop_loss': float(self.stop_loss),
            'take_profit_1': float(self.take_profit_1),
            'take_profit_2': float(self.take_profit_2) if self.take_profit_2 else None,
            'risk_reward_ratio': self.risk_reward_ratio,
            'generated_at': self.generated_at.isoformat(),
            'expected_hold_time_hours': self.expected_hold_time_hours,
            'market_context': {
                'state': self.market_state,
                'session': self.session,
                'volatility': self.volatility_regime
            }
        }
```

### Performance Tracking System
Comprehensive signal performance analysis:
```python
class SignalPerformanceTracker:
    def track_signal_outcome(self, signal_id, outcome_data):
        """
        Track the outcome of a signal for performance analysis
        """
        outcome = {
            'signal_id': signal_id,
            'outcome_type': outcome_data['type'],  # 'win', 'loss', 'neutral', 'cancelled'
            'entry_filled': outcome_data.get('entry_filled', False),
            'exit_price': outcome_data.get('exit_price'),
            'exit_time': outcome_data.get('exit_time'),
            'pnl_points': outcome_data.get('pnl_points'),
            'hold_duration_hours': outcome_data.get('hold_duration_hours'),
            'target_hit': outcome_data.get('target_hit'),  # 'tp1', 'tp2', 'stop', 'manual'
            'max_favorable_excursion': outcome_data.get('mfe'),
            'max_adverse_excursion': outcome_data.get('mae')
        }
        
        self.store_outcome(outcome)
        self.update_performance_metrics(signal_id, outcome)
        
    def calculate_performance_metrics(self, filter_criteria=None):
        """
        Calculate comprehensive performance metrics
        """
        signals = self.get_signals(filter_criteria)
        
        if not signals:
            return None
            
        outcomes = [s for s in signals if s.get('outcome')]
        wins = [s for s in outcomes if s['outcome']['outcome_type'] == 'win']
        losses = [s for s in outcomes if s['outcome']['outcome_type'] == 'loss']
        
        total_signals = len(outcomes)
        win_rate = len(wins) / total_signals if total_signals > 0 else 0
        
        gross_profit = sum(w['outcome']['pnl_points'] for w in wins)
        gross_loss = abs(sum(l['outcome']['pnl_points'] for l in losses))
        profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')
        
        avg_win = gross_profit / len(wins) if wins else 0
        avg_loss = gross_loss / len(losses) if losses else 0
        
        return {
            'total_signals': total_signals,
            'win_rate': win_rate * 100,
            'profit_factor': profit_factor,
            'gross_profit': gross_profit,
            'gross_loss': gross_loss,
            'average_win': avg_win,
            'average_loss': avg_loss,
            'largest_win': max((w['outcome']['pnl_points'] for w in wins), default=0),
            'largest_loss': min((l['outcome']['pnl_points'] for l in losses), default=0),
            'avg_hold_time_hours': np.mean([s['outcome']['hold_duration_hours'] for s in outcomes if s['outcome'].get('hold_duration_hours')])
        }
```

### Database Schema for Signals
Comprehensive signal storage:
```sql
CREATE TABLE trading_signals (
    signal_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    symbol VARCHAR(20) NOT NULL,
    timeframe VARCHAR(10) NOT NULL,
    signal_type VARCHAR(10) NOT NULL CHECK (signal_type IN ('long', 'short')),
    pattern_type VARCHAR(50) NOT NULL,
    confidence_score DECIMAL(5,2) NOT NULL CHECK (confidence_score BETWEEN 0.00 AND 100.00),
    entry_price DECIMAL(10,5) NOT NULL,
    stop_loss DECIMAL(10,5) NOT NULL,
    take_profit DECIMAL(10,5) NOT NULL,
    risk_reward_ratio DECIMAL(4,2) NOT NULL,
    wyckoff_phase VARCHAR(50),
    pattern_type VARCHAR(100),
    volume_confirmation BOOLEAN NOT NULL DEFAULT false,
    generated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    valid_until TIMESTAMP WITH TIME ZONE,
    expected_hold_time_hours INTEGER,
    market_context JSONB NOT NULL DEFAULT '{}'::jsonb,
    pattern_data JSONB NOT NULL DEFAULT '{}'::jsonb,
    
    INDEX idx_signals_symbol_time (symbol, generated_at),
    INDEX idx_signals_confidence (confidence_score),
    INDEX idx_signals_pattern (pattern_type)
);

CREATE TABLE signal_outcomes (
    outcome_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    signal_id UUID NOT NULL REFERENCES trading_signals(signal_id),
    outcome_type VARCHAR(20) NOT NULL CHECK (outcome_type IN ('win', 'loss', 'neutral', 'cancelled')),
    entry_filled BOOLEAN DEFAULT false,
    exit_price DECIMAL(10,5),
    exit_time TIMESTAMP WITH TIME ZONE,
    pnl_points DECIMAL(8,2),
    hold_duration_hours INTEGER,
    target_hit VARCHAR(20), -- 'tp1', 'tp2', 'stop', 'manual'
    max_favorable_excursion DECIMAL(8,2),
    max_adverse_excursion DECIMAL(8,2),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    INDEX idx_outcomes_signal (signal_id),
    INDEX idx_outcomes_type (outcome_type)
);
```

### Integration Events
Kafka events for signal generation:
```json
{
  "event_type": "trading.signal.generated",
  "signal": {
    "signal_id": "uuid",
    "symbol": "EURUSD",
    "signal_type": "long",
    "pattern_type": "spring",
    "confidence": 87.5,
    "entry_price": 1.0950,
    "stop_loss": 1.0920,
    "take_profit_1": 1.1010,
    "risk_reward_ratio": 2.0,
    "expected_hold_time_hours": 18
  },
  "timestamp": "2024-01-01T10:00:00Z",
  "correlation_id": "uuid"
}
```

### Testing Requirements
- **Confidence threshold tests:** Verify only >75% confidence signals generated
- **R:R ratio tests:** Ensure all signals meet minimum 1:2 risk-reward
- **Frequency limit tests:** Validate weekly signal limits per account
- **Parameter accuracy tests:** Verify entry/exit calculation correctness
- **Performance tracking tests:** Validate outcome tracking accuracy
- **Integration tests:** Test with full Market Analysis Agent pipeline

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-06 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here*
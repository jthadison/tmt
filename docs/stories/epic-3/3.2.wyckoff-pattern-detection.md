# Story 3.2: Wyckoff Pattern Detection Engine

## Status
Draft

## Story
**As a** signal generation system,
**I want** to identify Wyckoff accumulation and distribution patterns,
**so that** I can trade with institutional order flow.

## Acceptance Criteria
1. Wyckoff phase identification: accumulation, markup, distribution, markdown
2. Spring and upthrust detection with volume confirmation
3. Support/resistance zone identification using volume profile
4. Pattern confidence scoring from 0-100% based on multiple criteria
5. Multi-timeframe validation (M5, M15, H1, H4) for pattern confirmation
6. Pattern performance tracking to validate detection accuracy

## Tasks / Subtasks
- [ ] Task 1: Implement Wyckoff phase detection algorithm (AC: 1)
  - [ ] Create accumulation phase detector using price structure analysis
  - [ ] Implement markup phase identification with trend strength metrics
  - [ ] Build distribution phase detector using volume divergence
  - [ ] Create markdown phase identification with declining price structure
  - [ ] Add phase transition detection with confirmation criteria
  - [ ] Implement phase state machine with validation rules
- [ ] Task 2: Build spring and upthrust detection (AC: 2)
  - [ ] Implement spring detection: price breaks support but recovers with volume
  - [ ] Create upthrust detection: price breaks resistance but fails with volume
  - [ ] Add volume confirmation analysis for spring/upthrust validity
  - [ ] Implement false breakout detection using volume profile
  - [ ] Create stop hunt identification algorithm
  - [ ] Add spring/upthrust strength scoring based on volume and recovery
- [ ] Task 3: Develop support/resistance zone detection (AC: 3)
  - [ ] Implement volume profile calculation for price levels
  - [ ] Create support/resistance zone identification using volume clusters
  - [ ] Add dynamic zone strength calculation based on volume and touches
  - [ ] Implement zone expansion/contraction tracking
  - [ ] Create zone break detection with volume confirmation
  - [ ] Add historical zone performance tracking
- [ ] Task 4: Create pattern confidence scoring system (AC: 4)
  - [ ] Design multi-factor confidence scoring algorithm (0-100%)
  - [ ] Implement volume confirmation weight (30% of score)
  - [ ] Add price structure quality weight (25% of score)
  - [ ] Include timeframe alignment weight (20% of score)
  - [ ] Add historical performance weight (15% of score)
  - [ ] Include market context weight (10% of score)
- [ ] Task 5: Implement multi-timeframe validation (AC: 5)
  - [ ] Create timeframe hierarchy: M5 → M15 → H1 → H4 → D1
  - [ ] Implement pattern alignment detection across timeframes
  - [ ] Add higher timeframe trend confirmation
  - [ ] Create timeframe divergence detection and warnings
  - [ ] Implement pattern strength amplification with timeframe alignment
  - [ ] Add conflicting timeframe pattern resolution logic
- [ ] Task 6: Build pattern performance tracking (AC: 6)
  - [ ] Create pattern tracking database schema
  - [ ] Implement signal outcome tracking (win/loss/neutral)
  - [ ] Calculate pattern success rates by type and confidence
  - [ ] Add pattern profitability analysis
  - [ ] Create pattern performance reporting dashboard
  - [ ] Implement feedback loop for algorithm improvement

## Dev Notes

### Architecture Context
The Wyckoff Pattern Detection Engine is the core intelligence component of the Market Analysis Agent, responsible for identifying institutional order flow patterns and generating high-confidence trading signals. The engine uses Wyckoff methodology to detect accumulation and distribution phases, providing the foundation for the system's 70%+ profitable months target. [Source: architecture/components.md#market-analysis-agent]

### Previous Story Context
Story 3.1 established the Market Data Integration Pipeline providing real-time and historical OHLCV data from OANDA and Polygon.io stored in TimescaleDB. The Wyckoff Detection Engine builds on this foundation, consuming normalized market data to perform pattern analysis across multiple timeframes.

### Wyckoff Methodology Implementation
The four-phase Wyckoff cycle implementation:

**Phase 1: Accumulation**
```python
class AccumulationDetector:
    def detect_accumulation(self, price_data, volume_data):
        """
        Detect accumulation phase characteristics:
        - Sideways price movement with declining volatility
        - Volume increasing on any upward moves
        - Support level holding with volume
        - Spring patterns (false breakdowns)
        """
        criteria = {
            'price_range_contraction': self.calculate_range_contraction(price_data),
            'volume_on_strength': self.analyze_volume_strength(price_data, volume_data),
            'support_holding': self.identify_support_levels(price_data, volume_data),
            'spring_patterns': self.detect_springs(price_data, volume_data)
        }
        
        confidence = self.calculate_phase_confidence(criteria)
        return {
            'phase': 'accumulation',
            'confidence': confidence,
            'criteria': criteria,
            'key_levels': self.extract_key_levels(price_data, volume_data)
        }
```

**Phase 2: Markup (Mark Up)**
```python
def detect_markup(self, price_data, volume_data):
    """
    Detect markup phase characteristics:
    - Strong upward price movement
    - Volume confirmation on breakouts
    - Higher highs and higher lows structure
    - Pullbacks to previous resistance as support
    """
    return {
        'phase': 'markup',
        'trend_strength': self.calculate_trend_strength(price_data),
        'breakout_volume': self.validate_breakout_volume(price_data, volume_data),
        'structure_quality': self.analyze_hh_hl_structure(price_data)
    }
```

### Spring and Upthrust Detection Algorithms
Advanced detection for key Wyckoff patterns:

**Spring Detection:**
```python
def detect_spring(self, price_data, volume_data, support_level):
    """
    Spring: Price breaks below support, immediately recovers with volume
    Indicates strong underlying demand and potential accumulation
    """
    # Find potential spring candidates
    candidates = []
    for i in range(len(price_data)):
        if (price_data[i]['low'] < support_level and 
            price_data[i]['close'] > support_level and
            volume_data[i] > self.average_volume):
            
            spring_strength = self.calculate_spring_strength(
                price_data[i], volume_data[i], support_level
            )
            candidates.append({
                'timestamp': price_data[i]['timestamp'],
                'strength': spring_strength,
                'recovery_volume': volume_data[i]
            })
    
    return self.filter_valid_springs(candidates)
```

### Volume Profile Support/Resistance Detection
Volume-based level identification:
```python
class VolumeProfileAnalyzer:
    def calculate_volume_profile(self, price_data, volume_data, bins=50):
        """
        Calculate volume profile to identify high-volume price levels
        These levels act as support/resistance zones
        """
        price_range = max(price_data['high']) - min(price_data['low'])
        bin_size = price_range / bins
        
        volume_by_price = {}
        for i, candle in enumerate(price_data):
            # Distribute volume across the price range for this candle
            price_levels = self.distribute_volume_across_range(
                candle['low'], candle['high'], volume_data[i], bin_size
            )
            
            for price_level, volume in price_levels.items():
                volume_by_price[price_level] = volume_by_price.get(price_level, 0) + volume
        
        # Identify high-volume nodes as support/resistance
        return self.identify_volume_nodes(volume_by_price)
```

### Pattern Confidence Scoring System
Multi-factor confidence calculation:
```python
def calculate_pattern_confidence(self, pattern_data):
    """
    Calculate confidence score (0-100%) based on weighted factors
    """
    factors = {
        'volume_confirmation': {
            'weight': 0.30,
            'score': self.score_volume_confirmation(pattern_data)
        },
        'price_structure': {
            'weight': 0.25,
            'score': self.score_price_structure_quality(pattern_data)
        },
        'timeframe_alignment': {
            'weight': 0.20,
            'score': self.score_timeframe_alignment(pattern_data)
        },
        'historical_performance': {
            'weight': 0.15,
            'score': self.score_historical_performance(pattern_data['type'])
        },
        'market_context': {
            'weight': 0.10,
            'score': self.score_market_context(pattern_data)
        }
    }
    
    total_score = sum(
        factor['weight'] * factor['score'] 
        for factor in factors.values()
    )
    
    return min(100, max(0, total_score))
```

### Multi-Timeframe Validation Architecture
Hierarchical timeframe analysis:
```python
class MultiTimeframeValidator:
    def __init__(self):
        self.timeframes = ['5m', '15m', '1h', '4h', '1d']
        self.hierarchy = {
            '5m': {'weight': 0.1, 'confirms': ['15m']},
            '15m': {'weight': 0.2, 'confirms': ['1h']},
            '1h': {'weight': 0.3, 'confirms': ['4h']},
            '4h': {'weight': 0.3, 'confirms': ['1d']},
            '1d': {'weight': 0.1, 'primary': True}
        }
    
    def validate_pattern_alignment(self, symbol, pattern_type):
        """
        Check if pattern is aligned across multiple timeframes
        Higher timeframe confirmation increases confidence
        """
        patterns = {}
        for tf in self.timeframes:
            patterns[tf] = self.detect_pattern_on_timeframe(
                symbol, pattern_type, tf
            )
        
        alignment_score = self.calculate_alignment_score(patterns)
        conflicts = self.identify_conflicts(patterns)
        
        return {
            'alignment_score': alignment_score,
            'conflicts': conflicts,
            'dominant_timeframe': self.identify_dominant_timeframe(patterns),
            'recommendation': self.generate_recommendation(patterns, conflicts)
        }
```

### Pattern Database Schema
Tracking schema for pattern performance:
```sql
CREATE TABLE wyckoff_patterns (
    pattern_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    symbol VARCHAR(20) NOT NULL,
    pattern_type VARCHAR(50) NOT NULL, -- accumulation, distribution, spring, upthrust
    phase VARCHAR(20) NOT NULL, -- accumulation, markup, distribution, markdown
    detection_time TIMESTAMP WITH TIME ZONE NOT NULL,
    confidence_score DECIMAL(5,2) NOT NULL,
    key_levels JSONB NOT NULL, -- support, resistance, entry, stop, target
    timeframe_data JSONB NOT NULL, -- multi-timeframe analysis
    volume_profile JSONB NOT NULL,
    
    INDEX idx_patterns_symbol_time (symbol, detection_time),
    INDEX idx_patterns_type_confidence (pattern_type, confidence_score)
);

CREATE TABLE pattern_outcomes (
    outcome_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    pattern_id UUID NOT NULL REFERENCES wyckoff_patterns(pattern_id),
    signal_id UUID REFERENCES trading_signals(signal_id),
    outcome_type VARCHAR(20) NOT NULL, -- win, loss, neutral, cancelled
    outcome_time TIMESTAMP WITH TIME ZONE,
    pnl_points DECIMAL(8,2),
    hold_duration_minutes INTEGER,
    notes TEXT,
    
    INDEX idx_outcomes_pattern (pattern_id),
    INDEX idx_outcomes_type (outcome_type)
);
```

### Integration with Market Analysis Agent
The Wyckoff engine integrates with the broader analysis system:
- **Data input:** Consumes normalized OHLCV from Market Data Pipeline
- **Event publishing:** Publishes `market.analysis.pattern_detected` to Kafka
- **API endpoints:** Exposes `/api/v1/analysis/wyckoff/detect` for pattern detection
- **WebSocket:** Streams real-time pattern updates to dashboard

Event format:
```json
{
  "event_type": "market.analysis.pattern_detected",
  "symbol": "EURUSD",
  "pattern": {
    "type": "accumulation",
    "phase": "accumulation",
    "confidence": 85.5,
    "timeframe": "1h",
    "key_levels": {
      "support": 1.0920,
      "resistance": 1.0980,
      "entry": 1.0950,
      "stop": 1.0910,
      "target": 1.1020
    },
    "detection_criteria": {
      "volume_confirmation": 90,
      "price_structure": 82,
      "timeframe_alignment": 88
    }
  },
  "timestamp": "2024-01-01T10:00:00Z",
  "correlation_id": "uuid"
}
```

### Performance Requirements
- **Detection latency:** <500ms for pattern analysis on new data
- **Confidence calculation:** <200ms for multi-factor scoring
- **Multi-timeframe validation:** <1 second for full hierarchy check
- **Memory efficiency:** Support 50+ symbols simultaneously
- **Storage efficiency:** Compress historical pattern data

### File Structure Integration
```
agents/market-analysis/app/
├── wyckoff/
│   ├── __init__.py
│   ├── phase_detector.py      # Four-phase cycle detection
│   ├── spring_upthrust.py     # Spring/upthrust detection
│   ├── volume_profile.py      # Volume-based S/R levels
│   ├── confidence_scorer.py   # Pattern confidence calculation
│   ├── timeframe_validator.py # Multi-timeframe analysis
│   └── performance_tracker.py # Pattern outcome tracking
├── utils/
│   ├── market_structure.py    # Price structure analysis
│   └── volume_analysis.py     # Volume analysis utilities
└── tests/
    ├── test_wyckoff.py        # Wyckoff pattern tests
    └── test_confidence.py     # Confidence scoring tests
```

### Testing Requirements
- **Pattern accuracy tests:** Validate detection against known historical patterns
- **Confidence calibration:** Ensure confidence scores correlate with actual outcomes
- **Performance tests:** Verify detection speed meets latency requirements
- **Multi-timeframe tests:** Test alignment logic across different timeframes
- **Volume analysis tests:** Validate volume profile calculations
- **Integration tests:** Test with live market data feeds

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-06 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here*
# Story 3.3: Volume Price Analysis Integration

## Status
Draft

## Story
**As a** market analyst,
**I want** volume-based insights combined with price action,
**so that** I can confirm the strength of detected patterns.

## Acceptance Criteria
1. Volume spike detection (>2x average) with price action context
2. Volume divergence identification (price up/volume down scenarios)
3. Accumulation/distribution line calculation and trend analysis
4. Volume-weighted average price (VWAP) bands for entry/exit zones
5. Smart money vs retail volume classification algorithm
6. Volume profile creation showing high-volume nodes as S/R levels

## Tasks / Subtasks
- [ ] Task 1: Implement volume spike detection system (AC: 1)
  - [ ] Calculate rolling average volume over configurable periods (20, 50, 200)
  - [ ] Detect volume spikes >2x, >3x, >5x average with severity levels
  - [ ] Analyze price context during volume spikes (breakout, breakdown, reversal)
  - [ ] Classify spike types: accumulation, distribution, breakout, panic
  - [ ] Add spike duration tracking and follow-through analysis
  - [ ] Create volume spike alerts with price action context
- [ ] Task 2: Build volume divergence detection (AC: 2)
  - [ ] Implement bullish divergence: price makes lower low, volume makes higher low
  - [ ] Create bearish divergence: price makes higher high, volume makes lower high
  - [ ] Add divergence strength scoring based on magnitude and duration
  - [ ] Implement hidden divergence detection for trend continuation
  - [ ] Create divergence validation using multiple timeframes
  - [ ] Add divergence outcome tracking for strategy validation
- [ ] Task 3: Develop Accumulation/Distribution Line (AC: 3)
  - [ ] Implement A/D line calculation: ((C-L)-(H-C))/(H-L) * Volume
  - [ ] Create cumulative A/D line for trend analysis
  - [ ] Add A/D line divergence detection with price action
  - [ ] Implement A/D oscillator for momentum analysis
  - [ ] Create A/D line trend strength indicators
  - [ ] Add A/D line breakout and breakdown signals
- [ ] Task 4: Create VWAP analysis system (AC: 4)
  - [ ] Calculate intraday VWAP using volume-weighted price averages
  - [ ] Implement VWAP standard deviation bands (1σ, 2σ, 3σ)
  - [ ] Create VWAP trend identification (above/below VWAP)
  - [ ] Add VWAP mean reversion signals at band extremes
  - [ ] Implement anchored VWAP for significant price levels
  - [ ] Create VWAP breakout and pullback signals
- [ ] Task 5: Build smart money vs retail classification (AC: 5)
  - [ ] Analyze volume patterns during different market hours
  - [ ] Classify institutional volume: large size, low spread impact
  - [ ] Identify retail volume: small size, high frequency, emotional
  - [ ] Create smart money accumulation detection algorithms
  - [ ] Implement retail distribution identification
  - [ ] Add institutional vs retail sentiment indicators
- [ ] Task 6: Create comprehensive volume profile system (AC: 6)
  - [ ] Build volume profile calculation for any time period
  - [ ] Identify Point of Control (POC) - highest volume price level
  - [ ] Calculate Value Area High (VAH) and Value Area Low (VAL)
  - [ ] Create volume profile-based support/resistance levels
  - [ ] Implement profile shape analysis (balanced, trending, double distribution)
  - [ ] Add volume profile breakout and rejection signals

## Dev Notes

### Architecture Context
The Volume Price Analysis Integration enhances the Market Analysis Agent's pattern detection capabilities by adding volume-based confirmation and analysis. Volume analysis is critical for validating Wyckoff patterns and distinguishing between genuine institutional moves and retail noise. The system integrates with the Wyckoff Pattern Detection Engine to provide comprehensive market structure analysis. [Source: architecture/components.md#market-analysis-agent]

### Previous Story Context  
Stories 3.1-3.2 established the Market Data Pipeline with volume data from OANDA/Polygon.io and the Wyckoff Pattern Detection Engine. The Volume Price Analysis system builds on this foundation by adding sophisticated volume analysis algorithms that enhance pattern detection confidence and signal quality.

### Volume Spike Detection Implementation
Advanced spike detection with price context:
```python
class VolumeSpikeDetector:
    def __init__(self):
        self.lookback_periods = [20, 50, 200]  # Short, medium, long-term averages
        self.spike_thresholds = {
            'moderate': 2.0,  # 2x average volume
            'strong': 3.0,    # 3x average volume
            'extreme': 5.0    # 5x average volume
        }
    
    def detect_volume_spikes(self, price_data, volume_data):
        """
        Detect volume spikes with price action context
        """
        spikes = []
        for i in range(max(self.lookback_periods), len(volume_data)):
            current_volume = volume_data[i]
            current_price = price_data[i]
            
            for period in self.lookback_periods:
                avg_volume = np.mean(volume_data[i-period:i])
                
                for severity, threshold in self.spike_thresholds.items():
                    if current_volume > avg_volume * threshold:
                        spike_context = self.analyze_price_context(
                            price_data, i, period
                        )
                        
                        spikes.append({
                            'timestamp': current_price['timestamp'],
                            'volume': current_volume,
                            'average_volume': avg_volume,
                            'spike_ratio': current_volume / avg_volume,
                            'severity': severity,
                            'price_context': spike_context,
                            'classification': self.classify_spike(spike_context)
                        })
        return spikes
    
    def classify_spike(self, context):
        """
        Classify volume spike type based on price action
        """
        if context['breakout_direction'] != 'none':
            return 'breakout'
        elif context['reversal_signal']:
            return 'reversal' 
        elif context['price_change'] > 0:
            return 'accumulation'
        else:
            return 'distribution'
```

### Volume Divergence Analysis
Implementation of bullish and bearish divergences:
```python
class VolumeDivergenceDetector:
    def detect_divergences(self, price_data, volume_data, lookback=50):
        """
        Detect volume divergences with price action
        """
        divergences = []
        
        # Find price peaks and troughs
        price_extremes = self.find_price_extremes(price_data)
        volume_extremes = self.find_volume_extremes(volume_data)
        
        for i in range(1, len(price_extremes)):
            current_extreme = price_extremes[i]
            previous_extreme = price_extremes[i-1]
            
            # Bullish divergence: lower price low, higher volume low
            if (current_extreme['type'] == 'trough' and
                previous_extreme['type'] == 'trough' and
                current_extreme['price'] < previous_extreme['price']):
                
                volume_comparison = self.compare_volume_at_extremes(
                    volume_data, current_extreme['index'], previous_extreme['index']
                )
                
                if volume_comparison > 0:  # Higher volume at lower price
                    divergences.append({
                        'type': 'bullish',
                        'strength': abs(volume_comparison),
                        'price_low_1': previous_extreme['price'],
                        'price_low_2': current_extreme['price'],
                        'confirmation': self.validate_divergence(price_data, i)
                    })
        
        return divergences
```

### Accumulation/Distribution Line Calculation
Implementation of the A/D line with trend analysis:
```python
class AccumulationDistributionLine:
    def calculate_ad_line(self, price_data, volume_data):
        """
        Calculate Accumulation/Distribution Line
        Formula: ((C-L)-(H-C))/(H-L) * Volume
        """
        ad_values = []
        cumulative_ad = 0
        
        for i, candle in enumerate(price_data):
            high = candle['high']
            low = candle['low']
            close = candle['close']
            volume = volume_data[i]
            
            if high != low:  # Avoid division by zero
                money_flow_multiplier = ((close - low) - (high - close)) / (high - low)
                money_flow_volume = money_flow_multiplier * volume
                cumulative_ad += money_flow_volume
            
            ad_values.append({
                'timestamp': candle['timestamp'],
                'ad_value': cumulative_ad,
                'money_flow_volume': money_flow_volume if high != low else 0,
                'multiplier': money_flow_multiplier if high != low else 0
            })
        
        return ad_values
    
    def analyze_ad_trend(self, ad_data, price_data):
        """
        Analyze A/D line trend and divergences
        """
        ad_trend = self.calculate_trend_slope(ad_data)
        price_trend = self.calculate_trend_slope(price_data)
        
        # Detect divergences
        divergence = None
        if ad_trend > 0 and price_trend < 0:
            divergence = 'bullish'  # A/D rising, price falling
        elif ad_trend < 0 and price_trend > 0:
            divergence = 'bearish'  # A/D falling, price rising
        
        return {
            'ad_trend': ad_trend,
            'price_trend': price_trend,
            'divergence': divergence,
            'trend_strength': abs(ad_trend)
        }
```

### VWAP Analysis System
Comprehensive VWAP implementation with bands:
```python
class VWAPAnalyzer:
    def calculate_vwap_with_bands(self, price_data, volume_data):
        """
        Calculate VWAP and standard deviation bands
        """
        cumulative_pv = 0  # Price * Volume
        cumulative_volume = 0
        cumulative_pv_squared = 0
        
        vwap_data = []
        
        for i, candle in enumerate(price_data):
            typical_price = (candle['high'] + candle['low'] + candle['close']) / 3
            volume = volume_data[i]
            
            cumulative_pv += typical_price * volume
            cumulative_volume += volume
            cumulative_pv_squared += (typical_price ** 2) * volume
            
            vwap = cumulative_pv / cumulative_volume if cumulative_volume > 0 else 0
            
            # Calculate standard deviation for bands
            variance = (cumulative_pv_squared / cumulative_volume) - (vwap ** 2)
            std_dev = np.sqrt(max(0, variance))
            
            vwap_data.append({
                'timestamp': candle['timestamp'],
                'vwap': vwap,
                'upper_band_1': vwap + std_dev,
                'upper_band_2': vwap + 2 * std_dev,
                'upper_band_3': vwap + 3 * std_dev,
                'lower_band_1': vwap - std_dev,
                'lower_band_2': vwap - 2 * std_dev,
                'lower_band_3': vwap - 3 * std_dev,
                'std_dev': std_dev
            })
        
        return vwap_data
    
    def generate_vwap_signals(self, price_data, vwap_data):
        """
        Generate trading signals based on VWAP analysis
        """
        signals = []
        for i, (candle, vwap) in enumerate(zip(price_data, vwap_data)):
            current_price = candle['close']
            
            # Mean reversion signals at band extremes
            if current_price >= vwap['upper_band_2']:
                signals.append({
                    'type': 'mean_reversion_short',
                    'strength': (current_price - vwap['upper_band_2']) / vwap['std_dev'],
                    'entry': current_price,
                    'target': vwap['vwap'],
                    'stop': vwap['upper_band_3']
                })
            
            elif current_price <= vwap['lower_band_2']:
                signals.append({
                    'type': 'mean_reversion_long',
                    'strength': (vwap['lower_band_2'] - current_price) / vwap['std_dev'],
                    'entry': current_price,
                    'target': vwap['vwap'],
                    'stop': vwap['lower_band_3']
                })
        
        return signals
```

### Smart Money vs Retail Classification
Algorithm to distinguish institutional from retail volume:
```python
class VolumeClassifier:
    def classify_volume_type(self, price_data, volume_data, time_data):
        """
        Classify volume as smart money vs retail based on multiple factors
        """
        classifications = []
        
        for i, (candle, volume, timestamp) in enumerate(
            zip(price_data, volume_data, time_data)
        ):
            factors = {
                'size_factor': self.analyze_volume_size(volume, i, volume_data),
                'timing_factor': self.analyze_volume_timing(timestamp),
                'price_impact': self.analyze_price_impact(candle, volume),
                'spread_factor': self.analyze_spread_during_volume(candle),
                'session_factor': self.analyze_session_context(timestamp)
            }
            
            smart_money_score = self.calculate_smart_money_score(factors)
            
            classifications.append({
                'timestamp': timestamp,
                'volume': volume,
                'classification': 'smart_money' if smart_money_score > 0.6 else 'retail',
                'confidence': smart_money_score,
                'factors': factors
            })
        
        return classifications
    
    def analyze_volume_timing(self, timestamp):
        """
        Analyze if volume occurs during institutional trading hours
        """
        hour = timestamp.hour
        
        # Institutional hours tend to be:
        # London: 08:00-12:00 GMT
        # New York: 13:00-17:00 GMT
        if 8 <= hour <= 12 or 13 <= hour <= 17:
            return 0.8  # High institutional probability
        elif 17 <= hour <= 20:  # Overlap period
            return 0.6
        else:
            return 0.2  # Low institutional probability
```

### Volume Profile System
Comprehensive volume profile implementation:
```python
class VolumeProfileBuilder:
    def build_volume_profile(self, price_data, volume_data, price_bins=100):
        """
        Build volume profile showing volume distribution by price level
        """
        price_min = min(candle['low'] for candle in price_data)
        price_max = max(candle['high'] for candle in price_data)
        price_range = price_max - price_min
        bin_size = price_range / price_bins
        
        volume_by_price = {}
        
        for candle, volume in zip(price_data, volume_data):
            # Distribute volume across the price range of this candle
            candle_range = candle['high'] - candle['low']
            if candle_range > 0:
                volume_per_tick = volume / (candle_range / bin_size)
                
                price_level = candle['low']
                while price_level <= candle['high']:
                    bin_index = int((price_level - price_min) / bin_size)
                    volume_by_price[bin_index] = volume_by_price.get(bin_index, 0) + volume_per_tick
                    price_level += bin_size
        
        # Calculate key levels
        poc_bin = max(volume_by_price.items(), key=lambda x: x[1])[0]
        poc_price = price_min + (poc_bin * bin_size)
        
        # Calculate Value Area (70% of volume)
        sorted_volume = sorted(volume_by_price.items(), key=lambda x: x[1], reverse=True)
        total_volume = sum(volume_by_price.values())
        value_area_volume = 0
        value_area_bins = []
        
        for bin_index, volume in sorted_volume:
            value_area_volume += volume
            value_area_bins.append(bin_index)
            if value_area_volume >= total_volume * 0.7:
                break
        
        vah = price_min + (max(value_area_bins) * bin_size)  # Value Area High
        val = price_min + (min(value_area_bins) * bin_size)  # Value Area Low
        
        return {
            'poc': poc_price,
            'vah': vah,
            'val': val,
            'volume_by_price': volume_by_price,
            'total_volume': total_volume,
            'profile_shape': self.classify_profile_shape(volume_by_price)
        }
```

### Integration with Wyckoff Detection
Volume analysis enhances pattern detection:
```python
def enhance_wyckoff_with_volume(wyckoff_pattern, volume_analysis):
    """
    Enhance Wyckoff pattern confidence with volume analysis
    """
    volume_confirmation = 0
    
    # Check for volume confirmation of key Wyckoff events
    if wyckoff_pattern['type'] == 'spring':
        # Springs should have volume spike on recovery
        if volume_analysis['spike_during_recovery']:
            volume_confirmation += 30
    
    elif wyckoff_pattern['type'] == 'accumulation':
        # Accumulation should show volume on strength, not weakness
        if volume_analysis['volume_on_strength'] > volume_analysis['volume_on_weakness']:
            volume_confirmation += 25
    
    # Add A/D line confirmation
    if volume_analysis['ad_line_trend'] == wyckoff_pattern['expected_ad_trend']:
        volume_confirmation += 20
    
    # Add VWAP confirmation
    if volume_analysis['vwap_trend'] == wyckoff_pattern['price_trend']:
        volume_confirmation += 15
    
    # Update pattern confidence
    enhanced_confidence = min(100, 
        wyckoff_pattern['confidence'] + volume_confirmation
    )
    
    return enhanced_confidence
```

### Database Schema Extension
Additional tables for volume analysis:
```sql
CREATE TABLE volume_analysis (
    analysis_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    symbol VARCHAR(20) NOT NULL,
    timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
    analysis_type VARCHAR(50) NOT NULL, -- spike, divergence, vwap, profile
    analysis_data JSONB NOT NULL,
    confidence_score DECIMAL(5,2),
    
    INDEX idx_volume_analysis_symbol_time (symbol, timestamp),
    INDEX idx_volume_analysis_type (analysis_type)
);

CREATE TABLE volume_profiles (
    profile_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    symbol VARCHAR(20) NOT NULL,
    period_start TIMESTAMP WITH TIME ZONE NOT NULL,
    period_end TIMESTAMP WITH TIME ZONE NOT NULL,
    poc_price DECIMAL(10,5) NOT NULL,
    vah_price DECIMAL(10,5) NOT NULL,
    val_price DECIMAL(10,5) NOT NULL,
    profile_shape VARCHAR(20), -- balanced, trending, double_distribution
    volume_data JSONB NOT NULL,
    
    INDEX idx_profiles_symbol_period (symbol, period_start)
);
```

### Testing Requirements
- **Volume spike accuracy:** Test detection against known historical spikes
- **Divergence validation:** Verify divergence detection with manual analysis
- **VWAP calculation:** Validate VWAP math against market data providers
- **A/D line accuracy:** Test A/D calculations against reference implementations
- **Profile generation:** Verify volume profile calculations
- **Performance tests:** Ensure analysis completes within latency requirements
- **Integration tests:** Test enhancement of Wyckoff pattern confidence

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-06 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here*
# Story 4.2: Dynamic Position Sizing Calculator

## Status
Draft

## Story
**As a** risk management system,
**I want** to calculate optimal position sizes,
**so that** risk is controlled while maximizing returns.

## Acceptance Criteria
1. Position size based on account balance, risk percentage, and stop loss distance
2. Volatility-adjusted sizing using ATR multiplier (reduce size in high volatility)
3. Account drawdown adjustment (reduce size by 50% after 3% drawdown)
4. Correlation-based size reduction when multiple correlated positions exist
5. Prop firm maximum position limits enforced per account
6. Position size variance between accounts for anti-detection

## Tasks / Subtasks
- [ ] Task 1: Build core position sizing engine (AC: 1)
  - [ ] Implement base position size calculation: (Account Balance * Risk %) / Stop Distance
  - [ ] Add support for different risk percentage models (fixed, adaptive, Kelly criterion)
  - [ ] Create position size validation against minimum trade sizes
  - [ ] Add maximum position size limits per instrument
  - [ ] Implement fractional lot size handling and rounding
  - [ ] Create position sizing calculation API endpoints
- [ ] Task 2: Implement volatility-based size adjustment (AC: 2)
  - [ ] Calculate Average True Range (ATR) for volatility measurement
  - [ ] Create volatility percentile ranking system (0-100%)
  - [ ] Implement size reduction formula based on volatility level
  - [ ] Add volatility regime classification (low, normal, high, extreme)
  - [ ] Create volatility-adjusted risk percentage scaling
  - [ ] Add historical volatility comparison for context
- [ ] Task 3: Build drawdown-based size reduction (AC: 3)
  - [ ] Track real-time account drawdown from peak equity
  - [ ] Implement progressive size reduction based on drawdown levels
  - [ ] Create drawdown recovery monitoring for size restoration
  - [ ] Add configurable drawdown thresholds per account
  - [ ] Implement emergency position sizing for extreme drawdown
  - [ ] Create drawdown-based trading halt triggers
- [ ] Task 4: Create correlation-based size adjustment (AC: 4)
  - [ ] Calculate real-time correlation between open positions
  - [ ] Implement size reduction when correlation exceeds threshold (>0.7)
  - [ ] Add portfolio heat calculation across all positions
  - [ ] Create correlation matrix for position interaction analysis
  - [ ] Implement dynamic correlation monitoring with alerts
  - [ ] Add correlation-based position limit enforcement
- [ ] Task 5: Enforce prop firm position limits (AC: 5)
  - [ ] Load prop firm specific limits from configuration
  - [ ] Implement maximum lot size per trade enforcement
  - [ ] Add maximum open positions per symbol limits
  - [ ] Create total exposure limits per account
  - [ ] Implement margin requirement checking
  - [ ] Add prop firm rule violation prevention
- [ ] Task 6: Build anti-detection size variance (AC: 6)
  - [ ] Generate position size variance (5-15%) between accounts
  - [ ] Create account-specific sizing personalities
  - [ ] Implement randomized sizing within risk limits
  - [ ] Add sizing pattern detection and avoidance
  - [ ] Create size variance tracking and analysis
  - [ ] Implement size variance optimization algorithms

## Dev Notes

### Architecture Context
The Dynamic Position Sizing Calculator is a core component of the Adaptive Risk Intelligence Agent (ARIA), responsible for calculating optimal position sizes that balance risk management, profitability, and compliance requirements. The system must integrate with multiple data sources and apply complex algorithms while maintaining the anti-detection variance needed for prop firm compliance. [Source: architecture/components.md#adaptive-risk-intelligence-agent-aria]

### Previous Epic Context
Epics 1-3 established infrastructure, compliance systems, and signal generation. Epic 4.1 created the MetaTrader Bridge for execution. The Position Sizing Calculator bridges the gap between signal generation and execution by determining the precise trade size that optimizes risk-adjusted returns.

### Core Position Sizing Formula
Base calculation with multiple adjustment factors:
```rust
pub struct PositionSizeCalculator {
    base_risk_percentage: f64,
    volatility_adjuster: VolatilityAdjuster,
    drawdown_adjuster: DrawdownAdjuster,
    correlation_adjuster: CorrelationAdjuster,
    prop_firm_limits: PropFirmLimitChecker,
    variance_engine: SizeVarianceEngine,
}

impl PositionSizeCalculator {
    pub async fn calculate_position_size(&self, request: PositionSizeRequest) -> Result<PositionSize> {
        // Step 1: Base position size calculation
        let base_size = self.calculate_base_size(&request).await?;
        
        // Step 2: Apply volatility adjustment
        let volatility_adjusted = self.volatility_adjuster
            .adjust_size(base_size, &request.symbol).await?;
        
        // Step 3: Apply drawdown reduction
        let drawdown_adjusted = self.drawdown_adjuster
            .adjust_size(volatility_adjusted, request.account_id).await?;
        
        // Step 4: Apply correlation reduction
        let correlation_adjusted = self.correlation_adjuster
            .adjust_size(drawdown_adjusted, &request).await?;
        
        // Step 5: Enforce prop firm limits
        let limit_enforced = self.prop_firm_limits
            .enforce_limits(correlation_adjusted, &request).await?;
        
        // Step 6: Apply anti-detection variance
        let final_size = self.variance_engine
            .apply_variance(limit_enforced, request.account_id).await?;
        
        Ok(PositionSize {
            base_size,
            adjusted_size: final_size,
            adjustments: SizeAdjustments {
                volatility_factor: volatility_adjusted / base_size,
                drawdown_factor: drawdown_adjusted / volatility_adjusted,
                correlation_factor: correlation_adjusted / drawdown_adjusted,
                limit_factor: limit_enforced / correlation_adjusted,
                variance_factor: final_size / limit_enforced,
            },
            reasoning: self.generate_sizing_reasoning(&request, final_size).await?,
        })
    }
    
    async fn calculate_base_size(&self, request: &PositionSizeRequest) -> Result<f64> {
        let account_balance = request.account_balance;
        let risk_percentage = self.get_risk_percentage(request.account_id).await?;
        let stop_distance_pips = request.stop_distance_pips;
        let pip_value = self.get_pip_value(&request.symbol, account_balance).await?;
        
        // Base formula: (Account Balance * Risk %) / (Stop Distance * Pip Value)
        let risk_amount = account_balance * risk_percentage / 100.0;
        let position_size = risk_amount / (stop_distance_pips * pip_value);
        
        Ok(position_size)
    }
}
```

### Volatility-Based Size Adjustment
Advanced volatility measurement and adjustment:
```rust
pub struct VolatilityAdjuster {
    atr_period: usize,
    volatility_database: Arc<VolatilityDatabase>,
    adjustment_curves: HashMap<VolatilityRegime, AdjustmentCurve>,
}

impl VolatilityAdjuster {
    pub async fn adjust_size(&self, base_size: f64, symbol: &str) -> Result<f64> {
        // Calculate current ATR
        let current_atr = self.calculate_atr(symbol, self.atr_period).await?;
        
        // Get historical ATR for percentile ranking
        let historical_atr = self.volatility_database
            .get_historical_atr(symbol, 252).await?; // 1 year
        
        // Calculate volatility percentile
        let volatility_percentile = self.calculate_percentile(current_atr, &historical_atr);
        
        // Classify volatility regime
        let regime = self.classify_volatility_regime(volatility_percentile);
        
        // Apply regime-specific adjustment
        let adjustment_factor = self.get_adjustment_factor(regime, volatility_percentile);
        
        let adjusted_size = base_size * adjustment_factor;
        
        Ok(adjusted_size)
    }
    
    fn classify_volatility_regime(&self, percentile: f64) -> VolatilityRegime {
        match percentile {
            p if p < 20.0 => VolatilityRegime::Low,
            p if p < 40.0 => VolatilityRegime::BelowNormal,
            p if p < 60.0 => VolatilityRegime::Normal,
            p if p < 80.0 => VolatilityRegime::AboveNormal,
            p if p < 95.0 => VolatilityRegime::High,
            _ => VolatilityRegime::Extreme,
        }
    }
    
    fn get_adjustment_factor(&self, regime: VolatilityRegime, percentile: f64) -> f64 {
        match regime {
            VolatilityRegime::Low => 1.1,        // Increase size in low volatility
            VolatilityRegime::BelowNormal => 1.05,
            VolatilityRegime::Normal => 1.0,     // No adjustment
            VolatilityRegime::AboveNormal => 0.9,
            VolatilityRegime::High => 0.7,       // Reduce size in high volatility
            VolatilityRegime::Extreme => 0.5,    // Significant reduction
        }
    }
}
```

### Drawdown-Based Size Adjustment
Progressive size reduction based on account drawdown:
```rust
pub struct DrawdownAdjuster {
    drawdown_thresholds: HashMap<DrawdownLevel, f64>,
    size_reduction_factors: HashMap<DrawdownLevel, f64>,
    drawdown_tracker: Arc<DrawdownTracker>,
}

impl DrawdownAdjuster {
    pub async fn adjust_size(&self, base_size: f64, account_id: AccountId) -> Result<f64> {
        let current_drawdown = self.drawdown_tracker
            .get_current_drawdown(account_id).await?;
        
        let drawdown_level = self.classify_drawdown_level(current_drawdown.percentage);
        let reduction_factor = self.get_reduction_factor(drawdown_level);
        
        let adjusted_size = base_size * reduction_factor;
        
        // Log drawdown adjustment
        info!("Drawdown adjustment for account {}: {}% drawdown, size reduced by factor {}",
            account_id, current_drawdown.percentage, reduction_factor);
        
        Ok(adjusted_size)
    }
    
    fn classify_drawdown_level(&self, drawdown_pct: f64) -> DrawdownLevel {
        match drawdown_pct {
            d if d < 1.0 => DrawdownLevel::Minimal,
            d if d < 3.0 => DrawdownLevel::Small,
            d if d < 5.0 => DrawdownLevel::Moderate,
            d if d < 8.0 => DrawdownLevel::Large,
            _ => DrawdownLevel::Extreme,
        }
    }
    
    fn get_reduction_factor(&self, level: DrawdownLevel) -> f64 {
        match level {
            DrawdownLevel::Minimal => 1.0,    // No reduction
            DrawdownLevel::Small => 0.9,      // 10% reduction
            DrawdownLevel::Moderate => 0.5,   // 50% reduction (as per AC)
            DrawdownLevel::Large => 0.3,      // 70% reduction
            DrawdownLevel::Extreme => 0.1,    // 90% reduction
        }
    }
}
```

### Correlation-Based Size Adjustment
Portfolio correlation analysis and position sizing:
```rust
pub struct CorrelationAdjuster {
    position_tracker: Arc<PositionTracker>,
    correlation_calculator: Arc<CorrelationCalculator>,
    max_correlation_threshold: f64,
}

impl CorrelationAdjuster {
    pub async fn adjust_size(&self, base_size: f64, request: &PositionSizeRequest) -> Result<f64> {
        // Get current open positions for the account
        let open_positions = self.position_tracker
            .get_open_positions(request.account_id).await?;
        
        if open_positions.is_empty() {
            return Ok(base_size); // No correlation adjustment needed
        }
        
        // Calculate correlation with existing positions
        let correlations = self.calculate_position_correlations(
            &request.symbol, &open_positions
        ).await?;
        
        // Find maximum correlation
        let max_correlation = correlations.iter()
            .map(|c| c.correlation_coefficient.abs())
            .max_by(|a, b| a.partial_cmp(b).unwrap())
            .unwrap_or(0.0);
        
        // Apply correlation-based reduction
        let adjustment_factor = self.calculate_correlation_adjustment(max_correlation);
        let adjusted_size = base_size * adjustment_factor;
        
        // Check portfolio heat
        let portfolio_heat = self.calculate_portfolio_heat(
            request.account_id, &request.symbol, adjusted_size
        ).await?;
        
        // Further reduce if portfolio heat too high
        let final_size = if portfolio_heat > 0.1 { // Max 10% portfolio heat
            adjusted_size * 0.7 // Further reduction
        } else {
            adjusted_size
        };
        
        Ok(final_size)
    }
    
    fn calculate_correlation_adjustment(&self, max_correlation: f64) -> f64 {
        if max_correlation < 0.3 {
            1.0     // No adjustment for low correlation
        } else if max_correlation < 0.5 {
            0.9     // 10% reduction
        } else if max_correlation < 0.7 {
            0.7     // 30% reduction
        } else {
            0.5     // 50% reduction for high correlation
        }
    }
    
    async fn calculate_portfolio_heat(&self, account_id: AccountId, new_symbol: &str, new_size: f64) -> Result<f64> {
        let account_balance = self.get_account_balance(account_id).await?;
        let open_positions = self.position_tracker.get_open_positions(account_id).await?;
        
        // Calculate total risk from existing positions
        let existing_risk: f64 = open_positions.iter()
            .map(|pos| pos.risk_amount)
            .sum();
        
        // Calculate risk for new position
        let new_position_risk = new_size * self.get_pip_value(new_symbol, account_balance).await?;
        
        // Total portfolio heat
        let total_risk = existing_risk + new_position_risk;
        let portfolio_heat = total_risk / account_balance;
        
        Ok(portfolio_heat)
    }
}
```

### Prop Firm Limit Enforcement
Comprehensive limit checking and enforcement:
```rust
pub struct PropFirmLimitChecker {
    firm_limits: HashMap<PropFirm, PropFirmLimits>,
    account_firm_mapping: Arc<AccountFirmMapping>,
}

impl PropFirmLimitChecker {
    pub async fn enforce_limits(&self, calculated_size: f64, request: &PositionSizeRequest) -> Result<f64> {
        let prop_firm = self.account_firm_mapping
            .get_firm_for_account(request.account_id).await?;
        
        let limits = self.firm_limits.get(&prop_firm)
            .ok_or(Error::UnknownPropFirm(prop_firm))?;
        
        let mut enforced_size = calculated_size;
        
        // Check maximum lot size per trade
        if enforced_size > limits.max_lot_size {
            enforced_size = limits.max_lot_size;
            warn!("Position size reduced to comply with max lot size limit: {} -> {}",
                calculated_size, enforced_size);
        }
        
        // Check maximum open positions
        let open_positions_count = self.get_open_positions_count(
            request.account_id, &request.symbol
        ).await?;
        
        if open_positions_count >= limits.max_positions_per_symbol {
            return Err(Error::MaxPositionsExceeded);
        }
        
        // Check total exposure limits
        let current_exposure = self.calculate_current_exposure(request.account_id).await?;
        let new_exposure_value = enforced_size * self.get_contract_value(&request.symbol).await?;
        
        if current_exposure + new_exposure_value > limits.max_total_exposure {
            // Reduce size to fit within exposure limit
            let available_exposure = limits.max_total_exposure - current_exposure;
            let max_allowed_size = available_exposure / self.get_contract_value(&request.symbol).await?;
            enforced_size = enforced_size.min(max_allowed_size);
        }
        
        // Check margin requirements
        let required_margin = self.calculate_required_margin(&request.symbol, enforced_size).await?;
        let available_margin = self.get_available_margin(request.account_id).await?;
        
        if required_margin > available_margin {
            // Reduce size based on available margin
            let margin_constrained_size = (available_margin * 0.8) / // 80% safety buffer
                self.get_margin_per_lot(&request.symbol).await?;
            enforced_size = enforced_size.min(margin_constrained_size);
        }
        
        Ok(enforced_size)
    }
}
```

### Anti-Detection Size Variance
Sophisticated variance generation to avoid detection:
```rust
pub struct SizeVarianceEngine {
    variance_profiles: HashMap<AccountId, VarianceProfile>,
    variance_history: Arc<VarianceHistoryTracker>,
    randomization_seed: SystemTime,
}

impl SizeVarianceEngine {
    pub async fn apply_variance(&self, base_size: f64, account_id: AccountId) -> Result<f64> {
        let profile = self.get_or_create_variance_profile(account_id).await?;
        
        // Generate variance factor (5-15% as per AC)
        let variance_factor = self.generate_variance_factor(&profile);
        
        // Apply directional bias based on account personality
        let directional_variance = if profile.aggressive {
            1.0 + variance_factor  // Tend toward larger sizes
        } else {
            1.0 - variance_factor  // Tend toward smaller sizes
        };
        
        let varied_size = base_size * directional_variance;
        
        // Record variance for pattern detection avoidance
        self.variance_history.record_variance(
            account_id, base_size, varied_size, variance_factor
        ).await?;
        
        // Check for pattern formation and adjust if needed
        if self.is_forming_detectable_pattern(account_id).await? {
            return self.apply_pattern_breaking_variance(varied_size, account_id).await;
        }
        
        Ok(varied_size)
    }
    
    fn generate_variance_factor(&self, profile: &VarianceProfile) -> f64 {
        let mut rng = StdRng::seed_from_u64(
            profile.seed + SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
        );
        
        // Generate variance between 5-15%
        let variance_range = 0.15 - 0.05; // 10% range
        let base_variance = 0.05; // 5% minimum
        
        let random_factor: f64 = rng.gen();
        base_variance + (random_factor * variance_range)
    }
    
    async fn is_forming_detectable_pattern(&self, account_id: AccountId) -> Result<bool> {
        let recent_variances = self.variance_history
            .get_recent_variances(account_id, 20).await?; // Last 20 trades
        
        if recent_variances.len() < 10 {
            return Ok(false);
        }
        
        // Check for too much consistency (low standard deviation)
        let variance_factors: Vec<f64> = recent_variances.iter()
            .map(|v| v.variance_factor)
            .collect();
        
        let mean = variance_factors.iter().sum::<f64>() / variance_factors.len() as f64;
        let variance = variance_factors.iter()
            .map(|v| (v - mean).powi(2))
            .sum::<f64>() / variance_factors.len() as f64;
        
        let std_dev = variance.sqrt();
        
        // If standard deviation is too low, we're forming a pattern
        Ok(std_dev < 0.02) // Less than 2% standard deviation indicates pattern
    }
}
```

### Database Schema for Position Sizing
```sql
CREATE TABLE position_sizing_calculations (
    calculation_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    signal_id UUID REFERENCES trading_signals(signal_id),
    account_id UUID REFERENCES trading_accounts(account_id),
    symbol VARCHAR(20) NOT NULL,
    base_size DECIMAL(10,4) NOT NULL,
    final_size DECIMAL(10,4) NOT NULL,
    
    -- Adjustment factors
    volatility_factor DECIMAL(6,4) NOT NULL,
    drawdown_factor DECIMAL(6,4) NOT NULL,
    correlation_factor DECIMAL(6,4) NOT NULL,
    limit_factor DECIMAL(6,4) NOT NULL,
    variance_factor DECIMAL(6,4) NOT NULL,
    
    -- Risk metrics
    account_balance DECIMAL(12,2) NOT NULL,
    risk_percentage DECIMAL(5,2) NOT NULL,
    stop_distance_pips DECIMAL(8,2) NOT NULL,
    risk_amount DECIMAL(10,2) NOT NULL,
    
    -- Market context
    volatility_percentile DECIMAL(5,2),
    account_drawdown DECIMAL(5,2),
    max_correlation DECIMAL(4,3),
    
    calculated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    INDEX idx_sizing_account_time (account_id, calculated_at),
    INDEX idx_sizing_signal (signal_id)
);

CREATE TABLE size_variance_history (
    variance_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    account_id UUID REFERENCES trading_accounts(account_id),
    base_size DECIMAL(10,4) NOT NULL,
    varied_size DECIMAL(10,4) NOT NULL,
    variance_factor DECIMAL(6,4) NOT NULL,
    variance_direction VARCHAR(10) NOT NULL, -- 'increase', 'decrease'
    pattern_detected BOOLEAN DEFAULT false,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    INDEX idx_variance_account_time (account_id, created_at)
);
```

### API Endpoints
```rust
// REST API for position sizing
#[post("/api/v1/position-sizing/calculate")]
async fn calculate_position_size(
    request: web::Json<PositionSizeRequest>
) -> Result<web::Json<PositionSizeResponse>> {
    let calculator = get_position_size_calculator();
    let result = calculator.calculate_position_size(request.into_inner()).await?;
    Ok(web::Json(result.into()))
}

#[get("/api/v1/position-sizing/limits/{account_id}")]
async fn get_position_limits(
    path: web::Path<AccountId>
) -> Result<web::Json<PositionLimits>> {
    let limits = get_account_position_limits(path.into_inner()).await?;
    Ok(web::Json(limits))
}
```

### Testing Requirements
- **Formula accuracy tests:** Validate position size calculations with known scenarios
- **Volatility adjustment tests:** Test size reduction under different volatility regimes
- **Drawdown tests:** Verify progressive size reduction as drawdown increases
- **Correlation tests:** Validate size reduction when positions are correlated
- **Limit enforcement tests:** Test compliance with all prop firm limitations
- **Variance tests:** Ensure 5-15% variance is maintained while avoiding patterns
- **Integration tests:** End-to-end testing with real market data

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-06 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here*
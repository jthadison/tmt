# Story 4.3: Real-Time Risk Monitoring

## Status
Draft

## Story
**As a** risk manager,
**I want** continuous monitoring of all risk metrics,
**so that** I can prevent excessive losses.

## Acceptance Criteria
1. Real-time P&L calculation updated every tick
2. Drawdown tracking: daily, weekly, and maximum drawdown
3. Exposure monitoring across all positions and accounts
4. Risk-reward tracking for open positions
5. Margin level monitoring with warnings at 150% and 120%
6. Automated position reduction when risk thresholds approached

## Tasks / Subtasks
- [ ] Task 1: Build real-time P&L calculation engine (AC: 1)
  - [ ] Implement tick-by-tick P&L updates for all open positions
  - [ ] Calculate unrealized P&L using current market prices
  - [ ] Track realized P&L from closed positions
  - [ ] Aggregate P&L across positions and accounts
  - [ ] Add P&L breakdown by symbol, strategy, and timeframe
  - [ ] Create P&L streaming via WebSocket for real-time updates
- [ ] Task 2: Create comprehensive drawdown tracking (AC: 2)
  - [ ] Implement daily drawdown calculation from day's opening balance
  - [ ] Track weekly drawdown from week's highest equity point
  - [ ] Calculate maximum drawdown from all-time high equity
  - [ ] Add drawdown recovery monitoring and alerts
  - [ ] Create drawdown visualization and trend analysis
  - [ ] Implement drawdown-based position sizing adjustments
- [ ] Task 3: Build exposure monitoring system (AC: 3)
  - [ ] Calculate total exposure per currency pair
  - [ ] Track aggregate exposure across all accounts
  - [ ] Monitor net exposure by currency (USD, EUR, GBP, etc.)
  - [ ] Add exposure concentration warnings
  - [ ] Create exposure limits enforcement
  - [ ] Implement dynamic exposure rebalancing alerts
- [ ] Task 4: Create risk-reward tracking for open positions (AC: 4)
  - [ ] Calculate current R:R ratio for each open position
  - [ ] Track maximum favorable excursion (MFE) per position
  - [ ] Monitor maximum adverse excursion (MAE) per position
  - [ ] Add risk-reward ratio alerts and optimization suggestions
  - [ ] Create position performance scoring and ranking
  - [ ] Implement target adjustment recommendations
- [ ] Task 5: Build margin monitoring system (AC: 5)
  - [ ] Track real-time margin usage across all accounts
  - [ ] Calculate margin level percentage for each account
  - [ ] Add margin level alerts at 150% and 120% thresholds
  - [ ] Monitor free margin and margin calls
  - [ ] Create margin optimization recommendations
  - [ ] Implement automatic margin level protection
- [ ] Task 6: Create automated risk response system (AC: 6)
  - [ ] Define risk threshold levels for automated action
  - [ ] Implement position size reduction algorithms
  - [ ] Create emergency position closure procedures
  - [ ] Add risk-based trading halt mechanisms
  - [ ] Build escalation procedures for critical risk events
  - [ ] Create risk response audit logging and reporting

## Dev Notes

### Architecture Context
The Real-Time Risk Monitoring system is a critical component of the Adaptive Risk Intelligence Agent (ARIA) that provides continuous oversight of all risk metrics across the trading system. This system must process high-frequency market data updates while maintaining accurate risk calculations and triggering appropriate responses to protect capital. [Source: architecture/components.md#adaptive-risk-intelligence-agent-aria]

### Previous Story Context
Stories 4.1-4.2 established the MetaTrader Bridge for execution and the Dynamic Position Sizing Calculator. The Risk Monitoring system builds on these foundations to provide comprehensive risk oversight for all executed positions, ensuring that the system operates within safe parameters at all times.

### Real-Time P&L Calculation Engine
High-frequency P&L calculation with streaming updates:
```rust
pub struct RealTimePnLCalculator {
    position_tracker: Arc<PositionTracker>,
    market_data_stream: Arc<MarketDataStream>,
    pnl_cache: Arc<DashMap<PositionId, PnLSnapshot>>,
    websocket_publisher: Arc<WebSocketPublisher>,
    kafka_producer: Arc<KafkaProducer>,
}

impl RealTimePnLCalculator {
    pub async fn start_pnl_monitoring(&self) {
        let mut market_data_rx = self.market_data_stream.subscribe().await;
        
        while let Some(tick) = market_data_rx.recv().await {
            if let Err(e) = self.process_tick_update(&tick).await {
                error!("Failed to process tick update: {}", e);
                continue;
            }
        }
    }
    
    async fn process_tick_update(&self, tick: &MarketTick) -> Result<()> {
        // Get all positions for this symbol
        let positions = self.position_tracker
            .get_positions_by_symbol(&tick.symbol).await?;
        
        for position in positions {
            let updated_pnl = self.calculate_position_pnl(&position, tick).await?;
            
            // Update cache
            self.pnl_cache.insert(position.id, updated_pnl.clone());
            
            // Stream update via WebSocket
            self.websocket_publisher.publish_pnl_update(PnLUpdate {
                position_id: position.id,
                account_id: position.account_id,
                symbol: position.symbol.clone(),
                unrealized_pnl: updated_pnl.unrealized_pnl,
                unrealized_pnl_percentage: updated_pnl.unrealized_pnl_percentage,
                current_price: tick.price,
                timestamp: tick.timestamp,
            }).await?;
            
            // Check for significant P&L changes
            if self.is_significant_pnl_change(&updated_pnl, &position).await? {
                self.publish_pnl_alert(&position, &updated_pnl).await?;
            }
        }
        
        // Update aggregate P&L by account
        self.update_aggregate_pnl(&tick.symbol).await?;
        
        Ok(())
    }
    
    async fn calculate_position_pnl(&self, position: &Position, tick: &MarketTick) -> Result<PnLSnapshot> {
        let current_price = tick.price;
        let entry_price = position.entry_price;
        let position_size = position.size;
        let pip_value = self.get_pip_value(&position.symbol, position.account_id).await?;
        
        // Calculate unrealized P&L
        let price_diff = if position.position_type == PositionType::Long {
            current_price - entry_price
        } else {
            entry_price - current_price
        };
        
        let unrealized_pnl = price_diff * position_size * pip_value;
        let unrealized_pnl_percentage = (price_diff / entry_price) * 100.0 * 
            if position.position_type == PositionType::Long { 1.0 } else { -1.0 };
        
        // Update running P&L statistics
        let mut max_favorable = position.max_favorable_excursion;
        let mut max_adverse = position.max_adverse_excursion;
        
        if unrealized_pnl > max_favorable {
            max_favorable = unrealized_pnl;
        }
        if unrealized_pnl < max_adverse {
            max_adverse = unrealized_pnl;
        }
        
        Ok(PnLSnapshot {
            position_id: position.id,
            unrealized_pnl,
            unrealized_pnl_percentage,
            max_favorable_excursion: max_favorable,
            max_adverse_excursion: max_adverse,
            current_price,
            timestamp: tick.timestamp,
        })
    }
}
```

### Comprehensive Drawdown Tracking
Multi-timeframe drawdown analysis:
```rust
pub struct DrawdownTracker {
    equity_history: Arc<EquityHistoryManager>,
    drawdown_cache: Arc<DashMap<AccountId, DrawdownMetrics>>,
    drawdown_alerts: Arc<DrawdownAlertManager>,
}

impl DrawdownTracker {
    pub async fn calculate_drawdowns(&self, account_id: AccountId) -> Result<DrawdownMetrics> {
        let equity_history = self.equity_history.get_history(account_id, Duration::from_days(30)).await?;
        
        if equity_history.is_empty() {
            return Ok(DrawdownMetrics::default());
        }
        
        // Calculate daily drawdown
        let daily_drawdown = self.calculate_daily_drawdown(&equity_history).await?;
        
        // Calculate weekly drawdown
        let weekly_drawdown = self.calculate_weekly_drawdown(&equity_history).await?;
        
        // Calculate maximum drawdown
        let max_drawdown = self.calculate_maximum_drawdown(&equity_history).await?;
        
        let metrics = DrawdownMetrics {
            daily_drawdown,
            weekly_drawdown,
            maximum_drawdown: max_drawdown,
            current_underwater_period: self.calculate_underwater_period(&equity_history).await?,
            recovery_factor: self.calculate_recovery_factor(&equity_history).await?,
            last_updated: Utc::now(),
        };
        
        // Update cache
        self.drawdown_cache.insert(account_id, metrics.clone());
        
        // Check for drawdown alerts
        self.check_drawdown_alerts(account_id, &metrics).await?;
        
        Ok(metrics)
    }
    
    async fn calculate_daily_drawdown(&self, equity_history: &[EquityPoint]) -> Result<DrawdownData> {
        let today_start = Utc::now().date_naive().and_hms_opt(0, 0, 0).unwrap();
        let today_points: Vec<_> = equity_history.iter()
            .filter(|point| point.timestamp.date_naive() >= today_start.date())
            .collect();
        
        if today_points.is_empty() {
            return Ok(DrawdownData::default());
        }
        
        let starting_equity = today_points[0].equity;
        let current_equity = today_points.last().unwrap().equity;
        let peak_equity = today_points.iter().map(|p| p.equity).fold(0.0, f64::max);
        
        let drawdown_amount = peak_equity - current_equity;
        let drawdown_percentage = (drawdown_amount / peak_equity) * 100.0;
        
        Ok(DrawdownData {
            amount: drawdown_amount,
            percentage: drawdown_percentage,
            peak_equity,
            current_equity,
            start_time: today_points[0].timestamp,
            duration: Utc::now() - today_points[0].timestamp,
        })
    }
    
    async fn calculate_maximum_drawdown(&self, equity_history: &[EquityPoint]) -> Result<DrawdownData> {
        let mut max_drawdown = 0.0;
        let mut max_drawdown_pct = 0.0;
        let mut peak_equity = 0.0;
        let mut drawdown_start: Option<DateTime<Utc>> = None;
        let mut max_drawdown_period = Duration::zero();
        
        for point in equity_history {
            if point.equity > peak_equity {
                peak_equity = point.equity;
                drawdown_start = None; // Reset drawdown period
            } else {
                if drawdown_start.is_none() {
                    drawdown_start = Some(point.timestamp);
                }
                
                let current_drawdown = peak_equity - point.equity;
                let current_drawdown_pct = (current_drawdown / peak_equity) * 100.0;
                
                if current_drawdown > max_drawdown {
                    max_drawdown = current_drawdown;
                    max_drawdown_pct = current_drawdown_pct;
                    
                    if let Some(start_time) = drawdown_start {
                        max_drawdown_period = point.timestamp - start_time;
                    }
                }
            }
        }
        
        Ok(DrawdownData {
            amount: max_drawdown,
            percentage: max_drawdown_pct,
            peak_equity,
            current_equity: equity_history.last().map(|p| p.equity).unwrap_or(0.0),
            start_time: drawdown_start.unwrap_or_else(|| Utc::now()),
            duration: max_drawdown_period,
        })
    }
}
```

### Exposure Monitoring System
Portfolio exposure tracking and analysis:
```rust
pub struct ExposureMonitor {
    position_tracker: Arc<PositionTracker>,
    currency_exposure_calculator: Arc<CurrencyExposureCalculator>,
    exposure_limits: Arc<ExposureLimits>,
    exposure_alerts: Arc<ExposureAlertManager>,
}

impl ExposureMonitor {
    pub async fn calculate_total_exposure(&self) -> Result<ExposureReport> {
        // Get all open positions across all accounts
        let all_positions = self.position_tracker.get_all_open_positions().await?;
        
        // Calculate exposure by currency pair
        let pair_exposure = self.calculate_pair_exposure(&all_positions).await?;
        
        // Calculate net currency exposure
        let currency_exposure = self.currency_exposure_calculator
            .calculate_net_exposure(&all_positions).await?;
        
        // Calculate total portfolio exposure
        let total_exposure = self.calculate_total_portfolio_exposure(&all_positions).await?;
        
        // Check exposure limits
        let limit_violations = self.check_exposure_limits(&pair_exposure, &currency_exposure).await?;
        
        let report = ExposureReport {
            pair_exposure,
            currency_exposure,
            total_exposure,
            limit_violations,
            concentration_risk: self.calculate_concentration_risk(&all_positions).await?,
            diversification_score: self.calculate_diversification_score(&all_positions).await?,
            timestamp: Utc::now(),
        };
        
        // Send alerts for any violations
        if !limit_violations.is_empty() {
            self.exposure_alerts.send_violation_alert(&report).await?;
        }
        
        Ok(report)
    }
    
    async fn calculate_pair_exposure(&self, positions: &[Position]) -> Result<HashMap<String, ExposureData>> {
        let mut pair_exposure = HashMap::new();
        
        for position in positions {
            let exposure_value = self.calculate_position_exposure_value(position).await?;
            
            let entry = pair_exposure.entry(position.symbol.clone()).or_insert(ExposureData {
                long_exposure: 0.0,
                short_exposure: 0.0,
                net_exposure: 0.0,
                total_exposure: 0.0,
                position_count: 0,
            });
            
            match position.position_type {
                PositionType::Long => {
                    entry.long_exposure += exposure_value;
                },
                PositionType::Short => {
                    entry.short_exposure += exposure_value;
                }
            }
            
            entry.net_exposure = entry.long_exposure - entry.short_exposure;
            entry.total_exposure = entry.long_exposure + entry.short_exposure;
            entry.position_count += 1;
        }
        
        Ok(pair_exposure)
    }
    
    async fn calculate_concentration_risk(&self, positions: &[Position]) -> Result<ConcentrationRisk> {
        let total_exposure: f64 = positions.iter()
            .map(|p| p.size * p.entry_price)
            .sum();
        
        // Calculate Herfindahl-Hirschman Index for concentration
        let mut symbol_exposures = HashMap::new();
        for position in positions {
            let exposure = position.size * position.entry_price;
            *symbol_exposures.entry(&position.symbol).or_insert(0.0) += exposure;
        }
        
        let hhi: f64 = symbol_exposures.values()
            .map(|&exposure| {
                let market_share = exposure / total_exposure;
                market_share * market_share
            })
            .sum();
        
        let concentration_level = match hhi {
            h if h < 0.15 => ConcentrationLevel::Low,
            h if h < 0.25 => ConcentrationLevel::Moderate,
            _ => ConcentrationLevel::High,
        };
        
        Ok(ConcentrationRisk {
            herfindahl_index: hhi,
            concentration_level,
            largest_position_percentage: symbol_exposures.values()
                .map(|&exp| exp / total_exposure * 100.0)
                .fold(0.0, f64::max),
        })
    }
}
```

### Margin Monitoring System
Real-time margin tracking and alerts:
```rust
pub struct MarginMonitor {
    account_manager: Arc<AccountManager>,
    margin_calculator: Arc<MarginCalculator>,
    margin_alerts: Arc<MarginAlertManager>,
    margin_thresholds: MarginThresholds,
}

impl MarginMonitor {
    pub async fn monitor_margin_levels(&self) {
        let mut interval = tokio::time::interval(Duration::from_secs(1));
        
        loop {
            interval.tick().await;
            
            if let Err(e) = self.check_all_account_margins().await {
                error!("Failed to check margin levels: {}", e);
            }
        }
    }
    
    async fn check_all_account_margins(&self) -> Result<()> {
        let accounts = self.account_manager.get_all_active_accounts().await?;
        
        for account in accounts {
            let margin_info = self.calculate_account_margin(&account).await?;
            
            // Check margin level thresholds
            self.check_margin_thresholds(&account, &margin_info).await?;
            
            // Update margin cache
            self.update_margin_cache(&account.id, &margin_info).await?;
        }
        
        Ok(())
    }
    
    async fn calculate_account_margin(&self, account: &Account) -> Result<MarginInfo> {
        let positions = self.account_manager.get_account_positions(&account.id).await?;
        
        let mut used_margin = 0.0;
        for position in &positions {
            used_margin += self.margin_calculator
                .calculate_position_margin(position).await?;
        }
        
        let account_balance = account.balance;
        let account_equity = account_balance + positions.iter()
            .map(|p| p.unrealized_pnl.unwrap_or(0.0))
            .sum::<f64>();
        
        let free_margin = account_equity - used_margin;
        let margin_level = if used_margin > 0.0 {
            (account_equity / used_margin) * 100.0
        } else {
            f64::INFINITY
        };
        
        Ok(MarginInfo {
            account_id: account.id,
            balance: account_balance,
            equity: account_equity,
            used_margin,
            free_margin,
            margin_level,
            positions_count: positions.len(),
            timestamp: Utc::now(),
        })
    }
    
    async fn check_margin_thresholds(&self, account: &Account, margin_info: &MarginInfo) -> Result<()> {
        // Check 150% warning threshold
        if margin_info.margin_level <= self.margin_thresholds.warning_level && 
           margin_info.margin_level > self.margin_thresholds.critical_level {
            self.margin_alerts.send_warning_alert(MarginAlert {
                account_id: account.id,
                level: AlertLevel::Warning,
                margin_level: margin_info.margin_level,
                threshold: self.margin_thresholds.warning_level,
                message: format!("Margin level at {}% - approaching warning threshold", 
                    margin_info.margin_level),
                timestamp: Utc::now(),
            }).await?;
        }
        
        // Check 120% critical threshold
        if margin_info.margin_level <= self.margin_thresholds.critical_level {
            self.margin_alerts.send_critical_alert(MarginAlert {
                account_id: account.id,
                level: AlertLevel::Critical,
                margin_level: margin_info.margin_level,
                threshold: self.margin_thresholds.critical_level,
                message: format!("CRITICAL: Margin level at {}% - immediate action required", 
                    margin_info.margin_level),
                timestamp: Utc::now(),
            }).await?;
            
            // Trigger automated margin protection
            self.trigger_margin_protection(account.id, margin_info).await?;
        }
        
        Ok(())
    }
}
```

### Automated Risk Response System
Intelligent risk threshold management:
```rust
pub struct RiskResponseSystem {
    risk_thresholds: Arc<RiskThresholds>,
    position_manager: Arc<PositionManager>,
    circuit_breaker: Arc<CircuitBreakerClient>,
    risk_logger: Arc<RiskAuditLogger>,
}

impl RiskResponseSystem {
    pub async fn evaluate_and_respond(&self, risk_event: RiskEvent) -> Result<RiskResponse> {
        let severity = self.assess_risk_severity(&risk_event).await?;
        let response_action = self.determine_response_action(&risk_event, severity).await?;
        
        // Log the risk event and intended response
        self.risk_logger.log_risk_event(&risk_event, &response_action).await?;
        
        // Execute the response
        let execution_result = self.execute_response_action(&response_action).await?;
        
        // Log the execution result
        self.risk_logger.log_response_execution(&response_action, &execution_result).await?;
        
        Ok(RiskResponse {
            risk_event,
            severity,
            action_taken: response_action,
            execution_result,
            timestamp: Utc::now(),
        })
    }
    
    async fn determine_response_action(&self, risk_event: &RiskEvent, severity: RiskSeverity) -> Result<ResponseAction> {
        match (risk_event.risk_type.as_ref(), severity) {
            ("margin_level", RiskSeverity::Critical) => {
                Ok(ResponseAction::ReducePositions {
                    account_id: risk_event.account_id,
                    reduction_percentage: 50.0,
                    priority: ReductionPriority::LargestLoss,
                })
            },
            
            ("drawdown_exceeded", RiskSeverity::High) => {
                Ok(ResponseAction::ReducePositionSize {
                    account_id: risk_event.account_id,
                    new_risk_percentage: 1.0, // Reduce to 1% risk per trade
                })
            },
            
            ("exposure_concentration", RiskSeverity::Medium) => {
                Ok(ResponseAction::DiversifyPositions {
                    account_id: risk_event.account_id,
                    max_exposure_per_symbol: 20.0, // Max 20% per symbol
                })
            },
            
            ("correlation_risk", RiskSeverity::Medium) => {
                Ok(ResponseAction::ReduceCorrelatedPositions {
                    account_id: risk_event.account_id,
                    correlation_threshold: 0.7,
                    reduction_factor: 0.5,
                })
            },
            
            (_, RiskSeverity::Extreme) => {
                Ok(ResponseAction::EmergencyStop {
                    scope: EmergencyStopScope::Account(risk_event.account_id),
                    reason: format!("Extreme risk detected: {}", risk_event.description),
                })
            },
            
            _ => Ok(ResponseAction::Monitor),
        }
    }
    
    async fn execute_response_action(&self, action: &ResponseAction) -> Result<ResponseExecutionResult> {
        match action {
            ResponseAction::ReducePositions { account_id, reduction_percentage, priority } => {
                let positions = self.position_manager.get_account_positions(*account_id).await?;
                let positions_to_reduce = self.select_positions_for_reduction(&positions, *priority).await?;
                
                let mut results = Vec::new();
                for position in positions_to_reduce {
                    let new_size = position.size * (1.0 - reduction_percentage / 100.0);
                    let result = self.position_manager.reduce_position_size(position.id, new_size).await?;
                    results.push(result);
                }
                
                Ok(ResponseExecutionResult::PositionsReduced {
                    positions_affected: results.len(),
                    total_reduction: reduction_percentage,
                })
            },
            
            ResponseAction::EmergencyStop { scope, reason } => {
                self.circuit_breaker.trigger_emergency_stop(*scope, reason.clone()).await?;
                
                Ok(ResponseExecutionResult::EmergencyStopTriggered {
                    scope: *scope,
                    timestamp: Utc::now(),
                })
            },
            
            ResponseAction::Monitor => {
                Ok(ResponseExecutionResult::MonitoringContinued)
            },
            
            // ... other action implementations
        }
    }
}
```

### Database Schema for Risk Monitoring
```sql
CREATE TABLE risk_metrics_snapshot (
    snapshot_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    account_id UUID REFERENCES trading_accounts(account_id),
    
    -- P&L metrics
    unrealized_pnl DECIMAL(12,2) NOT NULL,
    realized_pnl_today DECIMAL(12,2) NOT NULL,
    total_pnl DECIMAL(12,2) NOT NULL,
    
    -- Drawdown metrics
    daily_drawdown_pct DECIMAL(8,4) NOT NULL,
    weekly_drawdown_pct DECIMAL(8,4) NOT NULL,
    max_drawdown_pct DECIMAL(8,4) NOT NULL,
    
    -- Exposure metrics
    total_exposure DECIMAL(15,2) NOT NULL,
    largest_position_pct DECIMAL(5,2) NOT NULL,
    concentration_hhi DECIMAL(6,4) NOT NULL,
    
    -- Margin metrics
    margin_level DECIMAL(8,2) NOT NULL,
    used_margin DECIMAL(12,2) NOT NULL,
    free_margin DECIMAL(12,2) NOT NULL,
    
    -- Risk ratios
    avg_risk_reward_ratio DECIMAL(6,3),
    win_rate DECIMAL(5,2),
    profit_factor DECIMAL(6,3),
    
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    INDEX idx_risk_metrics_account_time (account_id, recorded_at)
);

CREATE TABLE risk_alerts (
    alert_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    account_id UUID REFERENCES trading_accounts(account_id),
    alert_type VARCHAR(50) NOT NULL,
    severity VARCHAR(20) NOT NULL CHECK (severity IN ('low', 'medium', 'high', 'critical', 'extreme')),
    message TEXT NOT NULL,
    metric_value DECIMAL(12,4),
    threshold_value DECIMAL(12,4),
    resolved BOOLEAN DEFAULT false,
    resolved_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    INDEX idx_risk_alerts_account_type (account_id, alert_type),
    INDEX idx_risk_alerts_severity (severity, created_at)
);

CREATE TABLE risk_responses (
    response_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    alert_id UUID REFERENCES risk_alerts(alert_id),
    account_id UUID REFERENCES trading_accounts(account_id),
    response_action VARCHAR(100) NOT NULL,
    action_parameters JSONB,
    execution_status VARCHAR(20) DEFAULT 'pending',
    execution_result JSONB,
    executed_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    INDEX idx_risk_responses_account_time (account_id, created_at)
);
```

### WebSocket Streaming for Real-Time Updates
```rust
// Real-time risk metric streaming
pub struct RiskMetricsStreamer {
    websocket_server: Arc<WebSocketServer>,
    subscription_manager: Arc<SubscriptionManager>,
}

impl RiskMetricsStreamer {
    pub async fn stream_risk_update(&self, update: RiskUpdate) -> Result<()> {
        let subscribers = self.subscription_manager
            .get_subscribers_for_account(update.account_id).await?;
        
        let message = serde_json::to_string(&update)?;
        
        for subscriber in subscribers {
            if let Err(e) = self.websocket_server.send_message(subscriber, &message).await {
                warn!("Failed to send risk update to subscriber {}: {}", subscriber, e);
            }
        }
        
        Ok(())
    }
}

// WebSocket message format
#[derive(Serialize)]
pub struct RiskUpdate {
    pub account_id: AccountId,
    pub update_type: String, // "pnl", "drawdown", "margin", "exposure"
    pub current_value: f64,
    pub previous_value: Option<f64>,
    pub threshold_status: String, // "safe", "warning", "critical"
    pub timestamp: DateTime<Utc>,
}
```

### Testing Requirements
- **P&L accuracy tests:** Validate P&L calculations against known price movements
- **Drawdown calculation tests:** Verify drawdown tracking across different scenarios
- **Exposure monitoring tests:** Test exposure calculations with multiple positions
- **Margin level tests:** Validate margin monitoring and alert thresholds
- **Response system tests:** Test automated risk responses and escalations
- **Performance tests:** Ensure real-time updates maintain <100ms latency
- **Integration tests:** End-to-end risk monitoring with live market data

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-06 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here*
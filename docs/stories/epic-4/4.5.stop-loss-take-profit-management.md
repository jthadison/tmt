# Story 4.5: Stop Loss and Take Profit Management

## Status
In Progress - Feature branch created: `feature/story-4.5-stop-loss-take-profit-management`

## Story
**As a** position manager,
**I want** dynamic adjustment of exit levels,
**so that** profits are maximized while protecting capital.

## Acceptance Criteria
1. Trailing stop implementation with ATR-based distance
2. Break-even stop movement after 1:1 risk-reward achieved
3. Partial profit taking at predetermined levels (50% at 1:1, 25% at 2:1)
4. Time-based exits for positions exceeding expected hold time
5. News event protection with tightened stops before high-impact events
6. Exit level modifications logged with reasoning

## Tasks / Subtasks
- [ ] Task 1: Build ATR-based trailing stop system (AC: 1)
  - [ ] Implement dynamic ATR calculation for trailing distance
  - [ ] Create trailing stop activation based on favorable movement
  - [ ] Add ATR multiplier configuration per symbol and timeframe
  - [ ] Implement minimum and maximum trailing distances
  - [ ] Create trailing stop visualization and monitoring
  - [ ] Add trailing stop performance analytics and optimization
- [ ] Task 2: Create break-even stop automation (AC: 2)
  - [ ] Implement automatic break-even detection at 1:1 R:R
  - [ ] Add configurable break-even trigger points
  - [ ] Create break-even stop placement with small buffer (5-10 pips)
  - [ ] Add break-even stop confirmation and validation
  - [ ] Implement break-even stop failure handling and retry logic
  - [ ] Create break-even stop performance tracking
- [ ] Task 3: Build partial profit taking system (AC: 3)
  - [ ] Implement 50% position closure at 1:1 risk-reward ratio
  - [ ] Add 25% position closure at 2:1 risk-reward ratio
  - [ ] Create configurable partial profit levels per strategy
  - [ ] Add partial closure execution with size validation
  - [ ] Implement remaining position management after partials
  - [ ] Create partial profit performance analysis and optimization
- [ ] Task 4: Create time-based exit system (AC: 4)
  - [ ] Implement position age monitoring and tracking
  - [ ] Add configurable maximum hold times per symbol/strategy
  - [ ] Create time-based exit warnings and alerts
  - [ ] Add time-based exit execution with market conditions check
  - [ ] Implement time exit override for strong trending moves
  - [ ] Create time-based exit performance analysis
- [ ] Task 5: Build news event protection system (AC: 5)
  - [ ] Integrate economic calendar for high-impact news events
  - [ ] Implement automatic stop tightening before news events
  - [ ] Add news event impact classification and stop adjustment rules
  - [ ] Create position closure option for extreme news events
  - [ ] Add news event protection configuration per account
  - [ ] Implement post-news position management and stop restoration
- [ ] Task 6: Create comprehensive exit logging system (AC: 6)
  - [ ] Build exit modification decision logging with full reasoning
  - [ ] Create exit level change audit trail with timestamps
  - [ ] Add exit performance metrics collection and analysis
  - [ ] Implement exit decision replay capability for debugging
  - [ ] Create exit strategy effectiveness reporting
  - [ ] Add compliance reporting for exit level modifications

## Dev Notes

### Architecture Context
The Stop Loss and Take Profit Management system is the final component of the execution pipeline, responsible for dynamically managing position exits to optimize profitability while maintaining strict risk control. This system integrates with all previous Epic 4 components - the MetaTrader Bridge for execution, Position Sizing for risk calculation, Risk Monitoring for oversight, and Trade Orchestration for coordination. [Source: architecture/components.md#execution-engine]

### Previous Story Context
Stories 4.1-4.4 established the complete execution infrastructure: MetaTrader integration, position sizing, risk monitoring, and trade orchestration. The Stop Loss and Take Profit Management system provides the intelligent exit management that transforms basic trade execution into a sophisticated profit optimization engine.

### ATR-Based Trailing Stop System
Dynamic trailing stop implementation using Average True Range:
```rust
pub struct TrailingStopManager {
    atr_calculator: Arc<ATRCalculator>,
    position_tracker: Arc<PositionTracker>,
    trail_configs: HashMap<String, TrailingConfig>,
    active_trails: Arc<DashMap<PositionId, ActiveTrail>>,
    mt_bridge: Arc<dyn MT4Bridge>,
}

impl TrailingStopManager {
    pub async fn update_trailing_stops(&self) -> Result<()> {
        let open_positions = self.position_tracker.get_all_open_positions().await?;
        
        for position in open_positions {
            if let Some(trail) = self.active_trails.get(&position.id) {
                let updated_trail = self.calculate_new_trail_level(&position, &trail).await?;
                
                if self.should_update_trail(&trail, &updated_trail) {
                    self.execute_trail_update(&position, updated_trail).await?;
                }
            }
        }
        
        Ok(())
    }
    
    async fn calculate_new_trail_level(&self, position: &Position, current_trail: &ActiveTrail) -> Result<TrailUpdate> {
        // Calculate current ATR for the symbol
        let current_atr = self.atr_calculator.calculate_atr(&position.symbol, 14).await?;
        
        // Get trailing configuration
        let config = self.trail_configs.get(&position.symbol)
            .unwrap_or(&TrailingConfig::default());
        
        // Calculate ATR-based trailing distance
        let trail_distance = current_atr * config.atr_multiplier;
        
        // Ensure distance is within bounds
        let bounded_distance = trail_distance
            .max(config.min_trail_distance)
            .min(config.max_trail_distance);
        
        // Get current market price
        let current_price = self.get_current_price(&position.symbol).await?;
        
        // Calculate new trail level
        let new_trail_level = if position.position_type == PositionType::Long {
            current_price - bounded_distance
        } else {
            current_price + bounded_distance
        };
        
        Ok(TrailUpdate {
            position_id: position.id,
            old_level: current_trail.trail_level,
            new_level: new_trail_level,
            atr_used: current_atr,
            distance_pips: bounded_distance,
            trigger_price: current_price,
            update_reason: format!(
                "ATR-based trail: ATR={:.5}, Multiplier={}, Distance={:.1} pips",
                current_atr, config.atr_multiplier, bounded_distance * 10000.0
            ),
        })
    }
    
    fn should_update_trail(&self, current: &ActiveTrail, update: &TrailUpdate) -> bool {
        // Only update if new level is better (more favorable)
        match current.position_type {
            PositionType::Long => update.new_level > current.trail_level,
            PositionType::Short => update.new_level < current.trail_level,
        }
    }
    
    async fn execute_trail_update(&self, position: &Position, update: TrailUpdate) -> Result<()> {
        // Update stop loss via MT Bridge
        let result = self.mt_bridge.modify_order(
            position.mt_order_id,
            Some(update.new_level),
            None
        ).await?;
        
        // Update active trail record
        if let Some(mut trail) = self.active_trails.get_mut(&position.id) {
            trail.trail_level = update.new_level;
            trail.last_updated = Utc::now();
            trail.update_count += 1;
        }
        
        // Log trail update
        self.log_trail_update(position.id, &update).await?;
        
        info!(
            "Trailing stop updated for position {}: {} -> {} ({})",
            position.id, update.old_level, update.new_level, update.update_reason
        );
        
        Ok(())
    }
}
```

### Break-Even Stop Automation
Intelligent break-even stop management:
```rust
pub struct BreakEvenManager {
    position_tracker: Arc<PositionTracker>,
    mt_bridge: Arc<dyn MT4Bridge>,
    break_even_configs: HashMap<String, BreakEvenConfig>,
}

impl BreakEvenManager {
    pub async fn check_break_even_triggers(&self) -> Result<()> {
        let open_positions = self.position_tracker.get_open_positions_without_breakeven().await?;
        
        for position in open_positions {
            if self.is_break_even_triggered(&position).await? {
                self.execute_break_even(&position).await?;
            }
        }
        
        Ok(())
    }
    
    async fn is_break_even_triggered(&self, position: &Position) -> Result<bool> {
        let current_price = self.get_current_price(&position.symbol).await?;
        let entry_price = position.entry_price;
        let initial_stop = position.initial_stop_loss;
        
        // Calculate current profit in pips
        let profit_pips = match position.position_type {
            PositionType::Long => (current_price - entry_price) * 10000.0,
            PositionType::Short => (entry_price - current_price) * 10000.0,
        };
        
        // Calculate risk in pips
        let risk_pips = match position.position_type {
            PositionType::Long => (entry_price - initial_stop) * 10000.0,
            PositionType::Short => (initial_stop - entry_price) * 10000.0,
        };
        
        // Get break-even configuration
        let config = self.break_even_configs.get(&position.symbol)
            .unwrap_or(&BreakEvenConfig::default());
        
        // Check if 1:1 risk-reward achieved plus buffer
        let break_even_threshold = risk_pips * config.trigger_ratio; // Default 1.0 for 1:1
        
        Ok(profit_pips >= break_even_threshold)
    }
    
    async fn execute_break_even(&self, position: &Position) -> Result<()> {
        let config = self.break_even_configs.get(&position.symbol)
            .unwrap_or(&BreakEvenConfig::default());
        
        // Calculate break-even level with small buffer
        let break_even_level = position.entry_price + config.break_even_buffer_pips / 10000.0;
        
        // Execute stop loss modification
        let result = self.mt_bridge.modify_order(
            position.mt_order_id,
            Some(break_even_level),
            None
        ).await?;
        
        // Mark position as having break-even stop
        self.position_tracker.mark_break_even_active(position.id).await?;
        
        // Log break-even activation
        self.log_break_even_activation(position.id, position.current_stop_loss, break_even_level).await?;
        
        info!(
            "Break-even stop activated for position {}: {} -> {} (+{} pip buffer)",
            position.id, position.current_stop_loss, break_even_level, config.break_even_buffer_pips
        );
        
        Ok(())
    }
}
```

### Partial Profit Taking System
Systematic partial position closure:
```rust
pub struct PartialProfitManager {
    position_tracker: Arc<PositionTracker>,
    mt_bridge: Arc<dyn MT4Bridge>,
    profit_configs: HashMap<String, ProfitTakingConfig>,
}

impl PartialProfitManager {
    pub async fn check_profit_targets(&self) -> Result<()> {
        let open_positions = self.position_tracker.get_positions_with_remaining_targets().await?;
        
        for position in open_positions {
            let targets_hit = self.evaluate_profit_targets(&position).await?;
            
            for target in targets_hit {
                self.execute_partial_close(&position, &target).await?;
            }
        }
        
        Ok(())
    }
    
    async fn evaluate_profit_targets(&self, position: &Position) -> Result<Vec<ProfitTarget>> {
        let current_price = self.get_current_price(&position.symbol).await?;
        let entry_price = position.entry_price;
        let initial_stop = position.initial_stop_loss;
        
        // Calculate current R:R ratio
        let current_rr = self.calculate_risk_reward_ratio(
            entry_price, current_price, initial_stop, position.position_type
        );
        
        let config = self.profit_configs.get(&position.symbol)
            .unwrap_or(&ProfitTakingConfig::default());
        
        let mut targets_hit = Vec::new();
        
        // Check each profit target
        for target in &config.profit_targets {
            if current_rr >= target.risk_reward_ratio && !position.is_target_hit(target.level) {
                targets_hit.push(target.clone());
            }
        }
        
        Ok(targets_hit)
    }
    
    async fn execute_partial_close(&self, position: &Position, target: &ProfitTarget) -> Result<()> {
        // Calculate partial close volume
        let remaining_volume = position.current_volume;
        let close_volume = remaining_volume * target.close_percentage;
        
        // Validate minimum volume requirements
        if close_volume < self.get_minimum_volume(&position.symbol).await? {
            warn!("Partial close volume too small for position {}, skipping", position.id);
            return Ok(());
        }
        
        // Execute partial close via MT Bridge
        let result = self.mt_bridge.close_position_partial(
            position.mt_order_id,
            close_volume
        ).await?;
        
        // Update position tracking
        self.position_tracker.record_partial_close(
            position.id, target.level, close_volume, result.close_price
        ).await?;
        
        // Log partial profit taking
        self.log_partial_profit_taking(position.id, target, close_volume, result.close_price).await?;
        
        info!(
            "Partial profit taken for position {}: {}% at {} R:R (Volume: {:.4})",
            position.id, target.close_percentage * 100.0, target.risk_reward_ratio, close_volume
        );
        
        Ok(())
    }
    
    fn calculate_risk_reward_ratio(
        &self,
        entry_price: f64,
        current_price: f64,
        stop_loss: f64,
        position_type: PositionType
    ) -> f64 {
        let profit = match position_type {
            PositionType::Long => current_price - entry_price,
            PositionType::Short => entry_price - current_price,
        };
        
        let risk = match position_type {
            PositionType::Long => entry_price - stop_loss,
            PositionType::Short => stop_loss - entry_price,
        };
        
        if risk > 0.0 {
            profit / risk
        } else {
            0.0
        }
    }
}
```

### Time-Based Exit System
Position age monitoring and time-based exits:
```rust
pub struct TimeBasedExitManager {
    position_tracker: Arc<PositionTracker>,
    mt_bridge: Arc<dyn MT4Bridge>,
    time_configs: HashMap<String, TimeExitConfig>,
    market_condition_analyzer: Arc<MarketConditionAnalyzer>,
}

impl TimeBasedExitManager {
    pub async fn check_time_based_exits(&self) -> Result<()> {
        let aged_positions = self.position_tracker.get_aged_positions().await?;
        
        for position in aged_positions {
            if self.should_exit_on_time(&position).await? {
                self.execute_time_based_exit(&position).await?;
            }
        }
        
        Ok(())
    }
    
    async fn should_exit_on_time(&self, position: &Position) -> Result<bool> {
        let position_age = Utc::now() - position.entry_time;
        let config = self.time_configs.get(&position.symbol)
            .unwrap_or(&TimeExitConfig::default());
        
        // Check if maximum hold time exceeded
        if position_age > config.max_hold_duration {
            // Override for strong trending conditions
            let market_conditions = self.market_condition_analyzer
                .analyze_current_conditions(&position.symbol).await?;
            
            if market_conditions.trend_strength > 0.8 && 
               position.unrealized_pnl > 0.0 {
                info!(
                    "Time exit overridden for position {} due to strong trend (strength: {:.2})",
                    position.id, market_conditions.trend_strength
                );
                return Ok(false);
            }
            
            return Ok(true);
        }
        
        // Check warning thresholds
        if position_age > config.warning_duration {
            self.send_time_warning(position).await?;
        }
        
        Ok(false)
    }
    
    async fn execute_time_based_exit(&self, position: &Position) -> Result<()> {
        // Close entire position
        let result = self.mt_bridge.close_position(position.mt_order_id).await?;
        
        // Log time-based exit
        self.log_time_based_exit(position.id, position.entry_time, result.close_price).await?;
        
        info!(
            "Time-based exit executed for position {}: Age {} hours, Exit price: {}",
            position.id,
            (Utc::now() - position.entry_time).num_hours(),
            result.close_price
        );
        
        Ok(())
    }
    
    async fn send_time_warning(&self, position: &Position) -> Result<()> {
        let position_age = Utc::now() - position.entry_time;
        let config = self.time_configs.get(&position.symbol)
            .unwrap_or(&TimeExitConfig::default());
        let remaining_time = config.max_hold_duration - position_age;
        
        // Send warning alert
        self.alert_manager.send_alert(Alert {
            level: AlertLevel::Warning,
            message: format!(
                "Position {} approaching time exit: {} hours remaining",
                position.id, remaining_time.num_hours()
            ),
            position_id: Some(position.id),
            timestamp: Utc::now(),
        }).await?;
        
        Ok(())
    }
}
```

### News Event Protection System
Pre-news stop tightening and position protection:
```rust
pub struct NewsEventProtection {
    economic_calendar: Arc<EconomicCalendarClient>,
    position_tracker: Arc<PositionTracker>,
    mt_bridge: Arc<dyn MT4Bridge>,
    news_configs: HashMap<String, NewsProtectionConfig>,
    protected_positions: Arc<DashMap<PositionId, NewsProtection>>,
}

impl NewsEventProtection {
    pub async fn monitor_upcoming_news(&self) -> Result<()> {
        // Get high-impact news events in the next 2 hours
        let upcoming_events = self.economic_calendar
            .get_upcoming_events(Duration::from_hours(2), ImpactLevel::High).await?;
        
        for event in upcoming_events {
            self.apply_news_protection(&event).await?;
        }
        
        Ok(())
    }
    
    async fn apply_news_protection(&self, event: &NewsEvent) -> Result<()> {
        // Get positions affected by this news event
        let affected_positions = self.position_tracker
            .get_positions_for_currency(&event.currency).await?;
        
        let config = self.news_configs.get(&event.currency)
            .unwrap_or(&NewsProtectionConfig::default());
        
        for position in affected_positions {
            match config.protection_strategy {
                NewsProtectionStrategy::TightenStops => {
                    self.tighten_stops_for_news(&position, &event, config).await?;
                },
                NewsProtectionStrategy::ClosePosition => {
                    self.close_position_for_news(&position, &event).await?;
                },
                NewsProtectionStrategy::ReduceSize => {
                    self.reduce_position_for_news(&position, &event, config).await?;
                }
            }
        }
        
        Ok(())
    }
    
    async fn tighten_stops_for_news(
        &self,
        position: &Position,
        event: &NewsEvent,
        config: &NewsProtectionConfig
    ) -> Result<()> {
        let current_stop = position.current_stop_loss;
        let entry_price = position.entry_price;
        
        // Calculate tightened stop level
        let normal_risk = match position.position_type {
            PositionType::Long => entry_price - current_stop,
            PositionType::Short => current_stop - entry_price,
        };
        
        let reduced_risk = normal_risk * config.stop_tighten_factor; // e.g., 0.5 for 50% reduction
        
        let new_stop = match position.position_type {
            PositionType::Long => entry_price - reduced_risk,
            PositionType::Short => entry_price + reduced_risk,
        };
        
        // Apply the tightened stop
        let result = self.mt_bridge.modify_order(
            position.mt_order_id,
            Some(new_stop),
            None
        ).await?;
        
        // Record news protection
        self.protected_positions.insert(position.id, NewsProtection {
            position_id: position.id,
            original_stop: current_stop,
            protected_stop: new_stop,
            news_event: event.clone(),
            protection_start: Utc::now(),
            restoration_scheduled: Some(event.time + Duration::from_hours(2)),
        });
        
        info!(
            "News protection applied to position {}: Stop tightened from {} to {} for {} event",
            position.id, current_stop, new_stop, event.description
        );
        
        Ok(())
    }
    
    pub async fn restore_post_news_stops(&self) -> Result<()> {
        let now = Utc::now();
        let mut to_restore = Vec::new();
        
        // Find positions ready for stop restoration
        for protection in self.protected_positions.iter() {
            if let Some(restore_time) = protection.restoration_scheduled {
                if now >= restore_time {
                    to_restore.push(protection.clone());
                }
            }
        }
        
        // Restore original stops
        for protection in to_restore {
            self.restore_original_stop(&protection).await?;
        }
        
        Ok(())
    }
    
    async fn restore_original_stop(&self, protection: &NewsProtection) -> Result<()> {
        // Check if position still exists
        if let Some(position) = self.position_tracker.get_position(protection.position_id).await? {
            // Restore to a reasonable stop level (not necessarily the original)
            let reasonable_stop = self.calculate_reasonable_stop_post_news(&position).await?;
            
            let result = self.mt_bridge.modify_order(
                position.mt_order_id,
                Some(reasonable_stop),
                None
            ).await?;
            
            info!(
                "Post-news stop restoration for position {}: {} -> {}",
                position.id, protection.protected_stop, reasonable_stop
            );
        }
        
        // Remove from protected positions
        self.protected_positions.remove(&protection.position_id);
        
        Ok(())
    }
}
```

### Comprehensive Exit Logging System
Detailed audit trail for all exit decisions:
```rust
pub struct ExitAuditLogger {
    audit_database: Arc<AuditDatabase>,
    exit_analytics: Arc<ExitAnalytics>,
}

impl ExitAuditLogger {
    pub async fn log_exit_modification(&self, modification: ExitModification) -> Result<AuditEntry> {
        let audit_entry = AuditEntry {
            entry_id: Uuid::new_v4(),
            position_id: modification.position_id,
            modification_type: modification.modification_type.clone(),
            old_value: modification.old_value,
            new_value: modification.new_value,
            reasoning: modification.reasoning.clone(),
            market_context: modification.market_context.clone(),
            performance_impact: self.calculate_performance_impact(&modification).await?,
            timestamp: Utc::now(),
        };
        
        // Store in audit database
        self.audit_database.store_audit_entry(&audit_entry).await?;
        
        // Update analytics
        self.exit_analytics.record_modification(&modification).await?;
        
        Ok(audit_entry)
    }
    
    pub async fn generate_exit_performance_report(&self, time_range: TimeRange) -> Result<ExitPerformanceReport> {
        let audit_entries = self.audit_database.get_entries_in_range(time_range).await?;
        
        let mut report = ExitPerformanceReport::new();
        
        // Analyze trailing stop effectiveness
        self.analyze_trailing_stop_performance(&audit_entries, &mut report).await?;
        
        // Analyze break-even stop success rate
        self.analyze_break_even_performance(&audit_entries, &mut report).await?;
        
        // Analyze partial profit taking results
        self.analyze_partial_profit_performance(&audit_entries, &mut report).await?;
        
        // Analyze time-based exit outcomes
        self.analyze_time_exit_performance(&audit_entries, &mut report).await?;
        
        // Analyze news protection effectiveness
        self.analyze_news_protection_performance(&audit_entries, &mut report).await?;
        
        Ok(report)
    }
    
    pub async fn create_exit_replay(&self, position_id: PositionId) -> Result<ExitReplay> {
        let exit_history = self.audit_database
            .get_position_exit_history(position_id).await?;
        
        let replay = ExitReplay {
            position_id,
            exit_timeline: self.build_exit_timeline(&exit_history).await?,
            decision_points: self.extract_decision_points(&exit_history).await?,
            market_context_evolution: self.track_market_context_changes(&exit_history).await?,
            performance_attribution: self.calculate_performance_attribution(&exit_history).await?,
            lessons_learned: self.extract_lessons_learned(&exit_history).await?,
        };
        
        Ok(replay)
    }
}
```

### Database Schema for Exit Management
```sql
CREATE TABLE exit_modifications (
    modification_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    position_id UUID REFERENCES trading_positions(position_id),
    modification_type VARCHAR(50) NOT NULL, -- 'trailing_stop', 'break_even', 'partial_profit', 'time_exit', 'news_protection'
    old_value DECIMAL(10,5),
    new_value DECIMAL(10,5),
    reasoning TEXT NOT NULL,
    market_context JSONB,
    atr_at_time DECIMAL(8,5),
    position_age_hours INTEGER,
    unrealized_pnl DECIMAL(10,2),
    risk_reward_ratio DECIMAL(6,3),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    INDEX idx_exit_modifications_position (position_id),
    INDEX idx_exit_modifications_type_time (modification_type, created_at)
);

CREATE TABLE partial_profit_history (
    profit_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    position_id UUID REFERENCES trading_positions(position_id),
    profit_level INTEGER NOT NULL, -- 1 for first target, 2 for second, etc.
    risk_reward_ratio DECIMAL(6,3) NOT NULL,
    close_percentage DECIMAL(5,4) NOT NULL,
    close_volume DECIMAL(10,4) NOT NULL,
    close_price DECIMAL(10,5) NOT NULL,
    profit_amount DECIMAL(10,2) NOT NULL,
    remaining_volume DECIMAL(10,4) NOT NULL,
    executed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    INDEX idx_partial_profits_position (position_id),
    INDEX idx_partial_profits_time (executed_at)
);

CREATE TABLE news_event_protections (
    protection_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    position_id UUID REFERENCES trading_positions(position_id),
    news_event_id VARCHAR(100) NOT NULL,
    news_description TEXT NOT NULL,
    news_currency VARCHAR(10) NOT NULL,
    news_impact VARCHAR(20) NOT NULL,
    protection_strategy VARCHAR(50) NOT NULL,
    original_stop_loss DECIMAL(10,5),
    protected_stop_loss DECIMAL(10,5),
    protection_start TIMESTAMP WITH TIME ZONE NOT NULL,
    protection_end TIMESTAMP WITH TIME ZONE,
    restoration_executed BOOLEAN DEFAULT false,
    
    INDEX idx_news_protections_position (position_id),
    INDEX idx_news_protections_currency_time (news_currency, protection_start)
);
```

### API Endpoints for Exit Management
```rust
#[post("/api/v1/positions/{position_id}/trail")]
async fn activate_trailing_stop(
    path: web::Path<PositionId>,
    config: web::Json<TrailingConfig>
) -> Result<web::Json<TrailingActivationResult>> {
    let result = activate_position_trailing_stop(
        path.into_inner(), 
        config.into_inner()
    ).await?;
    Ok(web::Json(result))
}

#[post("/api/v1/positions/{position_id}/break-even")]
async fn trigger_break_even(
    path: web::Path<PositionId>
) -> Result<web::Json<BreakEvenResult>> {
    let result = execute_break_even_stop(path.into_inner()).await?;
    Ok(web::Json(result))
}

#[get("/api/v1/exits/performance")]
async fn get_exit_performance(
    query: web::Query<PerformanceQuery>
) -> Result<web::Json<ExitPerformanceReport>> {
    let report = generate_exit_performance_report(query.into_inner()).await?;
    Ok(web::Json(report))
}
```

### Testing Requirements
- **Trailing stop tests:** Validate ATR-based trailing with various market conditions
- **Break-even tests:** Test 1:1 risk-reward detection and stop movement accuracy
- **Partial profit tests:** Verify correct volume calculations and execution
- **Time exit tests:** Test age-based exits with trend override scenarios
- **News protection tests:** Validate stop tightening before high-impact events
- **Integration tests:** End-to-end exit management with real market scenarios
- **Performance tests:** Exit decision latency and system responsiveness under load

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-06 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here*
# Story 4.1: MetaTrader Bridge Implementation

## Status
Draft

## Story
**As an** execution system,
**I want** direct integration with MT4/MT5 platforms,
**so that** I can execute trades on prop firm accounts.

## Acceptance Criteria
1. MT4/MT5 bridge supports market and pending orders
2. Order execution completes within 100ms of signal generation
3. Position modification (SL/TP adjustment) supported in real-time
4. Account synchronization updates positions every second
5. Connection monitoring with automatic reconnection on failure
6. Order rejection handling with reason codes and retry logic

## Tasks / Subtasks
- [ ] Task 1: Build MT4/MT5 bridge architecture (AC: 1)
  - [ ] Design bridge API specification for MT4/MT5 communication
  - [ ] Implement market order placement (buy/sell at market price)
  - [ ] Add pending order support (buy stop, sell stop, buy limit, sell limit)
  - [ ] Create order cancellation and deletion functionality
  - [ ] Implement order query and status checking
  - [ ] Add support for multiple MT4/MT5 instances per bridge
- [ ] Task 2: Optimize execution speed for <100ms latency (AC: 2)
  - [ ] Implement connection pooling to MT4/MT5 terminals
  - [ ] Create asynchronous order processing pipeline
  - [ ] Add order pre-validation to avoid rejections
  - [ ] Implement direct memory communication with MT4/MT5
  - [ ] Add execution time monitoring and optimization
  - [ ] Create fast-path execution for market orders
- [ ] Task 3: Build position modification system (AC: 3)
  - [ ] Implement stop loss modification for existing positions
  - [ ] Add take profit level adjustment functionality
  - [ ] Create trailing stop implementation
  - [ ] Add partial position closing capabilities
  - [ ] Implement position reversal functionality
  - [ ] Add bulk position modification for multiple orders
- [ ] Task 4: Create account synchronization engine (AC: 4)
  - [ ] Implement real-time position monitoring (1-second updates)
  - [ ] Add account balance and equity synchronization
  - [ ] Create margin level monitoring and reporting
  - [ ] Add open order tracking and status updates
  - [ ] Implement trade history synchronization
  - [ ] Create account synchronization conflict resolution
- [ ] Task 5: Build connection resilience system (AC: 5)
  - [ ] Implement connection health monitoring with heartbeat
  - [ ] Add automatic reconnection with exponential backoff
  - [ ] Create connection failover between multiple terminals
  - [ ] Add connection quality metrics and alerting
  - [ ] Implement graceful handling of MT4/MT5 restarts
  - [ ] Create connection pool management and optimization
- [ ] Task 6: Implement order rejection handling (AC: 6)
  - [ ] Create comprehensive error code mapping from MT4/MT5
  - [ ] Add intelligent retry logic with backoff strategies
  - [ ] Implement order rejection reason analysis and logging
  - [ ] Create alternative execution strategies for rejections
  - [ ] Add rejection rate monitoring and alerting
  - [ ] Implement manual override capabilities for persistent rejections

## Dev Notes

### Architecture Context
The MetaTrader Bridge is the critical interface between the Rust-based Execution Engine and the prop firm MT4/MT5 platforms. This component must achieve sub-100ms latency while maintaining reliability and handling the complexities of MetaTrader platform integration. The bridge runs as a separate service that communicates with both the main execution engine and the MetaTrader terminals. [Source: architecture/components.md#execution-engine]

### Previous Epic Context
Epics 1-3 established the infrastructure, compliance, and signal generation layers. The MetaTrader Bridge represents the culmination of the trading pipeline, converting high-confidence signals into actual trades on prop firm accounts while maintaining all compliance and risk management constraints.

### MetaTrader Integration Architecture
The bridge implements a hybrid architecture combining multiple communication methods:

**Communication Methods:**
1. **DDE (Dynamic Data Exchange)** - Legacy but reliable for MT4
2. **File-based communication** - Cross-platform compatibility
3. **Windows API calls** - Direct memory access for speed
4. **TCP/HTTP bridge** - Custom bridge service running locally

**Bridge Service Design:**
```rust
// Rust execution engine bridge interface
#[async_trait]
pub trait MT4Bridge {
    async fn place_market_order(&self, request: MarketOrderRequest) -> Result<OrderResult>;
    async fn place_pending_order(&self, request: PendingOrderRequest) -> Result<OrderResult>;
    async fn modify_order(&self, order_id: u64, sl: Option<f64>, tp: Option<f64>) -> Result<()>;
    async fn close_position(&self, position_id: u64, volume: Option<f64>) -> Result<()>;
    async fn get_account_info(&self) -> Result<AccountInfo>;
    async fn get_positions(&self) -> Result<Vec<Position>>;
}

pub struct MT4BridgeImpl {
    connection_pool: Arc<ConnectionPool>,
    command_queue: Arc<Mutex<VecDeque<BridgeCommand>>>,
    response_cache: Arc<DashMap<String, BridgeResponse>>,
}
```

### Sub-100ms Execution Pipeline
Critical optimization strategies for ultra-low latency:

**Execution Path Optimization:**
```rust
impl ExecutionEngine {
    pub async fn execute_signal(&self, signal: TradingSignal) -> Result<ExecutionResult> {
        let start = Instant::now();
        
        // Step 1: Pre-validate signal (< 5ms)
        self.pre_validate_signal(&signal).await?;
        
        // Step 2: Select optimal account and terminal (< 5ms)
        let account = self.select_execution_account(&signal).await?;
        
        // Step 3: Calculate precise position size (< 10ms)
        let position_size = self.calculate_position_size(&signal, &account).await?;
        
        // Step 4: Submit order via optimized bridge (< 50ms)
        let order_result = self.bridge.place_market_order(MarketOrderRequest {
            symbol: signal.symbol,
            order_type: signal.signal_type,
            volume: position_size,
            stop_loss: Some(signal.stop_loss),
            take_profit: Some(signal.take_profit_1),
            slippage: 3, // 3 pip maximum slippage
            magic_number: account.magic_number,
        }).await?;
        
        // Step 5: Log and notify (< 10ms)
        self.log_execution(&signal, &order_result, start.elapsed()).await?;
        
        Ok(ExecutionResult {
            order_id: order_result.order_id,
            execution_time: start.elapsed(),
            fill_price: order_result.fill_price,
            slippage: order_result.slippage,
        })
    }
}
```

### Position Modification System
Real-time position management implementation:
```rust
pub struct PositionManager {
    bridge: Arc<dyn MT4Bridge>,
    position_cache: Arc<DashMap<u64, Position>>,
    modification_queue: Arc<Mutex<VecDeque<ModificationRequest>>>,
}

impl PositionManager {
    pub async fn update_stop_loss(&self, position_id: u64, new_sl: f64) -> Result<()> {
        // Validate new stop loss level
        let position = self.get_position(position_id).await?;
        self.validate_stop_loss(&position, new_sl)?;
        
        // Execute modification via bridge
        let result = self.bridge.modify_order(position.order_id, Some(new_sl), None).await?;
        
        // Update local cache
        if let Some(mut pos) = self.position_cache.get_mut(&position_id) {
            pos.stop_loss = new_sl;
            pos.last_modified = Utc::now();
        }
        
        // Log modification
        self.log_position_modification(position_id, "stop_loss_update", new_sl).await?;
        
        Ok(())
    }
    
    pub async fn implement_trailing_stop(&self, position_id: u64, trail_distance: f64) -> Result<()> {
        let position = self.get_position(position_id).await?;
        let current_price = self.get_current_price(&position.symbol).await?;
        
        let new_sl = if position.order_type == OrderType::Buy {
            current_price - trail_distance
        } else {
            current_price + trail_distance
        };
        
        // Only update if new stop is better than current
        if self.is_stop_improvement(&position, new_sl) {
            self.update_stop_loss(position_id, new_sl).await?;
        }
        
        Ok(())
    }
}
```

### Account Synchronization Engine
Real-time account state monitoring:
```rust
pub struct AccountSynchronizer {
    bridges: HashMap<AccountId, Arc<dyn MT4Bridge>>,
    sync_interval: Duration,
    last_sync: HashMap<AccountId, Instant>,
}

impl AccountSynchronizer {
    pub async fn run_synchronization_loop(&self) {
        let mut interval = tokio::time::interval(self.sync_interval);
        
        loop {
            interval.tick().await;
            
            // Sync all accounts in parallel
            let sync_futures: Vec<_> = self.bridges.iter()
                .map(|(account_id, bridge)| {
                    self.sync_account(*account_id, bridge.clone())
                })
                .collect();
                
            // Execute all syncs concurrently
            let results = futures::future::join_all(sync_futures).await;
            
            // Process sync results
            for (i, result) in results.into_iter().enumerate() {
                if let Err(e) = result {
                    error!("Account sync failed for account {}: {}", i, e);
                    self.handle_sync_failure(i, e).await;
                }
            }
        }
    }
    
    async fn sync_account(&self, account_id: AccountId, bridge: Arc<dyn MT4Bridge>) -> Result<()> {
        // Get current account state from MT4/MT5
        let account_info = bridge.get_account_info().await?;
        let positions = bridge.get_positions().await?;
        
        // Update local cache
        self.update_account_cache(account_id, account_info, positions).await?;
        
        // Detect and handle discrepancies
        self.reconcile_positions(account_id).await?;
        
        // Publish sync events
        self.publish_sync_event(account_id, SyncEventType::Completed).await?;
        
        Ok(())
    }
}
```

### Connection Resilience Implementation
Robust connection management with failover:
```rust
pub struct ConnectionManager {
    connections: Arc<DashMap<AccountId, Connection>>,
    health_checker: Arc<HealthChecker>,
    reconnect_strategy: ExponentialBackoff,
}

impl ConnectionManager {
    pub async fn ensure_connection(&self, account_id: AccountId) -> Result<Arc<Connection>> {
        if let Some(conn) = self.connections.get(&account_id) {
            if conn.is_healthy().await {
                return Ok(conn.clone());
            }
        }
        
        // Attempt reconnection
        let new_connection = self.establish_connection(account_id).await?;
        self.connections.insert(account_id, new_connection.clone());
        
        Ok(new_connection)
    }
    
    pub async fn monitor_connections(&self) {
        let mut interval = tokio::time::interval(Duration::from_secs(5));
        
        loop {
            interval.tick().await;
            
            for connection in self.connections.iter() {
                if !connection.is_healthy().await {
                    warn!("Connection unhealthy for account {}", connection.account_id);
                    
                    // Attempt automatic reconnection
                    if let Err(e) = self.reconnect_account(connection.account_id).await {
                        error!("Failed to reconnect account {}: {}", connection.account_id, e);
                    }
                }
            }
        }
    }
    
    async fn reconnect_account(&self, account_id: AccountId) -> Result<()> {
        let mut backoff = self.reconnect_strategy.clone();
        
        for attempt in 1..=5 {
            match self.establish_connection(account_id).await {
                Ok(connection) => {
                    info!("Reconnected account {} on attempt {}", account_id, attempt);
                    self.connections.insert(account_id, connection);
                    return Ok(());
                },
                Err(e) => {
                    warn!("Reconnection attempt {} failed for account {}: {}", attempt, account_id, e);
                    tokio::time::sleep(backoff.next_delay()).await;
                }
            }
        }
        
        Err(Error::ReconnectionFailed(account_id))
    }
}
```

### Order Rejection Handling System
Intelligent rejection handling and retry logic:
```rust
pub struct OrderRejectionHandler {
    retry_strategies: HashMap<MT4ErrorCode, RetryStrategy>,
    rejection_analytics: Arc<RejectionAnalytics>,
}

impl OrderRejectionHandler {
    pub async fn handle_rejection(&self, rejection: OrderRejection) -> Result<Option<OrderResult>> {
        // Log rejection for analytics
        self.rejection_analytics.record_rejection(&rejection).await;
        
        // Determine retry strategy based on error code
        let strategy = self.get_retry_strategy(rejection.error_code);
        
        match strategy {
            RetryStrategy::ImmediateRetry { max_attempts } => {
                self.retry_with_immediate_strategy(&rejection.original_request, max_attempts).await
            },
            RetryStrategy::DelayedRetry { delay, max_attempts } => {
                self.retry_with_delay_strategy(&rejection.original_request, delay, max_attempts).await
            },
            RetryStrategy::ModifyAndRetry { modification } => {
                self.retry_with_modification(&rejection.original_request, modification).await
            },
            RetryStrategy::AlternativeExecution => {
                self.attempt_alternative_execution(&rejection.original_request).await
            },
            RetryStrategy::NoRetry => {
                warn!("No retry strategy for error code: {:?}", rejection.error_code);
                Ok(None)
            }
        }
    }
    
    fn get_retry_strategy(&self, error_code: MT4ErrorCode) -> RetryStrategy {
        match error_code {
            MT4ErrorCode::InsufficientMargin => RetryStrategy::ModifyAndRetry { 
                modification: OrderModification::ReduceVolume(0.8) 
            },
            MT4ErrorCode::InvalidStops => RetryStrategy::ModifyAndRetry {
                modification: OrderModification::AdjustStops
            },
            MT4ErrorCode::MarketClosed => RetryStrategy::DelayedRetry {
                delay: Duration::from_secs(30),
                max_attempts: 10
            },
            MT4ErrorCode::PriceChanged => RetryStrategy::ImmediateRetry { max_attempts: 3 },
            MT4ErrorCode::Requote => RetryStrategy::ImmediateRetry { max_attempts: 5 },
            _ => RetryStrategy::NoRetry
        }
    }
}
```

### Integration with Execution Engine
The bridge integrates with the broader execution architecture:
```rust
// Main execution engine orchestrating the bridge
pub struct ExecutionEngine {
    bridge_manager: Arc<BridgeManager>,
    position_manager: Arc<PositionManager>,
    risk_monitor: Arc<RiskMonitor>,
    kafka_producer: Arc<KafkaProducer>,
}

impl ExecutionEngine {
    pub async fn handle_signal(&self, signal: TradingSignal) -> Result<()> {
        // Pre-execution risk check
        self.risk_monitor.validate_signal(&signal).await?;
        
        // Execute via bridge
        let result = self.execute_signal(signal.clone()).await?;
        
        // Publish execution event
        self.kafka_producer.publish("execution.order.placed", ExecutionEvent {
            signal_id: signal.signal_id,
            order_id: result.order_id,
            execution_time: result.execution_time,
            fill_price: result.fill_price,
            slippage: result.slippage,
            timestamp: Utc::now(),
        }).await?;
        
        Ok(())
    }
}
```

### Database Schema for Execution Tracking
```sql
CREATE TABLE execution_orders (
    order_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    signal_id UUID REFERENCES trading_signals(signal_id),
    account_id UUID REFERENCES trading_accounts(account_id),
    mt_order_id BIGINT NOT NULL, -- MetaTrader order ID
    symbol VARCHAR(20) NOT NULL,
    order_type VARCHAR(10) NOT NULL CHECK (order_type IN ('buy', 'sell')),
    volume DECIMAL(10,4) NOT NULL,
    requested_price DECIMAL(10,5),
    fill_price DECIMAL(10,5),
    slippage_pips DECIMAL(6,2),
    stop_loss DECIMAL(10,5),
    take_profit DECIMAL(10,5),
    execution_time_ms INTEGER,
    order_status VARCHAR(20) DEFAULT 'pending',
    rejection_reason TEXT,
    retry_count INTEGER DEFAULT 0,
    placed_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    filled_at TIMESTAMP WITH TIME ZONE,
    
    INDEX idx_execution_orders_signal (signal_id),
    INDEX idx_execution_orders_account_time (account_id, placed_at),
    INDEX idx_execution_orders_mt_id (mt_order_id)
);

CREATE TABLE bridge_health_metrics (
    metric_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    account_id UUID REFERENCES trading_accounts(account_id),
    connection_status VARCHAR(20) NOT NULL,
    last_heartbeat TIMESTAMP WITH TIME ZONE,
    execution_latency_ms INTEGER,
    rejection_rate DECIMAL(5,2),
    sync_delay_ms INTEGER,
    recorded_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    INDEX idx_bridge_health_account_time (account_id, recorded_at)
);
```

### Performance Monitoring and Alerting
```rust
pub struct BridgeMonitor {
    metrics_collector: Arc<MetricsCollector>,
    alert_manager: Arc<AlertManager>,
}

impl BridgeMonitor {
    pub async fn record_execution_metrics(&self, account_id: AccountId, metrics: ExecutionMetrics) {
        // Record Prometheus metrics
        self.metrics_collector.record_execution_latency(
            account_id, metrics.execution_time
        );
        
        // Check for performance degradation
        if metrics.execution_time > Duration::from_millis(100) {
            self.alert_manager.send_alert(Alert {
                level: AlertLevel::Warning,
                message: format!("Execution latency exceeded 100ms for account {}: {}ms", 
                    account_id, metrics.execution_time.as_millis()),
                metric_name: "execution_latency",
                threshold: 100.0,
                actual_value: metrics.execution_time.as_millis() as f64,
            }).await;
        }
    }
}
```

### Testing Requirements
- **Latency tests:** Verify <100ms execution time under load
- **Resilience tests:** Test automatic reconnection and failover scenarios
- **Integration tests:** End-to-end execution with real MT4/MT5 demo accounts
- **Error handling tests:** Validate rejection handling for all error codes
- **Concurrency tests:** Multiple simultaneous executions across accounts
- **Performance tests:** Sustained high-frequency execution testing

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-06 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here*
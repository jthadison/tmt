# Story 4.4: Trade Execution Orchestrator

## Status
Draft

## Story
**As a** trade coordinator,
**I want** intelligent routing of trades to appropriate accounts,
**so that** opportunities are maximized while respecting limits.

## Acceptance Criteria
1. Account selection based on available margin and risk budget
2. Trade distribution across accounts with anti-correlation logic
3. Execution timing variance (1-30 seconds) between accounts
4. Partial fill handling with completion monitoring
5. Failed execution recovery with alternative account routing
6. Execution audit log with timestamps and decision rationale

## Tasks / Subtasks
- [ ] Task 1: Build intelligent account selection system (AC: 1)
  - [ ] Implement margin availability checker for account selection
  - [ ] Create risk budget calculator per account
  - [ ] Add account health scoring for selection prioritization
  - [ ] Implement account exclusion logic for suspended/problematic accounts
  - [ ] Create account rotation algorithms to distribute trading load
  - [ ] Add account selection optimization based on historical performance
- [ ] Task 2: Create trade distribution system with anti-correlation (AC: 2)
  - [ ] Implement correlation analysis between accounts before trade allocation
  - [ ] Create trade distribution algorithms to minimize account correlation
  - [ ] Add position size variation across accounts (5-15% variance)
  - [ ] Implement account-specific trading personality application
  - [ ] Create correlation monitoring and adjustment during execution
  - [ ] Add trade rejection if correlation thresholds exceeded
- [ ] Task 3: Build execution timing variance system (AC: 3)
  - [ ] Implement randomized delay generation (1-30 seconds)
  - [ ] Create intelligent delay based on market conditions and volatility
  - [ ] Add account-specific timing personalities for consistent variance
  - [ ] Implement priority override for time-sensitive signals
  - [ ] Create delay monitoring to ensure variance effectiveness
  - [ ] Add timing coordination to prevent simultaneous executions
- [ ] Task 4: Implement partial fill handling (AC: 4)
  - [ ] Create partial fill detection and monitoring system
  - [ ] Implement completion strategies for unfilled portions
  - [ ] Add timeout handling for incomplete orders
  - [ ] Create alternative execution strategies for stubborn fills
  - [ ] Implement partial fill aggregation and position consolidation
  - [ ] Add partial fill reporting and analysis
- [ ] Task 5: Build execution failure recovery system (AC: 5)
  - [ ] Create execution failure detection and classification
  - [ ] Implement alternative account routing for failed executions
  - [ ] Add retry logic with exponential backoff for temporary failures
  - [ ] Create execution strategy modification for persistent failures
  - [ ] Implement manual override and intervention capabilities
  - [ ] Add failure analysis and prevention system
- [ ] Task 6: Create comprehensive execution audit system (AC: 6)
  - [ ] Build execution decision logging with full rationale
  - [ ] Create timestamp tracking for all execution steps
  - [ ] Implement execution performance metrics collection
  - [ ] Add compliance reporting for regulatory requirements
  - [ ] Create execution replay capability for debugging
  - [ ] Build execution analytics dashboard

## Dev Notes

### Architecture Context
The Trade Execution Orchestrator is the central coordination system that bridges signal generation and actual trade execution. It manages the complex process of selecting optimal accounts, distributing trades to avoid correlation, and ensuring successful execution while maintaining compliance with prop firm rules and anti-detection requirements. This system operates as part of the Execution Engine with orchestration logic. [Source: architecture/components.md#execution-engine]

### Previous Story Context
Stories 4.1-4.3 established the MetaTrader Bridge, Dynamic Position Sizing, and Real-Time Risk Monitoring systems. The Trade Execution Orchestrator integrates all these components to provide intelligent trade routing and execution management that optimizes for profitability while maintaining compliance.

### Intelligent Account Selection System
Multi-factor account selection with optimization:
```rust
pub struct AccountSelectionEngine {
    account_analyzer: Arc<AccountAnalyzer>,
    margin_checker: Arc<MarginChecker>,
    risk_budget_calculator: Arc<RiskBudgetCalculator>,
    performance_tracker: Arc<AccountPerformanceTracker>,
    health_monitor: Arc<AccountHealthMonitor>,
}

impl AccountSelectionEngine {
    pub async fn select_optimal_account(&self, signal: &TradingSignal) -> Result<AccountSelection> {
        // Get all eligible accounts
        let eligible_accounts = self.get_eligible_accounts(signal).await?;
        
        if eligible_accounts.is_empty() {
            return Err(Error::NoEligibleAccounts);
        }
        
        // Score each account
        let mut scored_accounts = Vec::new();
        for account in eligible_accounts {
            let score = self.calculate_account_score(&account, signal).await?;
            scored_accounts.push((account, score));
        }
        
        // Sort by score (highest first)
        scored_accounts.sort_by(|a, b| b.1.total_score.partial_cmp(&a.1.total_score).unwrap());
        
        let selected_account = scored_accounts[0].0.clone();
        let selection_rationale = scored_accounts[0].1.clone();
        
        Ok(AccountSelection {
            account: selected_account,
            rationale: selection_rationale,
            alternatives: scored_accounts[1..].iter().take(3).map(|(acc, _)| acc.clone()).collect(),
            selection_timestamp: Utc::now(),
        })
    }
    
    async fn calculate_account_score(&self, account: &Account, signal: &TradingSignal) -> Result<AccountScore> {
        // Factor 1: Margin availability (30% weight)
        let margin_score = self.calculate_margin_score(account, signal).await?;
        
        // Factor 2: Risk budget availability (25% weight)
        let risk_budget_score = self.calculate_risk_budget_score(account, signal).await?;
        
        // Factor 3: Account health (20% weight)
        let health_score = self.health_monitor.get_health_score(account.id).await?;
        
        // Factor 4: Performance history (15% weight)
        let performance_score = self.performance_tracker.get_performance_score(account.id).await?;
        
        // Factor 5: Correlation with existing positions (10% weight)
        let correlation_score = self.calculate_correlation_score(account, signal).await?;
        
        let total_score = 
            margin_score * 0.30 +
            risk_budget_score * 0.25 +
            health_score * 0.20 +
            performance_score * 0.15 +
            correlation_score * 0.10;
        
        Ok(AccountScore {
            account_id: account.id,
            total_score,
            factors: ScoreFactors {
                margin_score,
                risk_budget_score,
                health_score,
                performance_score,
                correlation_score,
            },
            selection_confidence: self.calculate_selection_confidence(total_score),
        })
    }
    
    async fn get_eligible_accounts(&self, signal: &TradingSignal) -> Result<Vec<Account>> {
        let all_accounts = self.account_analyzer.get_active_accounts().await?;
        let mut eligible = Vec::new();
        
        for account in all_accounts {
            // Check basic eligibility
            if !self.is_account_eligible(&account, signal).await? {
                continue;
            }
            
            // Check prop firm compatibility
            if !self.is_prop_firm_compatible(&account, signal).await? {
                continue;
            }
            
            // Check account status
            if !self.is_account_healthy(&account).await? {
                continue;
            }
            
            eligible.push(account);
        }
        
        Ok(eligible)
    }
}
```

### Trade Distribution with Anti-Correlation
Sophisticated distribution logic to avoid detection:
```rust
pub struct TradeDistributionSystem {
    correlation_analyzer: Arc<CorrelationAnalyzer>,
    distribution_optimizer: Arc<DistributionOptimizer>,
    personality_engine: Arc<PersonalityEngine>,
    variance_generator: Arc<VarianceGenerator>,
}

impl TradeDistributionSystem {
    pub async fn distribute_trade(&self, signal: &TradingSignal, target_accounts: &[Account]) -> Result<TradeDistribution> {
        // Analyze current correlations between accounts
        let correlation_matrix = self.correlation_analyzer
            .calculate_account_correlations(target_accounts).await?;
        
        // Check if distribution is viable without exceeding correlation thresholds
        let correlation_check = self.validate_correlation_constraints(
            &correlation_matrix, target_accounts, signal
        ).await?;
        
        if !correlation_check.is_viable {
            return Err(Error::CorrelationThresholdExceeded);
        }
        
        // Create distribution plan
        let mut distribution_plan = Vec::new();
        
        for (i, account) in target_accounts.iter().enumerate() {
            let base_size = signal.position_size;
            
            // Apply account-specific variance (5-15%)
            let varied_size = self.variance_generator
                .apply_size_variance(base_size, account.id).await?;
            
            // Apply personality-based adjustments
            let personality_adjusted_size = self.personality_engine
                .apply_personality_sizing(varied_size, account.id).await?;
            
            // Calculate execution delay for this account
            let execution_delay = self.calculate_execution_delay(account, i, target_accounts.len()).await?;
            
            distribution_plan.push(AccountExecution {
                account_id: account.id,
                position_size: personality_adjusted_size,
                execution_delay,
                execution_priority: self.calculate_execution_priority(account, signal).await?,
                variance_applied: (personality_adjusted_size - base_size) / base_size,
            });
        }
        
        // Optimize distribution to minimize correlation
        let optimized_plan = self.distribution_optimizer
            .optimize_distribution(distribution_plan, &correlation_matrix).await?;
        
        Ok(TradeDistribution {
            signal_id: signal.signal_id.clone(),
            accounts: optimized_plan,
            distribution_strategy: "anti_correlation_optimized".to_string(),
            expected_correlation: correlation_check.expected_correlation,
            distribution_timestamp: Utc::now(),
        })
    }
    
    async fn validate_correlation_constraints(
        &self,
        correlation_matrix: &CorrelationMatrix,
        accounts: &[Account],
        signal: &TradingSignal,
    ) -> Result<CorrelationCheck> {
        let max_allowed_correlation = 0.7; // 70% threshold
        
        // Calculate expected correlation if this signal is executed on all accounts
        let expected_correlations = self.simulate_correlation_impact(
            correlation_matrix, accounts, signal
        ).await?;
        
        let max_expected_correlation = expected_correlations.iter()
            .map(|c| c.correlation_coefficient.abs())
            .fold(0.0, f64::max);
        
        let is_viable = max_expected_correlation <= max_allowed_correlation;
        
        if !is_viable {
            // Suggest account reduction to maintain correlation threshold
            let suggested_accounts = self.reduce_accounts_for_correlation(
                accounts, &expected_correlations, max_allowed_correlation
            ).await?;
            
            return Ok(CorrelationCheck {
                is_viable: false,
                expected_correlation: max_expected_correlation,
                threshold: max_allowed_correlation,
                suggested_accounts: Some(suggested_accounts),
            });
        }
        
        Ok(CorrelationCheck {
            is_viable: true,
            expected_correlation: max_expected_correlation,
            threshold: max_allowed_correlation,
            suggested_accounts: None,
        })
    }
}
```

### Execution Timing Variance System
Sophisticated timing control to avoid pattern detection:
```rust
pub struct ExecutionTimingManager {
    delay_generator: Arc<DelayGenerator>,
    market_condition_analyzer: Arc<MarketConditionAnalyzer>,
    timing_personality_engine: Arc<TimingPersonalityEngine>,
    execution_history: Arc<ExecutionHistoryTracker>,
}

impl ExecutionTimingManager {
    pub async fn calculate_execution_delays(&self, executions: &[AccountExecution]) -> Result<Vec<ExecutionTiming>> {
        let mut timing_plan = Vec::new();
        let market_urgency = self.assess_market_urgency().await?;
        
        for (i, execution) in executions.iter().enumerate() {
            let base_delay = self.generate_base_delay(execution.account_id).await?;
            let market_adjusted_delay = self.apply_market_urgency_adjustment(base_delay, market_urgency);
            let personality_adjusted_delay = self.timing_personality_engine
                .apply_personality_timing(market_adjusted_delay, execution.account_id).await?;
            
            // Add staggering between accounts
            let stagger_delay = self.calculate_stagger_delay(i, executions.len());
            let final_delay = personality_adjusted_delay + stagger_delay;
            
            // Ensure minimum and maximum bounds
            let bounded_delay = final_delay.max(Duration::from_secs(1)).min(Duration::from_secs(30));
            
            timing_plan.push(ExecutionTiming {
                account_id: execution.account_id,
                delay: bounded_delay,
                execution_window_start: Utc::now() + bounded_delay,
                execution_window_end: Utc::now() + bounded_delay + Duration::from_secs(30),
                timing_rationale: format!(
                    "Base: {}s, Market: {}s, Personality: {}s, Stagger: {}s",
                    base_delay.as_secs(),
                    market_adjusted_delay.as_secs() - base_delay.as_secs(),
                    personality_adjusted_delay.as_secs() - market_adjusted_delay.as_secs(),
                    stagger_delay.as_secs()
                ),
            });
        }
        
        // Validate timing plan doesn't create detectable patterns
        self.validate_timing_pattern(&timing_plan).await?;
        
        Ok(timing_plan)
    }
    
    async fn generate_base_delay(&self, account_id: AccountId) -> Result<Duration> {
        // Use account-specific randomization seed for consistency
        let account_seed = self.get_account_timing_seed(account_id).await?;
        let mut rng = StdRng::seed_from_u64(account_seed + Utc::now().timestamp() as u64);
        
        // Generate delay between 1-30 seconds with weighted distribution
        // Favor mid-range delays (5-15 seconds) to appear more human-like
        let weights = [0.1, 0.6, 0.3]; // [1-5s: 10%, 5-15s: 60%, 15-30s: 30%]
        let delay_bucket: f64 = rng.gen();
        
        let delay_seconds = if delay_bucket < weights[0] {
            rng.gen_range(1.0..5.0)
        } else if delay_bucket < weights[0] + weights[1] {
            rng.gen_range(5.0..15.0)
        } else {
            rng.gen_range(15.0..30.0)
        };
        
        Ok(Duration::from_secs_f64(delay_seconds))
    }
    
    async fn validate_timing_pattern(&self, timing_plan: &[ExecutionTiming]) -> Result<()> {
        // Check recent execution history for pattern formation
        let recent_executions = self.execution_history
            .get_recent_executions(Duration::from_days(7)).await?;
        
        // Analyze timing intervals for regularity
        let timing_intervals: Vec<Duration> = timing_plan.iter()
            .map(|t| t.delay)
            .collect();
        
        let interval_variance = self.calculate_timing_variance(&timing_intervals);
        
        if interval_variance < 0.2 { // Less than 20% variance indicates pattern
            return Err(Error::TimingPatternDetected);
        }
        
        // Check for time-of-day patterns
        let execution_times: Vec<_> = timing_plan.iter()
            .map(|t| t.execution_window_start.time())
            .collect();
        
        if self.has_time_of_day_pattern(&execution_times) {
            return Err(Error::TimeOfDayPatternDetected);
        }
        
        Ok(())
    }
}
```

### Partial Fill Handling System
Sophisticated partial fill management:
```rust
pub struct PartialFillManager {
    fill_monitor: Arc<FillMonitor>,
    completion_strategies: Arc<CompletionStrategies>,
    timeout_manager: Arc<TimeoutManager>,
    fill_aggregator: Arc<FillAggregator>,
}

impl PartialFillManager {
    pub async fn handle_partial_fill(&self, partial_fill: PartialFill) -> Result<FillHandlingResult> {
        // Assess fill situation
        let fill_analysis = self.analyze_partial_fill(&partial_fill).await?;
        
        // Determine completion strategy
        let strategy = self.select_completion_strategy(&partial_fill, &fill_analysis).await?;
        
        // Execute completion strategy
        match strategy {
            CompletionStrategy::WaitAndRetry { timeout, max_attempts } => {
                self.execute_wait_and_retry_strategy(&partial_fill, timeout, max_attempts).await
            },
            
            CompletionStrategy::ModifyOrder { new_price } => {
                self.execute_order_modification_strategy(&partial_fill, new_price).await
            },
            
            CompletionStrategy::CancelAndReplace { new_order_params } => {
                self.execute_cancel_and_replace_strategy(&partial_fill, new_order_params).await
            },
            
            CompletionStrategy::AcceptPartial => {
                self.execute_accept_partial_strategy(&partial_fill).await
            },
            
            CompletionStrategy::RouteToAlternativeAccount { alternative_account } => {
                self.execute_alternative_routing_strategy(&partial_fill, alternative_account).await
            },
        }
    }
    
    async fn analyze_partial_fill(&self, partial_fill: &PartialFill) -> Result<PartialFillAnalysis> {
        let market_conditions = self.assess_current_market_conditions(&partial_fill.symbol).await?;
        let liquidity_analysis = self.analyze_market_liquidity(&partial_fill.symbol).await?;
        let time_since_placement = Utc::now() - partial_fill.placement_time;
        
        let fill_percentage = partial_fill.filled_quantity / partial_fill.requested_quantity;
        let remaining_quantity = partial_fill.requested_quantity - partial_fill.filled_quantity;
        
        let urgency_level = self.assess_fill_urgency(partial_fill, &market_conditions).await?;
        
        Ok(PartialFillAnalysis {
            fill_percentage,
            remaining_quantity,
            time_elapsed: time_since_placement,
            market_conditions,
            liquidity_analysis,
            urgency_level,
            completion_probability: self.estimate_completion_probability(partial_fill, &market_conditions).await?,
        })
    }
    
    async fn select_completion_strategy(
        &self,
        partial_fill: &PartialFill,
        analysis: &PartialFillAnalysis,
    ) -> Result<CompletionStrategy> {
        // High urgency + good liquidity = modify order closer to market
        if analysis.urgency_level == UrgencyLevel::High && 
           analysis.liquidity_analysis.is_liquid {
            let current_price = self.get_current_price(&partial_fill.symbol).await?;
            let aggressive_price = self.calculate_aggressive_price(
                current_price, partial_fill.side
            );
            return Ok(CompletionStrategy::ModifyOrder { new_price: aggressive_price });
        }
        
        // Low urgency + poor liquidity = wait and retry
        if analysis.urgency_level == UrgencyLevel::Low && 
           !analysis.liquidity_analysis.is_liquid {
            return Ok(CompletionStrategy::WaitAndRetry {
                timeout: Duration::from_secs(300), // 5 minutes
                max_attempts: 3,
            });
        }
        
        // High fill percentage (>80%) = accept partial
        if analysis.fill_percentage > 0.8 {
            return Ok(CompletionStrategy::AcceptPartial);
        }
        
        // Time elapsed > threshold = cancel and route to alternative
        if analysis.time_elapsed > Duration::from_secs(600) { // 10 minutes
            let alternative = self.find_alternative_account(partial_fill).await?;
            return Ok(CompletionStrategy::RouteToAlternativeAccount { 
                alternative_account: alternative 
            });
        }
        
        // Default: wait and retry with moderate timeout
        Ok(CompletionStrategy::WaitAndRetry {
            timeout: Duration::from_secs(120),
            max_attempts: 2,
        })
    }
}
```

### Execution Failure Recovery System
Comprehensive failure handling and recovery:
```rust
pub struct ExecutionFailureRecovery {
    failure_classifier: Arc<FailureClassifier>,
    alternative_router: Arc<AlternativeAccountRouter>,
    retry_manager: Arc<RetryManager>,
    intervention_system: Arc<ManualInterventionSystem>,
}

impl ExecutionFailureRecovery {
    pub async fn handle_execution_failure(&self, failure: ExecutionFailure) -> Result<RecoveryResult> {
        // Classify the failure type and severity
        let classification = self.failure_classifier.classify_failure(&failure).await?;
        
        // Log the failure for analysis
        self.log_failure_event(&failure, &classification).await?;
        
        // Determine recovery strategy
        let recovery_strategy = self.determine_recovery_strategy(&failure, &classification).await?;
        
        // Execute recovery
        let recovery_result = self.execute_recovery_strategy(recovery_strategy).await?;
        
        // Update failure statistics
        self.update_failure_statistics(&failure, &classification, &recovery_result).await?;
        
        Ok(recovery_result)
    }
    
    async fn determine_recovery_strategy(
        &self,
        failure: &ExecutionFailure,
        classification: &FailureClassification,
    ) -> Result<RecoveryStrategy> {
        match (classification.failure_type.as_ref(), classification.severity) {
            ("insufficient_margin", _) => {
                Ok(RecoveryStrategy::ReduceSizeAndRetry {
                    size_reduction: 0.7, // Reduce to 70% of original
                    max_attempts: 2,
                })
            },
            
            ("connection_error", FailureSeverity::Temporary) => {
                Ok(RecoveryStrategy::RetryWithBackoff {
                    initial_delay: Duration::from_secs(5),
                    max_attempts: 3,
                    backoff_factor: 2.0,
                })
            },
            
            ("connection_error", FailureSeverity::Persistent) => {
                let alternative = self.alternative_router
                    .find_alternative_account(&failure.original_request).await?;
                Ok(RecoveryStrategy::RouteToAlternative { 
                    alternative_account: alternative 
                })
            },
            
            ("market_closed", _) => {
                Ok(RecoveryStrategy::ScheduleForNextSession {
                    next_session_start: self.calculate_next_session_start(&failure.symbol).await?,
                })
            },
            
            ("invalid_stops", _) => {
                Ok(RecoveryStrategy::ModifyParametersAndRetry {
                    parameter_modifications: self.suggest_stop_modifications(&failure).await?,
                })
            },
            
            ("account_suspended", _) => {
                Ok(RecoveryStrategy::ExcludeAccountAndReroute {
                    excluded_account: failure.account_id,
                    exclusion_duration: Duration::from_hours(24),
                })
            },
            
            (_, FailureSeverity::Critical) => {
                Ok(RecoveryStrategy::EscalateToManualIntervention {
                    escalation_reason: format!(
                        "Critical failure: {} on account {}", 
                        classification.failure_type, failure.account_id
                    ),
                })
            },
            
            _ => Ok(RecoveryStrategy::LogAndSkip),
        }
    }
    
    async fn execute_recovery_strategy(&self, strategy: RecoveryStrategy) -> Result<RecoveryResult> {
        match strategy {
            RecoveryStrategy::RetryWithBackoff { initial_delay, max_attempts, backoff_factor } => {
                self.retry_manager.execute_retry_with_backoff(
                    initial_delay, max_attempts, backoff_factor
                ).await
            },
            
            RecoveryStrategy::RouteToAlternative { alternative_account } => {
                self.alternative_router.execute_on_alternative(alternative_account).await
            },
            
            RecoveryStrategy::EscalateToManualIntervention { escalation_reason } => {
                self.intervention_system.create_intervention_request(escalation_reason).await
            },
            
            // ... other strategy implementations
        }
    }
}
```

### Comprehensive Execution Audit System
Detailed logging and compliance tracking:
```rust
pub struct ExecutionAuditSystem {
    audit_logger: Arc<AuditLogger>,
    compliance_reporter: Arc<ComplianceReporter>,
    performance_analyzer: Arc<ExecutionPerformanceAnalyzer>,
    replay_system: Arc<ExecutionReplaySystem>,
}

impl ExecutionAuditSystem {
    pub async fn log_execution_decision(&self, decision: ExecutionDecision) -> Result<AuditEntry> {
        let audit_entry = AuditEntry {
            entry_id: Uuid::new_v4(),
            execution_id: decision.execution_id,
            event_type: AuditEventType::ExecutionDecision,
            timestamp: Utc::now(),
            account_id: decision.account_id,
            signal_id: decision.signal_id,
            decision_data: serde_json::to_value(&decision)?,
            decision_rationale: decision.rationale,
            compliance_notes: self.generate_compliance_notes(&decision).await?,
            correlation_id: decision.correlation_id,
        };
        
        // Store in audit database
        self.audit_logger.log_entry(&audit_entry).await?;
        
        // Update performance metrics
        self.performance_analyzer.record_decision(&decision).await?;
        
        Ok(audit_entry)
    }
    
    pub async fn generate_compliance_report(&self, time_range: TimeRange) -> Result<ComplianceReport> {
        let audit_entries = self.audit_logger.get_entries_in_range(time_range).await?;
        
        let mut report = ComplianceReport::new();
        
        for entry in audit_entries {
            // Check account separation compliance
            self.analyze_account_separation(&entry, &mut report).await?;
            
            // Check timing distribution compliance  
            self.analyze_timing_distribution(&entry, &mut report).await?;
            
            // Check position sizing compliance
            self.analyze_position_sizing(&entry, &mut report).await?;
            
            // Check correlation compliance
            self.analyze_correlation_compliance(&entry, &mut report).await?;
        }
        
        // Generate compliance score
        report.compliance_score = self.calculate_compliance_score(&report).await?;
        
        Ok(report)
    }
    
    pub async fn replay_execution(&self, execution_id: ExecutionId) -> Result<ExecutionReplay> {
        let audit_entries = self.audit_logger.get_entries_by_execution(execution_id).await?;
        
        let replay = ExecutionReplay {
            execution_id,
            timeline: self.build_execution_timeline(&audit_entries).await?,
            decision_points: self.extract_decision_points(&audit_entries).await?,
            performance_metrics: self.calculate_execution_performance(&audit_entries).await?,
            compliance_analysis: self.analyze_execution_compliance(&audit_entries).await?,
        };
        
        Ok(replay)
    }
}
```

### Database Schema for Execution Orchestration
```sql
CREATE TABLE execution_decisions (
    decision_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    signal_id UUID REFERENCES trading_signals(signal_id),
    execution_strategy VARCHAR(100) NOT NULL,
    selected_accounts JSONB NOT NULL,
    account_selection_rationale TEXT,
    distribution_plan JSONB NOT NULL,
    timing_plan JSONB NOT NULL,
    correlation_analysis JSONB,
    decision_timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    INDEX idx_execution_decisions_signal (signal_id),
    INDEX idx_execution_decisions_time (decision_timestamp)
);

CREATE TABLE execution_results (
    result_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    decision_id UUID REFERENCES execution_decisions(decision_id),
    account_id UUID REFERENCES trading_accounts(account_id),
    execution_status VARCHAR(20) NOT NULL,
    fill_status VARCHAR(20) NOT NULL,
    filled_quantity DECIMAL(10,4),
    fill_price DECIMAL(10,5),
    execution_latency_ms INTEGER,
    slippage_pips DECIMAL(6,2),
    partial_fills JSONB,
    failure_reason TEXT,
    recovery_actions JSONB,
    completed_at TIMESTAMP WITH TIME ZONE,
    
    INDEX idx_execution_results_decision (decision_id),
    INDEX idx_execution_results_account_time (account_id, completed_at)
);

CREATE TABLE execution_audit_log (
    audit_id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    execution_id UUID NOT NULL,
    event_type VARCHAR(50) NOT NULL,
    account_id UUID,
    event_data JSONB NOT NULL,
    rationale TEXT,
    compliance_notes TEXT,
    correlation_id UUID,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    INDEX idx_audit_log_execution (execution_id),
    INDEX idx_audit_log_time (timestamp),
    INDEX idx_audit_log_correlation (correlation_id)
);
```

### API Endpoints for Orchestration Control
```rust
#[post("/api/v1/execution/orchestrate")]
async fn orchestrate_trade_execution(
    request: web::Json<TradeExecutionRequest>
) -> Result<web::Json<ExecutionPlan>> {
    let orchestrator = get_execution_orchestrator();
    let plan = orchestrator.create_execution_plan(request.into_inner()).await?;
    Ok(web::Json(plan))
}

#[get("/api/v1/execution/status/{execution_id}")]
async fn get_execution_status(
    path: web::Path<ExecutionId>
) -> Result<web::Json<ExecutionStatus>> {
    let status = get_execution_status(path.into_inner()).await?;
    Ok(web::Json(status))
}

#[post("/api/v1/execution/{execution_id}/intervene")]
async fn manual_intervention(
    path: web::Path<ExecutionId>,
    intervention: web::Json<ManualIntervention>
) -> Result<web::Json<InterventionResult>> {
    let result = execute_manual_intervention(
        path.into_inner(), 
        intervention.into_inner()
    ).await?;
    Ok(web::Json(result))
}
```

### Testing Requirements
- **Account selection tests:** Validate selection algorithm with various account states
- **Distribution tests:** Test anti-correlation distribution across multiple accounts
- **Timing variance tests:** Verify execution delays meet 1-30 second requirements
- **Partial fill tests:** Test completion strategies under various market conditions
- **Failure recovery tests:** Validate recovery mechanisms for different failure types
- **Audit compliance tests:** Ensure comprehensive logging meets regulatory requirements
- **Integration tests:** End-to-end orchestration with real market conditions

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-08-06 | 1.0 | Initial story creation | Bob (Scrum Master) |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References  
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review will be populated here*